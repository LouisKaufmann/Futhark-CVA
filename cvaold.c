#ifdef __GNUC__
#pragma GCC diagnostic ignored "-Wunused-function"
#pragma GCC diagnostic ignored "-Wunused-variable"
#pragma GCC diagnostic ignored "-Wparentheses"
#pragma GCC diagnostic ignored "-Wunused-label"
#endif
#ifdef __clang__
#pragma clang diagnostic ignored "-Wunused-function"
#pragma clang diagnostic ignored "-Wunused-variable"
#pragma clang diagnostic ignored "-Wparentheses"
#pragma clang diagnostic ignored "-Wunused-label"
#endif
// Headers

#define _GNU_SOURCE
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>
#define CL_TARGET_OPENCL_VERSION 120
#define CL_USE_DEPRECATED_OPENCL_1_2_APIS
#ifdef __APPLE__
#define CL_SILENCE_DEPRECATION
#include <OpenCL/cl.h>
#else
#include <CL/cl.h>
#endif


// Initialisation

int futhark_get_num_sizes(void);
const char *futhark_get_size_name(int);
const char *futhark_get_size_class(int);
struct futhark_context_config ;
struct futhark_context_config *futhark_context_config_new(void);
void futhark_context_config_free(struct futhark_context_config *cfg);
void futhark_context_config_add_build_option(struct futhark_context_config *cfg,
                                             const char *opt);
void futhark_context_config_set_debugging(struct futhark_context_config *cfg,
                                          int flag);
void futhark_context_config_set_profiling(struct futhark_context_config *cfg,
                                          int flag);
void futhark_context_config_set_logging(struct futhark_context_config *cfg,
                                        int flag);
void futhark_context_config_set_device(struct futhark_context_config *cfg, const
                                       char *s);
void futhark_context_config_set_platform(struct futhark_context_config *cfg,
                                         const char *s);
void
futhark_context_config_select_device_interactively(struct futhark_context_config *cfg);
void futhark_context_config_list_devices(struct futhark_context_config *cfg);
void futhark_context_config_dump_program_to(struct futhark_context_config *cfg,
                                            const char *path);
void
futhark_context_config_load_program_from(struct futhark_context_config *cfg,
                                         const char *path);
void futhark_context_config_dump_binary_to(struct futhark_context_config *cfg,
                                           const char *path);
void futhark_context_config_load_binary_from(struct futhark_context_config *cfg,
                                             const char *path);
void
futhark_context_config_set_default_group_size(struct futhark_context_config *cfg,
                                              int size);
void
futhark_context_config_set_default_num_groups(struct futhark_context_config *cfg,
                                              int num);
void
futhark_context_config_set_default_tile_size(struct futhark_context_config *cfg,
                                             int num);
void
futhark_context_config_set_default_threshold(struct futhark_context_config *cfg,
                                             int num);
int futhark_context_config_set_size(struct futhark_context_config *cfg, const
                                    char *size_name, size_t size_value);
struct futhark_context ;
struct futhark_context *futhark_context_new(struct futhark_context_config *cfg);
struct futhark_context
*futhark_context_new_with_command_queue(struct futhark_context_config *cfg,
                                        cl_command_queue queue);
void futhark_context_free(struct futhark_context *ctx);
cl_command_queue futhark_context_get_command_queue(struct futhark_context *ctx);

// Arrays

struct futhark_f32_1d ;
struct futhark_f32_1d *futhark_new_f32_1d(struct futhark_context *ctx, const
                                          float *data, int64_t dim0);
struct futhark_f32_1d *futhark_new_raw_f32_1d(struct futhark_context *ctx, const
                                              cl_mem data, int offset,
                                              int64_t dim0);
int futhark_free_f32_1d(struct futhark_context *ctx,
                        struct futhark_f32_1d *arr);
int futhark_values_f32_1d(struct futhark_context *ctx,
                          struct futhark_f32_1d *arr, float *data);
cl_mem futhark_values_raw_f32_1d(struct futhark_context *ctx,
                                 struct futhark_f32_1d *arr);
const int64_t *futhark_shape_f32_1d(struct futhark_context *ctx,
                                    struct futhark_f32_1d *arr);
struct futhark_i64_1d ;
struct futhark_i64_1d *futhark_new_i64_1d(struct futhark_context *ctx, const
                                          int64_t *data, int64_t dim0);
struct futhark_i64_1d *futhark_new_raw_i64_1d(struct futhark_context *ctx, const
                                              cl_mem data, int offset,
                                              int64_t dim0);
int futhark_free_i64_1d(struct futhark_context *ctx,
                        struct futhark_i64_1d *arr);
int futhark_values_i64_1d(struct futhark_context *ctx,
                          struct futhark_i64_1d *arr, int64_t *data);
cl_mem futhark_values_raw_i64_1d(struct futhark_context *ctx,
                                 struct futhark_i64_1d *arr);
const int64_t *futhark_shape_i64_1d(struct futhark_context *ctx,
                                    struct futhark_i64_1d *arr);

// Opaque values


// Entry points

int futhark_entry_main(struct futhark_context *ctx, float *out0,
                       struct futhark_f32_1d **out1, const int64_t in0, const
                       int64_t in1, const struct futhark_f32_1d *in2, const
                       struct futhark_i64_1d *in3, const
                       struct futhark_f32_1d *in4, const float in5, const
                       float in6, const float in7, const float in8);
int futhark_entry_test(struct futhark_context *ctx, float *out0, const
                       int64_t in0, const int64_t in1);

// Miscellaneous

int futhark_context_sync(struct futhark_context *ctx);
int futhark_context_clear_caches(struct futhark_context *ctx);
char *futhark_context_report(struct futhark_context *ctx);
char *futhark_context_get_error(struct futhark_context *ctx);
void futhark_context_pause_profiling(struct futhark_context *ctx);
void futhark_context_unpause_profiling(struct futhark_context *ctx);
#define FUTHARK_BACKEND_opencl
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <math.h>
#include <stdint.h>
#undef NDEBUG
#include <assert.h>
#include <stdarg.h>
// Start of util.h.
//
// Various helper functions that are useful in all generated C code.

#include <errno.h>
#include <string.h>

static const char *fut_progname = "(embedded Futhark)";

static void futhark_panic(int eval, const char *fmt, ...) {
  va_list ap;
  va_start(ap, fmt);
  fprintf(stderr, "%s: ", fut_progname);
  vfprintf(stderr, fmt, ap);
  va_end(ap);
  exit(eval);
}

// For generating arbitrary-sized error messages.  It is the callers
// responsibility to free the buffer at some point.
static char* msgprintf(const char *s, ...) {
  va_list vl;
  va_start(vl, s);
  size_t needed = 1 + (size_t)vsnprintf(NULL, 0, s, vl);
  char *buffer = (char*) malloc(needed);
  va_start(vl, s); // Must re-init.
  vsnprintf(buffer, needed, s, vl);
  return buffer;
}


static inline void check_err(int errval, int sets_errno, const char *fun, int line,
                            const char *msg, ...)
{
  if (errval) {
    char str[256];
    char errnum[10];
    sprintf(errnum, "%d", errval);
    sprintf(str, "ERROR: %s in %s() at line %d with error code %s\n", msg, fun, line,
            sets_errno ? strerror(errno) : errnum);
    fprintf(stderr, "%s", str);
    exit(errval);
  }
}

#define CHECK_ERR(err, msg...) check_err(err, 0, __func__, __LINE__, msg)
#define CHECK_ERRNO(err, msg...) check_err(err, 1, __func__, __LINE__, msg)

// Read a file into a NUL-terminated string; returns NULL on error.
static void* slurp_file(const char *filename, size_t *size) {
  unsigned char *s;
  FILE *f = fopen(filename, "rb"); // To avoid Windows messing with linebreaks.
  if (f == NULL) return NULL;
  fseek(f, 0, SEEK_END);
  size_t src_size = ftell(f);
  fseek(f, 0, SEEK_SET);
  s = (unsigned char*) malloc(src_size + 1);
  if (fread(s, 1, src_size, f) != src_size) {
    free(s);
    s = NULL;
  } else {
    s[src_size] = '\0';
  }
  fclose(f);

  if (size) {
    *size = src_size;
  }

  return s;
}

// Dump 'n' bytes from 'buf' into the file at the designated location.
// Returns 0 on success.
static int dump_file(const char *file, const void *buf, size_t n) {
  FILE *f = fopen(file, "w");

  if (f == NULL) {
    return 1;
  }

  if (fwrite(buf, sizeof(char), n, f) != n) {
    return 1;
  }

  if (fclose(f) != 0) {
    return 1;
  }

  return 0;
}

struct str_builder {
  char *str;
  size_t capacity; // Size of buffer.
  size_t used; // Bytes used, *not* including final zero.
};

static void str_builder_init(struct str_builder *b) {
  b->capacity = 10;
  b->used = 0;
  b->str = malloc(b->capacity);
  b->str[0] = 0;
}

static void str_builder(struct str_builder *b, const char *s, ...) {
  va_list vl;
  va_start(vl, s);
  size_t needed = (size_t)vsnprintf(NULL, 0, s, vl);

  while (b->capacity < b->used + needed + 1) {
    b->capacity *= 2;
    b->str = realloc(b->str, b->capacity);
  }

  va_start(vl, s); // Must re-init.
  vsnprintf(b->str+b->used, b->capacity-b->used, s, vl);
  b->used += needed;
}

// End of util.h.

// Start of timing.h.

// The function get_wall_time() returns the wall time in microseconds
// (with an unspecified offset).

#ifdef _WIN32

#include <windows.h>

static int64_t get_wall_time(void) {
  LARGE_INTEGER time,freq;
  assert(QueryPerformanceFrequency(&freq));
  assert(QueryPerformanceCounter(&time));
  return ((double)time.QuadPart / freq.QuadPart) * 1000000;
}

#else
// Assuming POSIX

#include <time.h>
#include <sys/time.h>

static int64_t get_wall_time(void) {
  struct timeval time;
  assert(gettimeofday(&time,NULL) == 0);
  return time.tv_sec * 1000000 + time.tv_usec;
}

static int64_t get_wall_time_ns(void) {
  struct timespec time;
  assert(clock_gettime(CLOCK_REALTIME, &time) == 0);
  return time.tv_sec * 1000000000 + time.tv_nsec;
}


static inline uint64_t rdtsc() {
  unsigned int hi, lo;
  __asm__ __volatile__("rdtsc" : "=a"(lo), "=d"(hi));
  return  ((uint64_t) lo) | (((uint64_t) hi) << 32);
}

static inline void rdtsc_wait(uint64_t n) {
  const uint64_t start = rdtsc();
  while (rdtsc() < (start + n)) {
    __asm__("PAUSE");
  }
}
static inline void spin_for(uint64_t nb_cycles) {
  rdtsc_wait(nb_cycles);
}


#endif

// End of timing.h.

#include <string.h>
#include <inttypes.h>
#include <errno.h>
#include <ctype.h>
#include <errno.h>
#include <getopt.h>
// Start of values.h.

//// Text I/O

typedef int (*writer)(FILE*, const void*);
typedef int (*bin_reader)(void*);
typedef int (*str_reader)(const char *, void*);

struct array_reader {
  char* elems;
  int64_t n_elems_space;
  int64_t elem_size;
  int64_t n_elems_used;
  int64_t *shape;
  str_reader elem_reader;
};

static void skipspaces() {
  int c;
  do {
    c = getchar();
  } while (isspace(c));

  if (c != EOF) {
    ungetc(c, stdin);
  }
}

static int constituent(char c) {
  return isalnum(c) || c == '.' || c == '-' || c == '+' || c == '_';
}

// Produces an empty token only on EOF.
static void next_token(char *buf, int bufsize) {
 start:
  skipspaces();

  int i = 0;
  while (i < bufsize) {
    int c = getchar();
    buf[i] = (char)c;

    if (c == EOF) {
      buf[i] = 0;
      return;
    } else if (c == '-' && i == 1 && buf[0] == '-') {
      // Line comment, so skip to end of line and start over.
      for (; c != '\n' && c != EOF; c = getchar());
      goto start;
    } else if (!constituent((char)c)) {
      if (i == 0) {
        // We permit single-character tokens that are not
        // constituents; this lets things like ']' and ',' be
        // tokens.
        buf[i+1] = 0;
        return;
      } else {
        ungetc(c, stdin);
        buf[i] = 0;
        return;
      }
    }

    i++;
  }

  buf[bufsize-1] = 0;
}

static int next_token_is(char *buf, int bufsize, const char* expected) {
  next_token(buf, bufsize);
  return strcmp(buf, expected) == 0;
}

static void remove_underscores(char *buf) {
  char *w = buf;

  for (char *r = buf; *r; r++) {
    if (*r != '_') {
      *w++ = *r;
    }
  }

  *w++ = 0;
}

static int read_str_elem(char *buf, struct array_reader *reader) {
  int ret;
  if (reader->n_elems_used == reader->n_elems_space) {
    reader->n_elems_space *= 2;
    reader->elems = (char*) realloc(reader->elems,
                                    (size_t)(reader->n_elems_space * reader->elem_size));
  }

  ret = reader->elem_reader(buf, reader->elems + reader->n_elems_used * reader->elem_size);

  if (ret == 0) {
    reader->n_elems_used++;
  }

  return ret;
}

static int read_str_array_elems(char *buf, int bufsize,
                                struct array_reader *reader, int64_t dims) {
  int ret;
  int first = 1;
  char *knows_dimsize = (char*) calloc((size_t)dims, sizeof(char));
  int cur_dim = dims-1;
  int64_t *elems_read_in_dim = (int64_t*) calloc((size_t)dims, sizeof(int64_t));

  while (1) {
    next_token(buf, bufsize);

    if (strcmp(buf, "]") == 0) {
      if (knows_dimsize[cur_dim]) {
        if (reader->shape[cur_dim] != elems_read_in_dim[cur_dim]) {
          ret = 1;
          break;
        }
      } else {
        knows_dimsize[cur_dim] = 1;
        reader->shape[cur_dim] = elems_read_in_dim[cur_dim];
      }
      if (cur_dim == 0) {
        ret = 0;
        break;
      } else {
        cur_dim--;
        elems_read_in_dim[cur_dim]++;
      }
    } else if (strcmp(buf, ",") == 0) {
      next_token(buf, bufsize);
      if (strcmp(buf, "[") == 0) {
        if (cur_dim == dims - 1) {
          ret = 1;
          break;
        }
        first = 1;
        cur_dim++;
        elems_read_in_dim[cur_dim] = 0;
      } else if (cur_dim == dims - 1) {
        ret = read_str_elem(buf, reader);
        if (ret != 0) {
          break;
        }
        elems_read_in_dim[cur_dim]++;
      } else {
        ret = 1;
        break;
      }
    } else if (strlen(buf) == 0) {
      // EOF
      ret = 1;
      break;
    } else if (first) {
      if (strcmp(buf, "[") == 0) {
        if (cur_dim == dims - 1) {
          ret = 1;
          break;
        }
        cur_dim++;
        elems_read_in_dim[cur_dim] = 0;
      } else {
        ret = read_str_elem(buf, reader);
        if (ret != 0) {
          break;
        }
        elems_read_in_dim[cur_dim]++;
        first = 0;
      }
    } else {
      ret = 1;
      break;
    }
  }

  free(knows_dimsize);
  free(elems_read_in_dim);
  return ret;
}

static int read_str_empty_array(char *buf, int bufsize,
                                const char *type_name, int64_t *shape, int64_t dims) {
  if (strlen(buf) == 0) {
    // EOF
    return 1;
  }

  if (strcmp(buf, "empty") != 0) {
    return 1;
  }

  if (!next_token_is(buf, bufsize, "(")) {
    return 1;
  }

  for (int i = 0; i < dims; i++) {
    if (!next_token_is(buf, bufsize, "[")) {
      return 1;
    }

    next_token(buf, bufsize);

    if (sscanf(buf, "%"SCNu64, (uint64_t*)&shape[i]) != 1) {
      return 1;
    }

    if (!next_token_is(buf, bufsize, "]")) {
      return 1;
    }
  }

  if (!next_token_is(buf, bufsize, type_name)) {
    return 1;
  }


  if (!next_token_is(buf, bufsize, ")")) {
    return 1;
  }

  // Check whether the array really is empty.
  for (int i = 0; i < dims; i++) {
    if (shape[i] == 0) {
      return 0;
    }
  }

  // Not an empty array!
  return 1;
}

static int read_str_array(int64_t elem_size, str_reader elem_reader,
                          const char *type_name,
                          void **data, int64_t *shape, int64_t dims) {
  int ret;
  struct array_reader reader;
  char buf[100];

  int dims_seen;
  for (dims_seen = 0; dims_seen < dims; dims_seen++) {
    if (!next_token_is(buf, sizeof(buf), "[")) {
      break;
    }
  }

  if (dims_seen == 0) {
    return read_str_empty_array(buf, sizeof(buf), type_name, shape, dims);
  }

  if (dims_seen != dims) {
    return 1;
  }

  reader.shape = shape;
  reader.n_elems_used = 0;
  reader.elem_size = elem_size;
  reader.n_elems_space = 16;
  reader.elems = (char*) realloc(*data, (size_t)(elem_size*reader.n_elems_space));
  reader.elem_reader = elem_reader;

  ret = read_str_array_elems(buf, sizeof(buf), &reader, dims);

  *data = reader.elems;

  return ret;
}

#define READ_STR(MACRO, PTR, SUFFIX)                                   \
  remove_underscores(buf);                                              \
  int j;                                                                \
  if (sscanf(buf, "%"MACRO"%n", (PTR*)dest, &j) == 1) {                 \
    return !(strcmp(buf+j, "") == 0 || strcmp(buf+j, SUFFIX) == 0);     \
  } else {                                                              \
    return 1;                                                           \
  }

static int read_str_i8(char *buf, void* dest) {
  // Some platforms (WINDOWS) does not support scanf %hhd or its
  // cousin, %SCNi8.  Read into int first to avoid corrupting
  // memory.
  //
  // https://gcc.gnu.org/bugzilla/show_bug.cgi?id=63417
  remove_underscores(buf);
  int j, x;
  if (sscanf(buf, "%i%n", &x, &j) == 1) {
    *(int8_t*)dest = (int8_t)x;
    return !(strcmp(buf+j, "") == 0 || strcmp(buf+j, "i8") == 0);
  } else {
    return 1;
  }
}

static int read_str_u8(char *buf, void* dest) {
  // Some platforms (WINDOWS) does not support scanf %hhd or its
  // cousin, %SCNu8.  Read into int first to avoid corrupting
  // memory.
  //
  // https://gcc.gnu.org/bugzilla/show_bug.cgi?id=63417
  remove_underscores(buf);
  int j, x;
  if (sscanf(buf, "%i%n", &x, &j) == 1) {
    *(uint8_t*)dest = (uint8_t)x;
    return !(strcmp(buf+j, "") == 0 || strcmp(buf+j, "u8") == 0);
  } else {
    return 1;
  }
}

static int read_str_i16(char *buf, void* dest) {
  READ_STR(SCNi16, int16_t, "i16");
}

static int read_str_u16(char *buf, void* dest) {
  READ_STR(SCNi16, int16_t, "u16");
}

static int read_str_i32(char *buf, void* dest) {
  READ_STR(SCNi32, int32_t, "i32");
}

static int read_str_u32(char *buf, void* dest) {
  READ_STR(SCNi32, int32_t, "u32");
}

static int read_str_i64(char *buf, void* dest) {
  READ_STR(SCNi64, int64_t, "i64");
}

static int read_str_u64(char *buf, void* dest) {
  // FIXME: This is not correct, as SCNu64 only permits decimal
  // literals.  However, SCNi64 does not handle very large numbers
  // correctly (it's really for signed numbers, so that's fair).
  READ_STR(SCNu64, uint64_t, "u64");
}

static int read_str_f32(char *buf, void* dest) {
  remove_underscores(buf);
  if (strcmp(buf, "f32.nan") == 0) {
    *(float*)dest = NAN;
    return 0;
  } else if (strcmp(buf, "f32.inf") == 0) {
    *(float*)dest = INFINITY;
    return 0;
  } else if (strcmp(buf, "-f32.inf") == 0) {
    *(float*)dest = -INFINITY;
    return 0;
  } else {
    READ_STR("f", float, "f32");
  }
}

static int read_str_f64(char *buf, void* dest) {
  remove_underscores(buf);
  if (strcmp(buf, "f64.nan") == 0) {
    *(double*)dest = NAN;
    return 0;
  } else if (strcmp(buf, "f64.inf") == 0) {
    *(double*)dest = INFINITY;
    return 0;
  } else if (strcmp(buf, "-f64.inf") == 0) {
    *(double*)dest = -INFINITY;
    return 0;
  } else {
    READ_STR("lf", double, "f64");
  }
}

static int read_str_bool(char *buf, void* dest) {
  if (strcmp(buf, "true") == 0) {
    *(char*)dest = 1;
    return 0;
  } else if (strcmp(buf, "false") == 0) {
    *(char*)dest = 0;
    return 0;
  } else {
    return 1;
  }
}

static int write_str_i8(FILE *out, int8_t *src) {
  return fprintf(out, "%hhdi8", *src);
}

static int write_str_u8(FILE *out, uint8_t *src) {
  return fprintf(out, "%hhuu8", *src);
}

static int write_str_i16(FILE *out, int16_t *src) {
  return fprintf(out, "%hdi16", *src);
}

static int write_str_u16(FILE *out, uint16_t *src) {
  return fprintf(out, "%huu16", *src);
}

static int write_str_i32(FILE *out, int32_t *src) {
  return fprintf(out, "%di32", *src);
}

static int write_str_u32(FILE *out, uint32_t *src) {
  return fprintf(out, "%uu32", *src);
}

static int write_str_i64(FILE *out, int64_t *src) {
  return fprintf(out, "%"PRIi64"i64", *src);
}

static int write_str_u64(FILE *out, uint64_t *src) {
  return fprintf(out, "%"PRIu64"u64", *src);
}

static int write_str_f32(FILE *out, float *src) {
  float x = *src;
  if (isnan(x)) {
    return fprintf(out, "f32.nan");
  } else if (isinf(x) && x >= 0) {
    return fprintf(out, "f32.inf");
  } else if (isinf(x)) {
    return fprintf(out, "-f32.inf");
  } else {
    return fprintf(out, "%.6ff32", x);
  }
}

static int write_str_f64(FILE *out, double *src) {
  double x = *src;
  if (isnan(x)) {
    return fprintf(out, "f64.nan");
  } else if (isinf(x) && x >= 0) {
    return fprintf(out, "f64.inf");
  } else if (isinf(x)) {
    return fprintf(out, "-f64.inf");
  } else {
    return fprintf(out, "%.6ff64", *src);
  }
}

static int write_str_bool(FILE *out, void *src) {
  return fprintf(out, *(char*)src ? "true" : "false");
}

//// Binary I/O

#define BINARY_FORMAT_VERSION 2
#define IS_BIG_ENDIAN (!*(unsigned char *)&(uint16_t){1})

static void flip_bytes(int elem_size, unsigned char *elem) {
  for (int j=0; j<elem_size/2; j++) {
    unsigned char head = elem[j];
    int tail_index = elem_size-1-j;
    elem[j] = elem[tail_index];
    elem[tail_index] = head;
  }
}

// On Windows we need to explicitly set the file mode to not mangle
// newline characters.  On *nix there is no difference.
#ifdef _WIN32
#include <io.h>
#include <fcntl.h>
static void set_binary_mode(FILE *f) {
  setmode(fileno(f), O_BINARY);
}
#else
static void set_binary_mode(FILE *f) {
  (void)f;
}
#endif

static int read_byte(void* dest) {
  int num_elems_read = fread(dest, 1, 1, stdin);
  return num_elems_read == 1 ? 0 : 1;
}

//// Types

struct primtype_info_t {
  const char binname[4]; // Used for parsing binary data.
  const char* type_name; // Same name as in Futhark.
  const int64_t size; // in bytes
  const writer write_str; // Write in text format.
  const str_reader read_str; // Read in text format.
};

static const struct primtype_info_t i8_info =
  {.binname = "  i8", .type_name = "i8",   .size = 1,
   .write_str = (writer)write_str_i8, .read_str = (str_reader)read_str_i8};
static const struct primtype_info_t i16_info =
  {.binname = " i16", .type_name = "i16",  .size = 2,
   .write_str = (writer)write_str_i16, .read_str = (str_reader)read_str_i16};
static const struct primtype_info_t i32_info =
  {.binname = " i32", .type_name = "i32",  .size = 4,
   .write_str = (writer)write_str_i32, .read_str = (str_reader)read_str_i32};
static const struct primtype_info_t i64_info =
  {.binname = " i64", .type_name = "i64",  .size = 8,
   .write_str = (writer)write_str_i64, .read_str = (str_reader)read_str_i64};
static const struct primtype_info_t u8_info =
  {.binname = "  u8", .type_name = "u8",   .size = 1,
   .write_str = (writer)write_str_u8, .read_str = (str_reader)read_str_u8};
static const struct primtype_info_t u16_info =
  {.binname = " u16", .type_name = "u16",  .size = 2,
   .write_str = (writer)write_str_u16, .read_str = (str_reader)read_str_u16};
static const struct primtype_info_t u32_info =
  {.binname = " u32", .type_name = "u32",  .size = 4,
   .write_str = (writer)write_str_u32, .read_str = (str_reader)read_str_u32};
static const struct primtype_info_t u64_info =
  {.binname = " u64", .type_name = "u64",  .size = 8,
   .write_str = (writer)write_str_u64, .read_str = (str_reader)read_str_u64};
static const struct primtype_info_t f32_info =
  {.binname = " f32", .type_name = "f32",  .size = 4,
   .write_str = (writer)write_str_f32, .read_str = (str_reader)read_str_f32};
static const struct primtype_info_t f64_info =
  {.binname = " f64", .type_name = "f64",  .size = 8,
   .write_str = (writer)write_str_f64, .read_str = (str_reader)read_str_f64};
static const struct primtype_info_t bool_info =
  {.binname = "bool", .type_name = "bool", .size = 1,
   .write_str = (writer)write_str_bool, .read_str = (str_reader)read_str_bool};

static const struct primtype_info_t* primtypes[] = {
  &i8_info, &i16_info, &i32_info, &i64_info,
  &u8_info, &u16_info, &u32_info, &u64_info,
  &f32_info, &f64_info,
  &bool_info,
  NULL // NULL-terminated
};

// General value interface.  All endian business taken care of at
// lower layers.

static int read_is_binary() {
  skipspaces();
  int c = getchar();
  if (c == 'b') {
    int8_t bin_version;
    int ret = read_byte(&bin_version);

    if (ret != 0) { futhark_panic(1, "binary-input: could not read version.\n"); }

    if (bin_version != BINARY_FORMAT_VERSION) {
      futhark_panic(1, "binary-input: File uses version %i, but I only understand version %i.\n",
            bin_version, BINARY_FORMAT_VERSION);
    }

    return 1;
  }
  ungetc(c, stdin);
  return 0;
}

static const struct primtype_info_t* read_bin_read_type_enum() {
  char read_binname[4];

  int num_matched = scanf("%4c", read_binname);
  if (num_matched != 1) { futhark_panic(1, "binary-input: Couldn't read element type.\n"); }

  const struct primtype_info_t **type = primtypes;

  for (; *type != NULL; type++) {
    // I compare the 4 characters manually instead of using strncmp because
    // this allows any value to be used, also NULL bytes
    if (memcmp(read_binname, (*type)->binname, 4) == 0) {
      return *type;
    }
  }
  futhark_panic(1, "binary-input: Did not recognize the type '%s'.\n", read_binname);
  return NULL;
}

static void read_bin_ensure_scalar(const struct primtype_info_t *expected_type) {
  int8_t bin_dims;
  int ret = read_byte(&bin_dims);
  if (ret != 0) { futhark_panic(1, "binary-input: Couldn't get dims.\n"); }

  if (bin_dims != 0) {
    futhark_panic(1, "binary-input: Expected scalar (0 dimensions), but got array with %i dimensions.\n",
          bin_dims);
  }

  const struct primtype_info_t *bin_type = read_bin_read_type_enum();
  if (bin_type != expected_type) {
    futhark_panic(1, "binary-input: Expected scalar of type %s but got scalar of type %s.\n",
          expected_type->type_name,
          bin_type->type_name);
  }
}

//// High-level interface

static int read_bin_array(const struct primtype_info_t *expected_type, void **data, int64_t *shape, int64_t dims) {
  int ret;

  int8_t bin_dims;
  ret = read_byte(&bin_dims);
  if (ret != 0) { futhark_panic(1, "binary-input: Couldn't get dims.\n"); }

  if (bin_dims != dims) {
    futhark_panic(1, "binary-input: Expected %i dimensions, but got array with %i dimensions.\n",
          dims, bin_dims);
  }

  const struct primtype_info_t *bin_primtype = read_bin_read_type_enum();
  if (expected_type != bin_primtype) {
    futhark_panic(1, "binary-input: Expected %iD-array with element type '%s' but got %iD-array with element type '%s'.\n",
          dims, expected_type->type_name, dims, bin_primtype->type_name);
  }

  int64_t elem_count = 1;
  for (int i=0; i<dims; i++) {
    int64_t bin_shape;
    ret = fread(&bin_shape, sizeof(bin_shape), 1, stdin);
    if (ret != 1) {
      futhark_panic(1, "binary-input: Couldn't read size for dimension %i of array.\n", i);
    }
    if (IS_BIG_ENDIAN) {
      flip_bytes(sizeof(bin_shape), (unsigned char*) &bin_shape);
    }
    elem_count *= bin_shape;
    shape[i] = bin_shape;
  }

  int64_t elem_size = expected_type->size;
  void* tmp = realloc(*data, (size_t)(elem_count * elem_size));
  if (tmp == NULL) {
    futhark_panic(1, "binary-input: Failed to allocate array of size %i.\n",
          elem_count * elem_size);
  }
  *data = tmp;

  int64_t num_elems_read = (int64_t)fread(*data, (size_t)elem_size, (size_t)elem_count, stdin);
  if (num_elems_read != elem_count) {
    futhark_panic(1, "binary-input: tried to read %i elements of an array, but only got %i elements.\n",
          elem_count, num_elems_read);
  }

  // If we're on big endian platform we must change all multibyte elements
  // from using little endian to big endian
  if (IS_BIG_ENDIAN && elem_size != 1) {
    flip_bytes(elem_size, (unsigned char*) *data);
  }

  return 0;
}

static int read_array(const struct primtype_info_t *expected_type, void **data, int64_t *shape, int64_t dims) {
  if (!read_is_binary()) {
    return read_str_array(expected_type->size, (str_reader)expected_type->read_str, expected_type->type_name, data, shape, dims);
  } else {
    return read_bin_array(expected_type, data, shape, dims);
  }
}

static int end_of_input() {
  skipspaces();
  char token[2];
  next_token(token, sizeof(token));
  if (strcmp(token, "") == 0) {
    return 0;
  } else {
    return 1;
  }
}

static int write_str_array(FILE *out,
                           const struct primtype_info_t *elem_type,
                           const unsigned char *data,
                           const int64_t *shape,
                           int8_t rank) {
  if (rank==0) {
    elem_type->write_str(out, (void*)data);
  } else {
    int64_t len = (int64_t)shape[0];
    int64_t slice_size = 1;

    int64_t elem_size = elem_type->size;
    for (int8_t i = 1; i < rank; i++) {
      slice_size *= shape[i];
    }

    if (len*slice_size == 0) {
      printf("empty(");
      for (int64_t i = 0; i < rank; i++) {
        printf("[%"PRIi64"]", shape[i]);
      }
      printf("%s", elem_type->type_name);
      printf(")");
    } else if (rank==1) {
      putchar('[');
      for (int64_t i = 0; i < len; i++) {
        elem_type->write_str(out, (void*) (data + i * elem_size));
        if (i != len-1) {
          printf(", ");
        }
      }
      putchar(']');
    } else {
      putchar('[');
      for (int64_t i = 0; i < len; i++) {
        write_str_array(out, elem_type, data + i * slice_size * elem_size, shape+1, rank-1);
        if (i != len-1) {
          printf(", ");
        }
      }
      putchar(']');
    }
  }
  return 0;
}

static int write_bin_array(FILE *out,
                           const struct primtype_info_t *elem_type,
                           const unsigned char *data,
                           const int64_t *shape,
                           int8_t rank) {
  int64_t num_elems = 1;
  for (int64_t i = 0; i < rank; i++) {
    num_elems *= shape[i];
  }

  fputc('b', out);
  fputc((char)BINARY_FORMAT_VERSION, out);
  fwrite(&rank, sizeof(int8_t), 1, out);
  fputs(elem_type->binname, out);
  if (shape != NULL) {
    fwrite(shape, sizeof(int64_t), (size_t)rank, out);
  }

  if (IS_BIG_ENDIAN) {
    for (int64_t i = 0; i < num_elems; i++) {
      const unsigned char *elem = data+i*elem_type->size;
      for (int64_t j = 0; j < elem_type->size; j++) {
        fwrite(&elem[elem_type->size-j], 1, 1, out);
      }
    }
  } else {
    fwrite(data, (size_t)elem_type->size, (size_t)num_elems, out);
  }

  return 0;
}

static int write_array(FILE *out, int write_binary,
                       const struct primtype_info_t *elem_type,
                       const void *data,
                       const int64_t *shape,
                       const int8_t rank) {
  if (write_binary) {
    return write_bin_array(out, elem_type, data, shape, rank);
  } else {
    return write_str_array(out, elem_type, data, shape, rank);
  }
}

static int read_scalar(const struct primtype_info_t *expected_type, void *dest) {
  if (!read_is_binary()) {
    char buf[100];
    next_token(buf, sizeof(buf));
    return expected_type->read_str(buf, dest);
  } else {
    read_bin_ensure_scalar(expected_type);
    int64_t elem_size = expected_type->size;
    int num_elems_read = fread(dest, (size_t)elem_size, 1, stdin);
    if (IS_BIG_ENDIAN) {
      flip_bytes(elem_size, (unsigned char*) dest);
    }
    return num_elems_read == 1 ? 0 : 1;
  }
}

static int write_scalar(FILE *out, int write_binary, const struct primtype_info_t *type, void *src) {
  if (write_binary) {
    return write_bin_array(out, type, src, NULL, 0);
  } else {
    return type->write_str(out, src);
  }
}

// End of values.h.

#define __private
static int binary_output = 0;
static FILE *runtime_file;
static int perform_warmup = 0;
static int num_runs = 1;
static const char *entry_point = "main";
// Start of tuning.h.

static char* load_tuning_file(const char *fname,
                              void *cfg,
                              int (*set_size)(void*, const char*, size_t)) {
  const int max_line_len = 1024;
  char* line = (char*) malloc(max_line_len);

  FILE *f = fopen(fname, "r");

  if (f == NULL) {
    snprintf(line, max_line_len, "Cannot open file: %s", strerror(errno));
    return line;
  }

  int lineno = 0;
  while (fgets(line, max_line_len, f) != NULL) {
    lineno++;
    char *eql = strstr(line, "=");
    if (eql) {
      *eql = 0;
      int value = atoi(eql+1);
      if (set_size(cfg, line, value) != 0) {
        strncpy(eql+1, line, max_line_len-strlen(line)-1);
        snprintf(line, max_line_len, "Unknown name '%s' on line %d.", eql+1, lineno);
        return line;
      }
    } else {
      snprintf(line, max_line_len, "Invalid line %d (must be of form 'name=int').",
               lineno);
      return line;
    }
  }

  free(line);

  return NULL;
}

// End of tuning.h.

int parse_options(struct futhark_context_config *cfg, int argc,
                  char *const argv[])
{
    int ch;
    static struct option long_options[] = {{"write-runtime-to",
                                            required_argument, NULL, 1},
                                           {"runs", required_argument, NULL, 2},
                                           {"debugging", no_argument, NULL, 3},
                                           {"log", no_argument, NULL, 4},
                                           {"entry-point", required_argument,
                                            NULL, 5}, {"binary-output",
                                                       no_argument, NULL, 6},
                                           {"help", no_argument, NULL, 7},
                                           {"device", required_argument, NULL,
                                            8}, {"default-group-size",
                                                 required_argument, NULL, 9},
                                           {"default-num-groups",
                                            required_argument, NULL, 10},
                                           {"default-tile-size",
                                            required_argument, NULL, 11},
                                           {"default-threshold",
                                            required_argument, NULL, 12},
                                           {"print-sizes", no_argument, NULL,
                                            13}, {"size", required_argument,
                                                  NULL, 14}, {"tuning",
                                                              required_argument,
                                                              NULL, 15},
                                           {"platform", required_argument, NULL,
                                            16}, {"dump-opencl",
                                                  required_argument, NULL, 17},
                                           {"load-opencl", required_argument,
                                            NULL, 18}, {"dump-opencl-binary",
                                                        required_argument, NULL,
                                                        19},
                                           {"load-opencl-binary",
                                            required_argument, NULL, 20},
                                           {"build-option", required_argument,
                                            NULL, 21}, {"profile", no_argument,
                                                        NULL, 22},
                                           {"list-devices", no_argument, NULL,
                                            23}, {0, 0, 0, 0}};
    static char *option_descriptions =
                "  -t/--write-runtime-to FILE Print the time taken to execute the program to the indicated file, an integral number of microseconds.\n  -r/--runs INT              Perform NUM runs of the program.\n  -D/--debugging             Perform possibly expensive internal correctness checks and verbose logging.\n  -L/--log                   Print various low-overhead logging information to stderr while running.\n  -e/--entry-point NAME      The entry point to run. Defaults to main.\n  -b/--binary-output         Print the program result in the binary output format.\n  -h/--help                  Print help information and exit.\n  -d/--device NAME           Use the first OpenCL device whose name contains the given string.\n  --default-group-size INT   The default size of OpenCL workgroups that are launched.\n  --default-num-groups INT   The default number of OpenCL workgroups that are launched.\n  --default-tile-size INT    The default tile size used when performing two-dimensional tiling.\n  --default-threshold INT    The default parallelism threshold.\n  --print-sizes              Print all sizes that can be set with -size or --tuning.\n  --size ASSIGNMENT          Set a configurable run-time parameter to the given value.\n  --tuning FILE              Read size=value assignments from the given file.\n  -p/--platform NAME         Use the first OpenCL platform whose name contains the given string.\n  --dump-opencl FILE         Dump the embedded OpenCL program to the indicated file.\n  --load-opencl FILE         Instead of using the embedded OpenCL program, load it from the indicated file.\n  --dump-opencl-binary FILE  Dump the compiled version of the embedded OpenCL program to the indicated file.\n  --load-opencl-binary FILE  Load an OpenCL binary from the indicated file.\n  --build-option OPT         Add an additional build option to the string passed to clBuildProgram().\n  -P/--profile               Gather profiling data while executing and print out a summary at the end.\n  --list-devices             List all OpenCL devices and platforms available on the system.\n";
    
    while ((ch = getopt_long(argc, argv, ":t:r:DLe:bhd:p:P", long_options,
                             NULL)) != -1) {
        if (ch == 1 || ch == 't') {
            runtime_file = fopen(optarg, "w");
            if (runtime_file == NULL)
                futhark_panic(1, "Cannot open %s: %s\n", optarg,
                              strerror(errno));
        }
        if (ch == 2 || ch == 'r') {
            num_runs = atoi(optarg);
            perform_warmup = 1;
            if (num_runs <= 0)
                futhark_panic(1, "Need a positive number of runs, not %s\n",
                              optarg);
        }
        if (ch == 3 || ch == 'D')
            futhark_context_config_set_debugging(cfg, 1);
        if (ch == 4 || ch == 'L')
            futhark_context_config_set_logging(cfg, 1);
        if (ch == 5 || ch == 'e') {
            if (entry_point != NULL)
                entry_point = optarg;
        }
        if (ch == 6 || ch == 'b')
            binary_output = 1;
        if (ch == 7 || ch == 'h') {
            printf("Usage: %s [OPTION]...\nOptions:\n\n%s\nFor more information, consult the Futhark User's Guide or the man pages.\n",
                   fut_progname, option_descriptions);
            exit(0);
        }
        if (ch == 8 || ch == 'd')
            futhark_context_config_set_device(cfg, optarg);
        if (ch == 9)
            futhark_context_config_set_default_group_size(cfg, atoi(optarg));
        if (ch == 10)
            futhark_context_config_set_default_num_groups(cfg, atoi(optarg));
        if (ch == 11)
            futhark_context_config_set_default_tile_size(cfg, atoi(optarg));
        if (ch == 12)
            futhark_context_config_set_default_threshold(cfg, atoi(optarg));
        if (ch == 13) {
            int n = futhark_get_num_sizes();
            
            for (int i = 0; i < n; i++)
                printf("%s (%s)\n", futhark_get_size_name(i),
                       futhark_get_size_class(i));
            exit(0);
        }
        if (ch == 14) {
            char *name = optarg;
            char *equals = strstr(optarg, "=");
            char *value_str = equals != NULL ? equals + 1 : optarg;
            int value = atoi(value_str);
            
            if (equals != NULL) {
                *equals = 0;
                if (futhark_context_config_set_size(cfg, name, value) != 0)
                    futhark_panic(1, "Unknown size: %s\n", name);
            } else
                futhark_panic(1, "Invalid argument for size option: %s\n",
                              optarg);
        }
        if (ch == 15) {
            char *ret = load_tuning_file(optarg, cfg, (int (*)(void *, const
                                                               char *,
                                                               size_t)) futhark_context_config_set_size);
            
            if (ret != NULL)
                futhark_panic(1, "When loading tuning from '%s': %s\n", optarg,
                              ret);
        }
        if (ch == 16 || ch == 'p')
            futhark_context_config_set_platform(cfg, optarg);
        if (ch == 17) {
            futhark_context_config_dump_program_to(cfg, optarg);
            entry_point = NULL;
        }
        if (ch == 18)
            futhark_context_config_load_program_from(cfg, optarg);
        if (ch == 19) {
            futhark_context_config_dump_binary_to(cfg, optarg);
            entry_point = NULL;
        }
        if (ch == 20)
            futhark_context_config_load_binary_from(cfg, optarg);
        if (ch == 21)
            futhark_context_config_add_build_option(cfg, optarg);
        if (ch == 22 || ch == 'P')
            futhark_context_config_set_profiling(cfg, 1);
        if (ch == 23) {
            futhark_context_config_list_devices(cfg);
            entry_point = NULL;
        }
        if (ch == ':')
            futhark_panic(-1, "Missing argument for option %s\n", argv[optind -
                                                                       1]);
        if (ch == '?') {
            fprintf(stderr, "Usage: %s: %s\n", fut_progname,
                    "  -t/--write-runtime-to FILE Print the time taken to execute the program to the indicated file, an integral number of microseconds.\n  -r/--runs INT              Perform NUM runs of the program.\n  -D/--debugging             Perform possibly expensive internal correctness checks and verbose logging.\n  -L/--log                   Print various low-overhead logging information to stderr while running.\n  -e/--entry-point NAME      The entry point to run. Defaults to main.\n  -b/--binary-output         Print the program result in the binary output format.\n  -h/--help                  Print help information and exit.\n  -d/--device NAME           Use the first OpenCL device whose name contains the given string.\n  --default-group-size INT   The default size of OpenCL workgroups that are launched.\n  --default-num-groups INT   The default number of OpenCL workgroups that are launched.\n  --default-tile-size INT    The default tile size used when performing two-dimensional tiling.\n  --default-threshold INT    The default parallelism threshold.\n  --print-sizes              Print all sizes that can be set with -size or --tuning.\n  --size ASSIGNMENT          Set a configurable run-time parameter to the given value.\n  --tuning FILE              Read size=value assignments from the given file.\n  -p/--platform NAME         Use the first OpenCL platform whose name contains the given string.\n  --dump-opencl FILE         Dump the embedded OpenCL program to the indicated file.\n  --load-opencl FILE         Instead of using the embedded OpenCL program, load it from the indicated file.\n  --dump-opencl-binary FILE  Dump the compiled version of the embedded OpenCL program to the indicated file.\n  --load-opencl-binary FILE  Load an OpenCL binary from the indicated file.\n  --build-option OPT         Add an additional build option to the string passed to clBuildProgram().\n  -P/--profile               Gather profiling data while executing and print out a summary at the end.\n  --list-devices             List all OpenCL devices and platforms available on the system.\n");
            futhark_panic(1, "Unknown option: %s\n", argv[optind - 1]);
        }
    }
    return optind;
}
static void futrts_cli_entry_main(struct futhark_context *ctx)
{
    int64_t t_start, t_end;
    int time_runs = 0, profile_run = 0;
    
    // We do not want to profile all the initialisation.
    futhark_context_pause_profiling(ctx);
    // Declare and read input.
    set_binary_mode(stdin);
    
    int64_t read_value_23978;
    
    if (read_scalar(&i64_info, &read_value_23978) != 0)
        futhark_panic(1,
                      "Error when reading input #%d of type %s (errno: %s).\n",
                      0, i64_info.type_name, strerror(errno));
    
    int64_t read_value_23979;
    
    if (read_scalar(&i64_info, &read_value_23979) != 0)
        futhark_panic(1,
                      "Error when reading input #%d of type %s (errno: %s).\n",
                      1, i64_info.type_name, strerror(errno));
    
    struct futhark_f32_1d *read_value_23980;
    int64_t read_shape_23981[1];
    float *read_arr_23982 = NULL;
    
    errno = 0;
    if (read_array(&f32_info, (void **) &read_arr_23982, read_shape_23981, 1) !=
        0)
        futhark_panic(1, "Cannot read input #%d of type %s%s (errno: %s).\n", 2,
                      "[]", f32_info.type_name, strerror(errno));
    
    struct futhark_i64_1d *read_value_23983;
    int64_t read_shape_23984[1];
    int64_t *read_arr_23985 = NULL;
    
    errno = 0;
    if (read_array(&i64_info, (void **) &read_arr_23985, read_shape_23984, 1) !=
        0)
        futhark_panic(1, "Cannot read input #%d of type %s%s (errno: %s).\n", 3,
                      "[]", i64_info.type_name, strerror(errno));
    
    struct futhark_f32_1d *read_value_23986;
    int64_t read_shape_23987[1];
    float *read_arr_23988 = NULL;
    
    errno = 0;
    if (read_array(&f32_info, (void **) &read_arr_23988, read_shape_23987, 1) !=
        0)
        futhark_panic(1, "Cannot read input #%d of type %s%s (errno: %s).\n", 4,
                      "[]", f32_info.type_name, strerror(errno));
    
    float read_value_23989;
    
    if (read_scalar(&f32_info, &read_value_23989) != 0)
        futhark_panic(1,
                      "Error when reading input #%d of type %s (errno: %s).\n",
                      5, f32_info.type_name, strerror(errno));
    
    float read_value_23990;
    
    if (read_scalar(&f32_info, &read_value_23990) != 0)
        futhark_panic(1,
                      "Error when reading input #%d of type %s (errno: %s).\n",
                      6, f32_info.type_name, strerror(errno));
    
    float read_value_23991;
    
    if (read_scalar(&f32_info, &read_value_23991) != 0)
        futhark_panic(1,
                      "Error when reading input #%d of type %s (errno: %s).\n",
                      7, f32_info.type_name, strerror(errno));
    
    float read_value_23992;
    
    if (read_scalar(&f32_info, &read_value_23992) != 0)
        futhark_panic(1,
                      "Error when reading input #%d of type %s (errno: %s).\n",
                      8, f32_info.type_name, strerror(errno));
    if (end_of_input() != 0)
        futhark_panic(1, "Expected EOF on stdin after reading input for %s.\n",
                      "\"main\"");
    
    float result_23993;
    struct futhark_f32_1d *result_23994;
    
    if (perform_warmup) {
        int r;
        
        ;
        ;
        assert((read_value_23980 = futhark_new_f32_1d(ctx, read_arr_23982,
                                                      read_shape_23981[0])) !=
            0);
        assert((read_value_23983 = futhark_new_i64_1d(ctx, read_arr_23985,
                                                      read_shape_23984[0])) !=
            0);
        assert((read_value_23986 = futhark_new_f32_1d(ctx, read_arr_23988,
                                                      read_shape_23987[0])) !=
            0);
        ;
        ;
        ;
        ;
        if (futhark_context_sync(ctx) != 0)
            futhark_panic(1, "%s", futhark_context_get_error(ctx));
        ;
        // Only profile last run.
        if (profile_run)
            futhark_context_unpause_profiling(ctx);
        t_start = get_wall_time();
        r = futhark_entry_main(ctx, &result_23993, &result_23994,
                               read_value_23978, read_value_23979,
                               read_value_23980, read_value_23983,
                               read_value_23986, read_value_23989,
                               read_value_23990, read_value_23991,
                               read_value_23992);
        if (r != 0)
            futhark_panic(1, "%s", futhark_context_get_error(ctx));
        if (futhark_context_sync(ctx) != 0)
            futhark_panic(1, "%s", futhark_context_get_error(ctx));
        ;
        if (profile_run)
            futhark_context_pause_profiling(ctx);
        t_end = get_wall_time();
        
        long elapsed_usec = t_end - t_start;
        
        if (time_runs && runtime_file != NULL) {
            fprintf(runtime_file, "%lld\n", (long long) elapsed_usec);
            fflush(runtime_file);
        }
        ;
        ;
        assert(futhark_free_f32_1d(ctx, read_value_23980) == 0);
        assert(futhark_free_i64_1d(ctx, read_value_23983) == 0);
        assert(futhark_free_f32_1d(ctx, read_value_23986) == 0);
        ;
        ;
        ;
        ;
        ;
        assert(futhark_free_f32_1d(ctx, result_23994) == 0);
    }
    time_runs = 1;
    // Proper run.
    for (int run = 0; run < num_runs; run++) {
        // Only profile last run.
        profile_run = run == num_runs - 1;
        
        int r;
        
        ;
        ;
        assert((read_value_23980 = futhark_new_f32_1d(ctx, read_arr_23982,
                                                      read_shape_23981[0])) !=
            0);
        assert((read_value_23983 = futhark_new_i64_1d(ctx, read_arr_23985,
                                                      read_shape_23984[0])) !=
            0);
        assert((read_value_23986 = futhark_new_f32_1d(ctx, read_arr_23988,
                                                      read_shape_23987[0])) !=
            0);
        ;
        ;
        ;
        ;
        if (futhark_context_sync(ctx) != 0)
            futhark_panic(1, "%s", futhark_context_get_error(ctx));
        ;
        // Only profile last run.
        if (profile_run)
            futhark_context_unpause_profiling(ctx);
        t_start = get_wall_time();
        r = futhark_entry_main(ctx, &result_23993, &result_23994,
                               read_value_23978, read_value_23979,
                               read_value_23980, read_value_23983,
                               read_value_23986, read_value_23989,
                               read_value_23990, read_value_23991,
                               read_value_23992);
        if (r != 0)
            futhark_panic(1, "%s", futhark_context_get_error(ctx));
        if (futhark_context_sync(ctx) != 0)
            futhark_panic(1, "%s", futhark_context_get_error(ctx));
        ;
        if (profile_run)
            futhark_context_pause_profiling(ctx);
        t_end = get_wall_time();
        
        long elapsed_usec = t_end - t_start;
        
        if (time_runs && runtime_file != NULL) {
            fprintf(runtime_file, "%lld\n", (long long) elapsed_usec);
            fflush(runtime_file);
        }
        ;
        ;
        assert(futhark_free_f32_1d(ctx, read_value_23980) == 0);
        assert(futhark_free_i64_1d(ctx, read_value_23983) == 0);
        assert(futhark_free_f32_1d(ctx, read_value_23986) == 0);
        ;
        ;
        ;
        ;
        if (run < num_runs - 1) {
            ;
            assert(futhark_free_f32_1d(ctx, result_23994) == 0);
        }
    }
    ;
    ;
    free(read_arr_23982);
    free(read_arr_23985);
    free(read_arr_23988);
    ;
    ;
    ;
    ;
    if (binary_output)
        set_binary_mode(stdout);
    write_scalar(stdout, binary_output, &f32_info, &result_23993);
    printf("\n");
    {
        float *arr = calloc(sizeof(float), futhark_shape_f32_1d(ctx,
                                                                result_23994)[0]);
        
        assert(arr != NULL);
        assert(futhark_values_f32_1d(ctx, result_23994, arr) == 0);
        write_array(stdout, binary_output, &f32_info, arr,
                    futhark_shape_f32_1d(ctx, result_23994), 1);
        free(arr);
    }
    printf("\n");
    ;
    assert(futhark_free_f32_1d(ctx, result_23994) == 0);
}
static void futrts_cli_entry_test(struct futhark_context *ctx)
{
    int64_t t_start, t_end;
    int time_runs = 0, profile_run = 0;
    
    // We do not want to profile all the initialisation.
    futhark_context_pause_profiling(ctx);
    // Declare and read input.
    set_binary_mode(stdin);
    
    int64_t read_value_23995;
    
    if (read_scalar(&i64_info, &read_value_23995) != 0)
        futhark_panic(1,
                      "Error when reading input #%d of type %s (errno: %s).\n",
                      0, i64_info.type_name, strerror(errno));
    
    int64_t read_value_23996;
    
    if (read_scalar(&i64_info, &read_value_23996) != 0)
        futhark_panic(1,
                      "Error when reading input #%d of type %s (errno: %s).\n",
                      1, i64_info.type_name, strerror(errno));
    if (end_of_input() != 0)
        futhark_panic(1, "Expected EOF on stdin after reading input for %s.\n",
                      "\"test\"");
    
    float result_23997;
    
    if (perform_warmup) {
        int r;
        
        ;
        ;
        if (futhark_context_sync(ctx) != 0)
            futhark_panic(1, "%s", futhark_context_get_error(ctx));
        ;
        // Only profile last run.
        if (profile_run)
            futhark_context_unpause_profiling(ctx);
        t_start = get_wall_time();
        r = futhark_entry_test(ctx, &result_23997, read_value_23995,
                               read_value_23996);
        if (r != 0)
            futhark_panic(1, "%s", futhark_context_get_error(ctx));
        if (futhark_context_sync(ctx) != 0)
            futhark_panic(1, "%s", futhark_context_get_error(ctx));
        ;
        if (profile_run)
            futhark_context_pause_profiling(ctx);
        t_end = get_wall_time();
        
        long elapsed_usec = t_end - t_start;
        
        if (time_runs && runtime_file != NULL) {
            fprintf(runtime_file, "%lld\n", (long long) elapsed_usec);
            fflush(runtime_file);
        }
        ;
        ;
        ;
    }
    time_runs = 1;
    // Proper run.
    for (int run = 0; run < num_runs; run++) {
        // Only profile last run.
        profile_run = run == num_runs - 1;
        
        int r;
        
        ;
        ;
        if (futhark_context_sync(ctx) != 0)
            futhark_panic(1, "%s", futhark_context_get_error(ctx));
        ;
        // Only profile last run.
        if (profile_run)
            futhark_context_unpause_profiling(ctx);
        t_start = get_wall_time();
        r = futhark_entry_test(ctx, &result_23997, read_value_23995,
                               read_value_23996);
        if (r != 0)
            futhark_panic(1, "%s", futhark_context_get_error(ctx));
        if (futhark_context_sync(ctx) != 0)
            futhark_panic(1, "%s", futhark_context_get_error(ctx));
        ;
        if (profile_run)
            futhark_context_pause_profiling(ctx);
        t_end = get_wall_time();
        
        long elapsed_usec = t_end - t_start;
        
        if (time_runs && runtime_file != NULL) {
            fprintf(runtime_file, "%lld\n", (long long) elapsed_usec);
            fflush(runtime_file);
        }
        ;
        ;
        if (run < num_runs - 1) {
            ;
        }
    }
    ;
    ;
    if (binary_output)
        set_binary_mode(stdout);
    write_scalar(stdout, binary_output, &f32_info, &result_23997);
    printf("\n");
    ;
}
typedef void entry_point_fun(struct futhark_context *);
struct entry_point_entry {
    const char *name;
    entry_point_fun *fun;
} ;
int main(int argc, char **argv)
{
    fut_progname = argv[0];
    
    struct entry_point_entry entry_points[] = {{.name ="main", .fun =
                                                futrts_cli_entry_main}, {.name =
                                                                         "test",
                                                                         .fun =
                                                                         futrts_cli_entry_test}};
    struct futhark_context_config *cfg = futhark_context_config_new();
    
    assert(cfg != NULL);
    
    int parsed_options = parse_options(cfg, argc, argv);
    
    argc -= parsed_options;
    argv += parsed_options;
    if (argc != 0)
        futhark_panic(1, "Excess non-option: %s\n", argv[0]);
    
    struct futhark_context *ctx = futhark_context_new(cfg);
    
    assert(ctx != NULL);
    
    char *error = futhark_context_get_error(ctx);
    
    if (error != NULL)
        futhark_panic(1, "%s", error);
    if (entry_point != NULL) {
        int num_entry_points = sizeof(entry_points) / sizeof(entry_points[0]);
        entry_point_fun *entry_point_fun = NULL;
        
        for (int i = 0; i < num_entry_points; i++) {
            if (strcmp(entry_points[i].name, entry_point) == 0) {
                entry_point_fun = entry_points[i].fun;
                break;
            }
        }
        if (entry_point_fun == NULL) {
            fprintf(stderr,
                    "No entry point '%s'.  Select another with --entry-point.  Options are:\n",
                    entry_point);
            for (int i = 0; i < num_entry_points; i++)
                fprintf(stderr, "%s\n", entry_points[i].name);
            return 1;
        }
        entry_point_fun(ctx);
        if (runtime_file != NULL)
            fclose(runtime_file);
        
        char *report = futhark_context_report(ctx);
        
        fputs(report, stderr);
        free(report);
    }
    futhark_context_free(ctx);
    futhark_context_config_free(cfg);
    return 0;
}
#ifdef _MSC_VER
#define inline __inline
#endif
#include <string.h>
#include <inttypes.h>
#include <ctype.h>
#include <errno.h>
#include <assert.h>
#define CL_TARGET_OPENCL_VERSION 120
#define CL_USE_DEPRECATED_OPENCL_1_2_APIS
#ifdef __APPLE__
#define CL_SILENCE_DEPRECATION
#include <OpenCL/cl.h>
#else
#include <CL/cl.h>
#endif

// Start of lock.h.

// A very simple cross-platform implementation of locks.  Uses
// pthreads on Unix and some Windows thing there.  Futhark's
// host-level code is not multithreaded, but user code may be, so we
// need some mechanism for ensuring atomic access to API functions.
// This is that mechanism.  It is not exposed to user code at all, so
// we do not have to worry about name collisions.

#ifdef _WIN32

typedef HANDLE lock_t;

static void create_lock(lock_t *lock) {
  *lock = CreateMutex(NULL,  // Default security attributes.
                      FALSE, // Initially unlocked.
                      NULL); // Unnamed.
}

static void lock_lock(lock_t *lock) {
  assert(WaitForSingleObject(*lock, INFINITE) == WAIT_OBJECT_0);
}

static void lock_unlock(lock_t *lock) {
  assert(ReleaseMutex(*lock));
}

static void free_lock(lock_t *lock) {
  CloseHandle(*lock);
}

#else
// Assuming POSIX

#include <pthread.h>

typedef pthread_mutex_t lock_t;

static void create_lock(lock_t *lock) {
  int r = pthread_mutex_init(lock, NULL);
  assert(r == 0);
}

static void lock_lock(lock_t *lock) {
  int r = pthread_mutex_lock(lock);
  assert(r == 0);
}

static void lock_unlock(lock_t *lock) {
  int r = pthread_mutex_unlock(lock);
  assert(r == 0);
}

static void free_lock(lock_t *lock) {
  // Nothing to do for pthreads.
  (void)lock;
}

#endif

// End of lock.h.

static inline uint8_t add8(uint8_t x, uint8_t y)
{
    return x + y;
}
static inline uint16_t add16(uint16_t x, uint16_t y)
{
    return x + y;
}
static inline uint32_t add32(uint32_t x, uint32_t y)
{
    return x + y;
}
static inline uint64_t add64(uint64_t x, uint64_t y)
{
    return x + y;
}
static inline uint8_t sub8(uint8_t x, uint8_t y)
{
    return x - y;
}
static inline uint16_t sub16(uint16_t x, uint16_t y)
{
    return x - y;
}
static inline uint32_t sub32(uint32_t x, uint32_t y)
{
    return x - y;
}
static inline uint64_t sub64(uint64_t x, uint64_t y)
{
    return x - y;
}
static inline uint8_t mul8(uint8_t x, uint8_t y)
{
    return x * y;
}
static inline uint16_t mul16(uint16_t x, uint16_t y)
{
    return x * y;
}
static inline uint32_t mul32(uint32_t x, uint32_t y)
{
    return x * y;
}
static inline uint64_t mul64(uint64_t x, uint64_t y)
{
    return x * y;
}
static inline uint8_t udiv8(uint8_t x, uint8_t y)
{
    return x / y;
}
static inline uint16_t udiv16(uint16_t x, uint16_t y)
{
    return x / y;
}
static inline uint32_t udiv32(uint32_t x, uint32_t y)
{
    return x / y;
}
static inline uint64_t udiv64(uint64_t x, uint64_t y)
{
    return x / y;
}
static inline uint8_t udiv_up8(uint8_t x, uint8_t y)
{
    return (x + y - 1) / y;
}
static inline uint16_t udiv_up16(uint16_t x, uint16_t y)
{
    return (x + y - 1) / y;
}
static inline uint32_t udiv_up32(uint32_t x, uint32_t y)
{
    return (x + y - 1) / y;
}
static inline uint64_t udiv_up64(uint64_t x, uint64_t y)
{
    return (x + y - 1) / y;
}
static inline uint8_t umod8(uint8_t x, uint8_t y)
{
    return x % y;
}
static inline uint16_t umod16(uint16_t x, uint16_t y)
{
    return x % y;
}
static inline uint32_t umod32(uint32_t x, uint32_t y)
{
    return x % y;
}
static inline uint64_t umod64(uint64_t x, uint64_t y)
{
    return x % y;
}
static inline uint8_t udiv_safe8(uint8_t x, uint8_t y)
{
    return y == 0 ? 0 : x / y;
}
static inline uint16_t udiv_safe16(uint16_t x, uint16_t y)
{
    return y == 0 ? 0 : x / y;
}
static inline uint32_t udiv_safe32(uint32_t x, uint32_t y)
{
    return y == 0 ? 0 : x / y;
}
static inline uint64_t udiv_safe64(uint64_t x, uint64_t y)
{
    return y == 0 ? 0 : x / y;
}
static inline uint8_t udiv_up_safe8(uint8_t x, uint8_t y)
{
    return y == 0 ? 0 : (x + y - 1) / y;
}
static inline uint16_t udiv_up_safe16(uint16_t x, uint16_t y)
{
    return y == 0 ? 0 : (x + y - 1) / y;
}
static inline uint32_t udiv_up_safe32(uint32_t x, uint32_t y)
{
    return y == 0 ? 0 : (x + y - 1) / y;
}
static inline uint64_t udiv_up_safe64(uint64_t x, uint64_t y)
{
    return y == 0 ? 0 : (x + y - 1) / y;
}
static inline uint8_t umod_safe8(uint8_t x, uint8_t y)
{
    return y == 0 ? 0 : x % y;
}
static inline uint16_t umod_safe16(uint16_t x, uint16_t y)
{
    return y == 0 ? 0 : x % y;
}
static inline uint32_t umod_safe32(uint32_t x, uint32_t y)
{
    return y == 0 ? 0 : x % y;
}
static inline uint64_t umod_safe64(uint64_t x, uint64_t y)
{
    return y == 0 ? 0 : x % y;
}
static inline int8_t sdiv8(int8_t x, int8_t y)
{
    int8_t q = x / y;
    int8_t r = x % y;
    
    return q - ((r != 0 && r < 0 != y < 0) ? 1 : 0);
}
static inline int16_t sdiv16(int16_t x, int16_t y)
{
    int16_t q = x / y;
    int16_t r = x % y;
    
    return q - ((r != 0 && r < 0 != y < 0) ? 1 : 0);
}
static inline int32_t sdiv32(int32_t x, int32_t y)
{
    int32_t q = x / y;
    int32_t r = x % y;
    
    return q - ((r != 0 && r < 0 != y < 0) ? 1 : 0);
}
static inline int64_t sdiv64(int64_t x, int64_t y)
{
    int64_t q = x / y;
    int64_t r = x % y;
    
    return q - ((r != 0 && r < 0 != y < 0) ? 1 : 0);
}
static inline int8_t sdiv_up8(int8_t x, int8_t y)
{
    return sdiv8(x + y - 1, y);
}
static inline int16_t sdiv_up16(int16_t x, int16_t y)
{
    return sdiv16(x + y - 1, y);
}
static inline int32_t sdiv_up32(int32_t x, int32_t y)
{
    return sdiv32(x + y - 1, y);
}
static inline int64_t sdiv_up64(int64_t x, int64_t y)
{
    return sdiv64(x + y - 1, y);
}
static inline int8_t smod8(int8_t x, int8_t y)
{
    int8_t r = x % y;
    
    return r + (r == 0 || (x > 0 && y > 0) || (x < 0 && y < 0) ? 0 : y);
}
static inline int16_t smod16(int16_t x, int16_t y)
{
    int16_t r = x % y;
    
    return r + (r == 0 || (x > 0 && y > 0) || (x < 0 && y < 0) ? 0 : y);
}
static inline int32_t smod32(int32_t x, int32_t y)
{
    int32_t r = x % y;
    
    return r + (r == 0 || (x > 0 && y > 0) || (x < 0 && y < 0) ? 0 : y);
}
static inline int64_t smod64(int64_t x, int64_t y)
{
    int64_t r = x % y;
    
    return r + (r == 0 || (x > 0 && y > 0) || (x < 0 && y < 0) ? 0 : y);
}
static inline int8_t sdiv_safe8(int8_t x, int8_t y)
{
    return y == 0 ? 0 : sdiv8(x, y);
}
static inline int16_t sdiv_safe16(int16_t x, int16_t y)
{
    return y == 0 ? 0 : sdiv16(x, y);
}
static inline int32_t sdiv_safe32(int32_t x, int32_t y)
{
    return y == 0 ? 0 : sdiv32(x, y);
}
static inline int64_t sdiv_safe64(int64_t x, int64_t y)
{
    return y == 0 ? 0 : sdiv64(x, y);
}
static inline int8_t sdiv_up_safe8(int8_t x, int8_t y)
{
    return sdiv_safe8(x + y - 1, y);
}
static inline int16_t sdiv_up_safe16(int16_t x, int16_t y)
{
    return sdiv_safe16(x + y - 1, y);
}
static inline int32_t sdiv_up_safe32(int32_t x, int32_t y)
{
    return sdiv_safe32(x + y - 1, y);
}
static inline int64_t sdiv_up_safe64(int64_t x, int64_t y)
{
    return sdiv_safe64(x + y - 1, y);
}
static inline int8_t smod_safe8(int8_t x, int8_t y)
{
    return y == 0 ? 0 : smod8(x, y);
}
static inline int16_t smod_safe16(int16_t x, int16_t y)
{
    return y == 0 ? 0 : smod16(x, y);
}
static inline int32_t smod_safe32(int32_t x, int32_t y)
{
    return y == 0 ? 0 : smod32(x, y);
}
static inline int64_t smod_safe64(int64_t x, int64_t y)
{
    return y == 0 ? 0 : smod64(x, y);
}
static inline int8_t squot8(int8_t x, int8_t y)
{
    return x / y;
}
static inline int16_t squot16(int16_t x, int16_t y)
{
    return x / y;
}
static inline int32_t squot32(int32_t x, int32_t y)
{
    return x / y;
}
static inline int64_t squot64(int64_t x, int64_t y)
{
    return x / y;
}
static inline int8_t srem8(int8_t x, int8_t y)
{
    return x % y;
}
static inline int16_t srem16(int16_t x, int16_t y)
{
    return x % y;
}
static inline int32_t srem32(int32_t x, int32_t y)
{
    return x % y;
}
static inline int64_t srem64(int64_t x, int64_t y)
{
    return x % y;
}
static inline int8_t squot_safe8(int8_t x, int8_t y)
{
    return y == 0 ? 0 : x / y;
}
static inline int16_t squot_safe16(int16_t x, int16_t y)
{
    return y == 0 ? 0 : x / y;
}
static inline int32_t squot_safe32(int32_t x, int32_t y)
{
    return y == 0 ? 0 : x / y;
}
static inline int64_t squot_safe64(int64_t x, int64_t y)
{
    return y == 0 ? 0 : x / y;
}
static inline int8_t srem_safe8(int8_t x, int8_t y)
{
    return y == 0 ? 0 : x % y;
}
static inline int16_t srem_safe16(int16_t x, int16_t y)
{
    return y == 0 ? 0 : x % y;
}
static inline int32_t srem_safe32(int32_t x, int32_t y)
{
    return y == 0 ? 0 : x % y;
}
static inline int64_t srem_safe64(int64_t x, int64_t y)
{
    return y == 0 ? 0 : x % y;
}
static inline int8_t smin8(int8_t x, int8_t y)
{
    return x < y ? x : y;
}
static inline int16_t smin16(int16_t x, int16_t y)
{
    return x < y ? x : y;
}
static inline int32_t smin32(int32_t x, int32_t y)
{
    return x < y ? x : y;
}
static inline int64_t smin64(int64_t x, int64_t y)
{
    return x < y ? x : y;
}
static inline uint8_t umin8(uint8_t x, uint8_t y)
{
    return x < y ? x : y;
}
static inline uint16_t umin16(uint16_t x, uint16_t y)
{
    return x < y ? x : y;
}
static inline uint32_t umin32(uint32_t x, uint32_t y)
{
    return x < y ? x : y;
}
static inline uint64_t umin64(uint64_t x, uint64_t y)
{
    return x < y ? x : y;
}
static inline int8_t smax8(int8_t x, int8_t y)
{
    return x < y ? y : x;
}
static inline int16_t smax16(int16_t x, int16_t y)
{
    return x < y ? y : x;
}
static inline int32_t smax32(int32_t x, int32_t y)
{
    return x < y ? y : x;
}
static inline int64_t smax64(int64_t x, int64_t y)
{
    return x < y ? y : x;
}
static inline uint8_t umax8(uint8_t x, uint8_t y)
{
    return x < y ? y : x;
}
static inline uint16_t umax16(uint16_t x, uint16_t y)
{
    return x < y ? y : x;
}
static inline uint32_t umax32(uint32_t x, uint32_t y)
{
    return x < y ? y : x;
}
static inline uint64_t umax64(uint64_t x, uint64_t y)
{
    return x < y ? y : x;
}
static inline uint8_t shl8(uint8_t x, uint8_t y)
{
    return x << y;
}
static inline uint16_t shl16(uint16_t x, uint16_t y)
{
    return x << y;
}
static inline uint32_t shl32(uint32_t x, uint32_t y)
{
    return x << y;
}
static inline uint64_t shl64(uint64_t x, uint64_t y)
{
    return x << y;
}
static inline uint8_t lshr8(uint8_t x, uint8_t y)
{
    return x >> y;
}
static inline uint16_t lshr16(uint16_t x, uint16_t y)
{
    return x >> y;
}
static inline uint32_t lshr32(uint32_t x, uint32_t y)
{
    return x >> y;
}
static inline uint64_t lshr64(uint64_t x, uint64_t y)
{
    return x >> y;
}
static inline int8_t ashr8(int8_t x, int8_t y)
{
    return x >> y;
}
static inline int16_t ashr16(int16_t x, int16_t y)
{
    return x >> y;
}
static inline int32_t ashr32(int32_t x, int32_t y)
{
    return x >> y;
}
static inline int64_t ashr64(int64_t x, int64_t y)
{
    return x >> y;
}
static inline uint8_t and8(uint8_t x, uint8_t y)
{
    return x & y;
}
static inline uint16_t and16(uint16_t x, uint16_t y)
{
    return x & y;
}
static inline uint32_t and32(uint32_t x, uint32_t y)
{
    return x & y;
}
static inline uint64_t and64(uint64_t x, uint64_t y)
{
    return x & y;
}
static inline uint8_t or8(uint8_t x, uint8_t y)
{
    return x | y;
}
static inline uint16_t or16(uint16_t x, uint16_t y)
{
    return x | y;
}
static inline uint32_t or32(uint32_t x, uint32_t y)
{
    return x | y;
}
static inline uint64_t or64(uint64_t x, uint64_t y)
{
    return x | y;
}
static inline uint8_t xor8(uint8_t x, uint8_t y)
{
    return x ^ y;
}
static inline uint16_t xor16(uint16_t x, uint16_t y)
{
    return x ^ y;
}
static inline uint32_t xor32(uint32_t x, uint32_t y)
{
    return x ^ y;
}
static inline uint64_t xor64(uint64_t x, uint64_t y)
{
    return x ^ y;
}
static inline bool ult8(uint8_t x, uint8_t y)
{
    return x < y;
}
static inline bool ult16(uint16_t x, uint16_t y)
{
    return x < y;
}
static inline bool ult32(uint32_t x, uint32_t y)
{
    return x < y;
}
static inline bool ult64(uint64_t x, uint64_t y)
{
    return x < y;
}
static inline bool ule8(uint8_t x, uint8_t y)
{
    return x <= y;
}
static inline bool ule16(uint16_t x, uint16_t y)
{
    return x <= y;
}
static inline bool ule32(uint32_t x, uint32_t y)
{
    return x <= y;
}
static inline bool ule64(uint64_t x, uint64_t y)
{
    return x <= y;
}
static inline bool slt8(int8_t x, int8_t y)
{
    return x < y;
}
static inline bool slt16(int16_t x, int16_t y)
{
    return x < y;
}
static inline bool slt32(int32_t x, int32_t y)
{
    return x < y;
}
static inline bool slt64(int64_t x, int64_t y)
{
    return x < y;
}
static inline bool sle8(int8_t x, int8_t y)
{
    return x <= y;
}
static inline bool sle16(int16_t x, int16_t y)
{
    return x <= y;
}
static inline bool sle32(int32_t x, int32_t y)
{
    return x <= y;
}
static inline bool sle64(int64_t x, int64_t y)
{
    return x <= y;
}
static inline int8_t pow8(int8_t x, int8_t y)
{
    int8_t res = 1, rem = y;
    
    while (rem != 0) {
        if (rem & 1)
            res *= x;
        rem >>= 1;
        x *= x;
    }
    return res;
}
static inline int16_t pow16(int16_t x, int16_t y)
{
    int16_t res = 1, rem = y;
    
    while (rem != 0) {
        if (rem & 1)
            res *= x;
        rem >>= 1;
        x *= x;
    }
    return res;
}
static inline int32_t pow32(int32_t x, int32_t y)
{
    int32_t res = 1, rem = y;
    
    while (rem != 0) {
        if (rem & 1)
            res *= x;
        rem >>= 1;
        x *= x;
    }
    return res;
}
static inline int64_t pow64(int64_t x, int64_t y)
{
    int64_t res = 1, rem = y;
    
    while (rem != 0) {
        if (rem & 1)
            res *= x;
        rem >>= 1;
        x *= x;
    }
    return res;
}
static inline bool itob_i8_bool(int8_t x)
{
    return x;
}
static inline bool itob_i16_bool(int16_t x)
{
    return x;
}
static inline bool itob_i32_bool(int32_t x)
{
    return x;
}
static inline bool itob_i64_bool(int64_t x)
{
    return x;
}
static inline int8_t btoi_bool_i8(bool x)
{
    return x;
}
static inline int16_t btoi_bool_i16(bool x)
{
    return x;
}
static inline int32_t btoi_bool_i32(bool x)
{
    return x;
}
static inline int64_t btoi_bool_i64(bool x)
{
    return x;
}
#define sext_i8_i8(x) ((int8_t) (int8_t) x)
#define sext_i8_i16(x) ((int16_t) (int8_t) x)
#define sext_i8_i32(x) ((int32_t) (int8_t) x)
#define sext_i8_i64(x) ((int64_t) (int8_t) x)
#define sext_i16_i8(x) ((int8_t) (int16_t) x)
#define sext_i16_i16(x) ((int16_t) (int16_t) x)
#define sext_i16_i32(x) ((int32_t) (int16_t) x)
#define sext_i16_i64(x) ((int64_t) (int16_t) x)
#define sext_i32_i8(x) ((int8_t) (int32_t) x)
#define sext_i32_i16(x) ((int16_t) (int32_t) x)
#define sext_i32_i32(x) ((int32_t) (int32_t) x)
#define sext_i32_i64(x) ((int64_t) (int32_t) x)
#define sext_i64_i8(x) ((int8_t) (int64_t) x)
#define sext_i64_i16(x) ((int16_t) (int64_t) x)
#define sext_i64_i32(x) ((int32_t) (int64_t) x)
#define sext_i64_i64(x) ((int64_t) (int64_t) x)
#define zext_i8_i8(x) ((int8_t) (uint8_t) x)
#define zext_i8_i16(x) ((int16_t) (uint8_t) x)
#define zext_i8_i32(x) ((int32_t) (uint8_t) x)
#define zext_i8_i64(x) ((int64_t) (uint8_t) x)
#define zext_i16_i8(x) ((int8_t) (uint16_t) x)
#define zext_i16_i16(x) ((int16_t) (uint16_t) x)
#define zext_i16_i32(x) ((int32_t) (uint16_t) x)
#define zext_i16_i64(x) ((int64_t) (uint16_t) x)
#define zext_i32_i8(x) ((int8_t) (uint32_t) x)
#define zext_i32_i16(x) ((int16_t) (uint32_t) x)
#define zext_i32_i32(x) ((int32_t) (uint32_t) x)
#define zext_i32_i64(x) ((int64_t) (uint32_t) x)
#define zext_i64_i8(x) ((int8_t) (uint64_t) x)
#define zext_i64_i16(x) ((int16_t) (uint64_t) x)
#define zext_i64_i32(x) ((int32_t) (uint64_t) x)
#define zext_i64_i64(x) ((int64_t) (uint64_t) x)
#if defined(__OPENCL_VERSION__)
static int32_t futrts_popc8(int8_t x)
{
    return popcount(x);
}
static int32_t futrts_popc16(int16_t x)
{
    return popcount(x);
}
static int32_t futrts_popc32(int32_t x)
{
    return popcount(x);
}
static int32_t futrts_popc64(int64_t x)
{
    return popcount(x);
}
#elif defined(__CUDA_ARCH__)
static int32_t futrts_popc8(int8_t x)
{
    return __popc(zext_i8_i32(x));
}
static int32_t futrts_popc16(int16_t x)
{
    return __popc(zext_i16_i32(x));
}
static int32_t futrts_popc32(int32_t x)
{
    return __popc(x);
}
static int32_t futrts_popc64(int64_t x)
{
    return __popcll(x);
}
#else
static int32_t futrts_popc8(int8_t x)
{
    int c = 0;
    
    for (; x; ++c)
        x &= x - 1;
    return c;
}
static int32_t futrts_popc16(int16_t x)
{
    int c = 0;
    
    for (; x; ++c)
        x &= x - 1;
    return c;
}
static int32_t futrts_popc32(int32_t x)
{
    int c = 0;
    
    for (; x; ++c)
        x &= x - 1;
    return c;
}
static int32_t futrts_popc64(int64_t x)
{
    int c = 0;
    
    for (; x; ++c)
        x &= x - 1;
    return c;
}
#endif
#if defined(__OPENCL_VERSION__)
static uint8_t futrts_mul_hi8(uint8_t a, uint8_t b)
{
    return mul_hi(a, b);
}
static uint16_t futrts_mul_hi16(uint16_t a, uint16_t b)
{
    return mul_hi(a, b);
}
static uint32_t futrts_mul_hi32(uint32_t a, uint32_t b)
{
    return mul_hi(a, b);
}
static uint64_t futrts_mul_hi64(uint64_t a, uint64_t b)
{
    return mul_hi(a, b);
}
#elif defined(__CUDA_ARCH__)
static uint8_t futrts_mul_hi8(uint8_t a, uint8_t b)
{
    uint16_t aa = a;
    uint16_t bb = b;
    
    return aa * bb >> 8;
}
static uint16_t futrts_mul_hi16(uint16_t a, uint16_t b)
{
    uint32_t aa = a;
    uint32_t bb = b;
    
    return aa * bb >> 16;
}
static uint32_t futrts_mul_hi32(uint32_t a, uint32_t b)
{
    return mulhi(a, b);
}
static uint64_t futrts_mul_hi64(uint64_t a, uint64_t b)
{
    return mul64hi(a, b);
}
#else
static uint8_t futrts_mul_hi8(uint8_t a, uint8_t b)
{
    uint16_t aa = a;
    uint16_t bb = b;
    
    return aa * bb >> 8;
}
static uint16_t futrts_mul_hi16(uint16_t a, uint16_t b)
{
    uint32_t aa = a;
    uint32_t bb = b;
    
    return aa * bb >> 16;
}
static uint32_t futrts_mul_hi32(uint32_t a, uint32_t b)
{
    uint64_t aa = a;
    uint64_t bb = b;
    
    return aa * bb >> 32;
}
static uint64_t futrts_mul_hi64(uint64_t a, uint64_t b)
{
    __uint128_t aa = a;
    __uint128_t bb = b;
    
    return aa * bb >> 64;
}
#endif
#if defined(__OPENCL_VERSION__)
static uint8_t futrts_mad_hi8(uint8_t a, uint8_t b, uint8_t c)
{
    return mad_hi(a, b, c);
}
static uint16_t futrts_mad_hi16(uint16_t a, uint16_t b, uint16_t c)
{
    return mad_hi(a, b, c);
}
static uint32_t futrts_mad_hi32(uint32_t a, uint32_t b, uint32_t c)
{
    return mad_hi(a, b, c);
}
static uint64_t futrts_mad_hi64(uint64_t a, uint64_t b, uint64_t c)
{
    return mad_hi(a, b, c);
}
#else
static uint8_t futrts_mad_hi8(uint8_t a, uint8_t b, uint8_t c)
{
    return futrts_mul_hi8(a, b) + c;
}
static uint16_t futrts_mad_hi16(uint16_t a, uint16_t b, uint16_t c)
{
    return futrts_mul_hi16(a, b) + c;
}
static uint32_t futrts_mad_hi32(uint32_t a, uint32_t b, uint32_t c)
{
    return futrts_mul_hi32(a, b) + c;
}
static uint64_t futrts_mad_hi64(uint64_t a, uint64_t b, uint64_t c)
{
    return futrts_mul_hi64(a, b) + c;
}
#endif
#if defined(__OPENCL_VERSION__)
static int32_t futrts_clzz8(int8_t x)
{
    return clz(x);
}
static int32_t futrts_clzz16(int16_t x)
{
    return clz(x);
}
static int32_t futrts_clzz32(int32_t x)
{
    return clz(x);
}
static int32_t futrts_clzz64(int64_t x)
{
    return clz(x);
}
#elif defined(__CUDA_ARCH__)
static int32_t futrts_clzz8(int8_t x)
{
    return __clz(zext_i8_i32(x)) - 24;
}
static int32_t futrts_clzz16(int16_t x)
{
    return __clz(zext_i16_i32(x)) - 16;
}
static int32_t futrts_clzz32(int32_t x)
{
    return __clz(x);
}
static int32_t futrts_clzz64(int64_t x)
{
    return __clzll(x);
}
#else
static int32_t futrts_clzz8(int8_t x)
{
    int n = 0;
    int bits = sizeof(x) * 8;
    
    for (int i = 0; i < bits; i++) {
        if (x < 0)
            break;
        n++;
        x <<= 1;
    }
    return n;
}
static int32_t futrts_clzz16(int16_t x)
{
    int n = 0;
    int bits = sizeof(x) * 8;
    
    for (int i = 0; i < bits; i++) {
        if (x < 0)
            break;
        n++;
        x <<= 1;
    }
    return n;
}
static int32_t futrts_clzz32(int32_t x)
{
    int n = 0;
    int bits = sizeof(x) * 8;
    
    for (int i = 0; i < bits; i++) {
        if (x < 0)
            break;
        n++;
        x <<= 1;
    }
    return n;
}
static int32_t futrts_clzz64(int64_t x)
{
    int n = 0;
    int bits = sizeof(x) * 8;
    
    for (int i = 0; i < bits; i++) {
        if (x < 0)
            break;
        n++;
        x <<= 1;
    }
    return n;
}
#endif
#if defined(__OPENCL_VERSION__)
static int32_t futrts_ctzz8(int8_t x)
{
    int i = 0;
    
    for (; i < 8 && (x & 1) == 0; i++, x >>= 1)
        ;
    return i;
}
static int32_t futrts_ctzz16(int16_t x)
{
    int i = 0;
    
    for (; i < 16 && (x & 1) == 0; i++, x >>= 1)
        ;
    return i;
}
static int32_t futrts_ctzz32(int32_t x)
{
    int i = 0;
    
    for (; i < 32 && (x & 1) == 0; i++, x >>= 1)
        ;
    return i;
}
static int32_t futrts_ctzz64(int64_t x)
{
    int i = 0;
    
    for (; i < 64 && (x & 1) == 0; i++, x >>= 1)
        ;
    return i;
}
#elif defined(__CUDA_ARCH__)
static int32_t futrts_ctzz8(int8_t x)
{
    int y = __ffs(x);
    
    return y == 0 ? 8 : y - 1;
}
static int32_t futrts_ctzz16(int16_t x)
{
    int y = __ffs(x);
    
    return y == 0 ? 16 : y - 1;
}
static int32_t futrts_ctzz32(int32_t x)
{
    int y = __ffs(x);
    
    return y == 0 ? 32 : y - 1;
}
static int32_t futrts_ctzz64(int64_t x)
{
    int y = __ffsll(x);
    
    return y == 0 ? 64 : y - 1;
}
#else
static int32_t futrts_ctzz8(int8_t x)
{
    return x == 0 ? 8 : __builtin_ctz((uint32_t) x);
}
static int32_t futrts_ctzz16(int16_t x)
{
    return x == 0 ? 16 : __builtin_ctz((uint32_t) x);
}
static int32_t futrts_ctzz32(int32_t x)
{
    return x == 0 ? 32 : __builtin_ctz(x);
}
static int32_t futrts_ctzz64(int64_t x)
{
    return x == 0 ? 64 : __builtin_ctzl(x);
}
#endif
static inline float fdiv32(float x, float y)
{
    return x / y;
}
static inline float fadd32(float x, float y)
{
    return x + y;
}
static inline float fsub32(float x, float y)
{
    return x - y;
}
static inline float fmul32(float x, float y)
{
    return x * y;
}
static inline float fmin32(float x, float y)
{
    return fmin(x, y);
}
static inline float fmax32(float x, float y)
{
    return fmax(x, y);
}
static inline float fpow32(float x, float y)
{
    return pow(x, y);
}
static inline bool cmplt32(float x, float y)
{
    return x < y;
}
static inline bool cmple32(float x, float y)
{
    return x <= y;
}
static inline float sitofp_i8_f32(int8_t x)
{
    return (float) x;
}
static inline float sitofp_i16_f32(int16_t x)
{
    return (float) x;
}
static inline float sitofp_i32_f32(int32_t x)
{
    return (float) x;
}
static inline float sitofp_i64_f32(int64_t x)
{
    return (float) x;
}
static inline float uitofp_i8_f32(uint8_t x)
{
    return (float) x;
}
static inline float uitofp_i16_f32(uint16_t x)
{
    return (float) x;
}
static inline float uitofp_i32_f32(uint32_t x)
{
    return (float) x;
}
static inline float uitofp_i64_f32(uint64_t x)
{
    return (float) x;
}
static inline int8_t fptosi_f32_i8(float x)
{
    return (int8_t) x;
}
static inline int16_t fptosi_f32_i16(float x)
{
    return (int16_t) x;
}
static inline int32_t fptosi_f32_i32(float x)
{
    return (int32_t) x;
}
static inline int64_t fptosi_f32_i64(float x)
{
    return (int64_t) x;
}
static inline uint8_t fptoui_f32_i8(float x)
{
    return (uint8_t) x;
}
static inline uint16_t fptoui_f32_i16(float x)
{
    return (uint16_t) x;
}
static inline uint32_t fptoui_f32_i32(float x)
{
    return (uint32_t) x;
}
static inline uint64_t fptoui_f32_i64(float x)
{
    return (uint64_t) x;
}
static inline double fdiv64(double x, double y)
{
    return x / y;
}
static inline double fadd64(double x, double y)
{
    return x + y;
}
static inline double fsub64(double x, double y)
{
    return x - y;
}
static inline double fmul64(double x, double y)
{
    return x * y;
}
static inline double fmin64(double x, double y)
{
    return fmin(x, y);
}
static inline double fmax64(double x, double y)
{
    return fmax(x, y);
}
static inline double fpow64(double x, double y)
{
    return pow(x, y);
}
static inline bool cmplt64(double x, double y)
{
    return x < y;
}
static inline bool cmple64(double x, double y)
{
    return x <= y;
}
static inline double sitofp_i8_f64(int8_t x)
{
    return (double) x;
}
static inline double sitofp_i16_f64(int16_t x)
{
    return (double) x;
}
static inline double sitofp_i32_f64(int32_t x)
{
    return (double) x;
}
static inline double sitofp_i64_f64(int64_t x)
{
    return (double) x;
}
static inline double uitofp_i8_f64(uint8_t x)
{
    return (double) x;
}
static inline double uitofp_i16_f64(uint16_t x)
{
    return (double) x;
}
static inline double uitofp_i32_f64(uint32_t x)
{
    return (double) x;
}
static inline double uitofp_i64_f64(uint64_t x)
{
    return (double) x;
}
static inline int8_t fptosi_f64_i8(double x)
{
    return (int8_t) x;
}
static inline int16_t fptosi_f64_i16(double x)
{
    return (int16_t) x;
}
static inline int32_t fptosi_f64_i32(double x)
{
    return (int32_t) x;
}
static inline int64_t fptosi_f64_i64(double x)
{
    return (int64_t) x;
}
static inline uint8_t fptoui_f64_i8(double x)
{
    return (uint8_t) x;
}
static inline uint16_t fptoui_f64_i16(double x)
{
    return (uint16_t) x;
}
static inline uint32_t fptoui_f64_i32(double x)
{
    return (uint32_t) x;
}
static inline uint64_t fptoui_f64_i64(double x)
{
    return (uint64_t) x;
}
static inline float fpconv_f32_f32(float x)
{
    return (float) x;
}
static inline double fpconv_f32_f64(float x)
{
    return (double) x;
}
static inline float fpconv_f64_f32(double x)
{
    return (float) x;
}
static inline double fpconv_f64_f64(double x)
{
    return (double) x;
}
static inline float futrts_log32(float x)
{
    return log(x);
}
static inline float futrts_log2_32(float x)
{
    return log2(x);
}
static inline float futrts_log10_32(float x)
{
    return log10(x);
}
static inline float futrts_sqrt32(float x)
{
    return sqrt(x);
}
static inline float futrts_exp32(float x)
{
    return exp(x);
}
static inline float futrts_cos32(float x)
{
    return cos(x);
}
static inline float futrts_sin32(float x)
{
    return sin(x);
}
static inline float futrts_tan32(float x)
{
    return tan(x);
}
static inline float futrts_acos32(float x)
{
    return acos(x);
}
static inline float futrts_asin32(float x)
{
    return asin(x);
}
static inline float futrts_atan32(float x)
{
    return atan(x);
}
static inline float futrts_cosh32(float x)
{
    return cosh(x);
}
static inline float futrts_sinh32(float x)
{
    return sinh(x);
}
static inline float futrts_tanh32(float x)
{
    return tanh(x);
}
static inline float futrts_acosh32(float x)
{
    return acosh(x);
}
static inline float futrts_asinh32(float x)
{
    return asinh(x);
}
static inline float futrts_atanh32(float x)
{
    return atanh(x);
}
static inline float futrts_atan2_32(float x, float y)
{
    return atan2(x, y);
}
static inline float futrts_gamma32(float x)
{
    return tgamma(x);
}
static inline float futrts_lgamma32(float x)
{
    return lgamma(x);
}
static inline bool futrts_isnan32(float x)
{
    return isnan(x);
}
static inline bool futrts_isinf32(float x)
{
    return isinf(x);
}
static inline int32_t futrts_to_bits32(float x)
{
    union {
        float f;
        int32_t t;
    } p;
    
    p.f = x;
    return p.t;
}
static inline float futrts_from_bits32(int32_t x)
{
    union {
        int32_t f;
        float t;
    } p;
    
    p.f = x;
    return p.t;
}
#ifdef __OPENCL_VERSION__
static inline float fmod32(float x, float y)
{
    return fmod(x, y);
}
static inline float futrts_round32(float x)
{
    return rint(x);
}
static inline float futrts_floor32(float x)
{
    return floor(x);
}
static inline float futrts_ceil32(float x)
{
    return ceil(x);
}
static inline float futrts_lerp32(float v0, float v1, float t)
{
    return mix(v0, v1, t);
}
static inline float futrts_mad32(float a, float b, float c)
{
    return mad(a, b, c);
}
static inline float futrts_fma32(float a, float b, float c)
{
    return fma(a, b, c);
}
#else
static inline float fmod32(float x, float y)
{
    return fmodf(x, y);
}
static inline float futrts_round32(float x)
{
    return rintf(x);
}
static inline float futrts_floor32(float x)
{
    return floorf(x);
}
static inline float futrts_ceil32(float x)
{
    return ceilf(x);
}
static inline float futrts_lerp32(float v0, float v1, float t)
{
    return v0 + (v1 - v0) * t;
}
static inline float futrts_mad32(float a, float b, float c)
{
    return a * b + c;
}
static inline float futrts_fma32(float a, float b, float c)
{
    return fmaf(a, b, c);
}
#endif
static inline double futrts_log64(double x)
{
    return log(x);
}
static inline double futrts_log2_64(double x)
{
    return log2(x);
}
static inline double futrts_log10_64(double x)
{
    return log10(x);
}
static inline double futrts_sqrt64(double x)
{
    return sqrt(x);
}
static inline double futrts_exp64(double x)
{
    return exp(x);
}
static inline double futrts_cos64(double x)
{
    return cos(x);
}
static inline double futrts_sin64(double x)
{
    return sin(x);
}
static inline double futrts_tan64(double x)
{
    return tan(x);
}
static inline double futrts_acos64(double x)
{
    return acos(x);
}
static inline double futrts_asin64(double x)
{
    return asin(x);
}
static inline double futrts_atan64(double x)
{
    return atan(x);
}
static inline double futrts_cosh64(double x)
{
    return cosh(x);
}
static inline double futrts_sinh64(double x)
{
    return sinh(x);
}
static inline double futrts_tanh64(double x)
{
    return tanh(x);
}
static inline double futrts_acosh64(double x)
{
    return acosh(x);
}
static inline double futrts_asinh64(double x)
{
    return asinh(x);
}
static inline double futrts_atanh64(double x)
{
    return atanh(x);
}
static inline double futrts_atan2_64(double x, double y)
{
    return atan2(x, y);
}
static inline double futrts_gamma64(double x)
{
    return tgamma(x);
}
static inline double futrts_lgamma64(double x)
{
    return lgamma(x);
}
static inline double futrts_fma64(double a, double b, double c)
{
    return fma(a, b, c);
}
static inline double futrts_round64(double x)
{
    return rint(x);
}
static inline double futrts_ceil64(double x)
{
    return ceil(x);
}
static inline double futrts_floor64(double x)
{
    return floor(x);
}
static inline bool futrts_isnan64(double x)
{
    return isnan(x);
}
static inline bool futrts_isinf64(double x)
{
    return isinf(x);
}
static inline int64_t futrts_to_bits64(double x)
{
    union {
        double f;
        int64_t t;
    } p;
    
    p.f = x;
    return p.t;
}
static inline double futrts_from_bits64(int64_t x)
{
    union {
        int64_t f;
        double t;
    } p;
    
    p.f = x;
    return p.t;
}
static inline double fmod64(double x, double y)
{
    return fmod(x, y);
}
#ifdef __OPENCL_VERSION__
static inline double futrts_lerp64(double v0, double v1, double t)
{
    return mix(v0, v1, t);
}
static inline double futrts_mad64(double a, double b, double c)
{
    return mad(a, b, c);
}
#else
static inline double futrts_lerp64(double v0, double v1, double t)
{
    return v0 + (v1 - v0) * t;
}
static inline double futrts_mad64(double a, double b, double c)
{
    return a * b + c;
}
#endif
int init_constants(struct futhark_context *);
int free_constants(struct futhark_context *);
static int32_t mainzicounter_mem_realtype_23802[10] = {0, 0, 0, 0, 0, 0, 0, 0,
                                                       0, 0};
static int32_t mainzicounter_mem_realtype_23809[10] = {0, 0, 0, 0, 0, 0, 0, 0,
                                                       0, 0};
static int32_t mainzicounter_mem_realtype_23821[10] = {0, 0, 0, 0, 0, 0, 0, 0,
                                                       0, 0};
static int32_t mainzicounter_mem_realtype_23848[10] = {0, 0, 0, 0, 0, 0, 0, 0,
                                                       0, 0};
static int32_t mainzicounter_mem_realtype_23870[10240];
static int32_t mainzicounter_mem_realtype_23881[10] = {0, 0, 0, 0, 0, 0, 0, 0,
                                                       0, 0};
static float testzistatic_array_realtype_23889[9] = {1.0F, -0.5F, 1.0F, 1.0F,
                                                     1.0F, 1.0F, 1.0F, 1.0F,
                                                     1.0F};
static int64_t testzistatic_array_realtype_23890[9] = {10, 20, 5, 5, 50, 20, 30,
                                                       15, 18};
static float testzistatic_array_realtype_23891[9] = {1.0F, 0.5F, 0.25F, 0.1F,
                                                     0.3F, 0.1F, 2.0F, 3.0F,
                                                     1.0F};
static int32_t testzicounter_mem_realtype_23892[10] = {0, 0, 0, 0, 0, 0, 0, 0,
                                                       0, 0};
static int32_t testzicounter_mem_realtype_23899[10] = {0, 0, 0, 0, 0, 0, 0, 0,
                                                       0, 0};
static int32_t testzicounter_mem_realtype_23911[10] = {0, 0, 0, 0, 0, 0, 0, 0,
                                                       0, 0};
static int32_t testzicounter_mem_realtype_23938[10] = {0, 0, 0, 0, 0, 0, 0, 0,
                                                       0, 0};
static int32_t testzicounter_mem_realtype_23960[10240];
static int32_t testzicounter_mem_realtype_23971[10] = {0, 0, 0, 0, 0, 0, 0, 0,
                                                       0, 0};
struct memblock_device {
    int *references;
    cl_mem mem;
    int64_t size;
    const char *desc;
} ;
struct memblock {
    int *references;
    char *mem;
    int64_t size;
    const char *desc;
} ;
typedef cl_mem fl_mem_t;
// Start of free_list.h.

// An entry in the free list.  May be invalid, to avoid having to
// deallocate entries as soon as they are removed.  There is also a
// tag, to help with memory reuse.
struct free_list_entry {
  size_t size;
  fl_mem_t mem;
  const char *tag;
  unsigned char valid;
};

struct free_list {
  struct free_list_entry *entries;        // Pointer to entries.
  int capacity;                           // Number of entries.
  int used;                               // Number of valid entries.
};

static void free_list_init(struct free_list *l) {
  l->capacity = 30; // Picked arbitrarily.
  l->used = 0;
  l->entries = (struct free_list_entry*) malloc(sizeof(struct free_list_entry) * l->capacity);
  for (int i = 0; i < l->capacity; i++) {
    l->entries[i].valid = 0;
  }
}

// Remove invalid entries from the free list.
static void free_list_pack(struct free_list *l) {
  int p = 0;
  for (int i = 0; i < l->capacity; i++) {
    if (l->entries[i].valid) {
      l->entries[p] = l->entries[i];
      p++;
    }
  }

  // Now p is the number of used elements.  We don't want it to go
  // less than the default capacity (although in practice it's OK as
  // long as it doesn't become 1).
  if (p < 30) {
    p = 30;
  }
  l->entries = realloc(l->entries, p * sizeof(struct free_list_entry));
  l->capacity = p;
}

static void free_list_destroy(struct free_list *l) {
  assert(l->used == 0);
  free(l->entries);
}

static int free_list_find_invalid(struct free_list *l) {
  int i;
  for (i = 0; i < l->capacity; i++) {
    if (!l->entries[i].valid) {
      break;
    }
  }
  return i;
}

static void free_list_insert(struct free_list *l, size_t size, fl_mem_t mem, const char *tag) {
  int i = free_list_find_invalid(l);

  if (i == l->capacity) {
    // List is full; so we have to grow it.
    int new_capacity = l->capacity * 2 * sizeof(struct free_list_entry);
    l->entries = realloc(l->entries, new_capacity);
    for (int j = 0; j < l->capacity; j++) {
      l->entries[j+l->capacity].valid = 0;
    }
    l->capacity *= 2;
  }

  // Now 'i' points to the first invalid entry.
  l->entries[i].valid = 1;
  l->entries[i].size = size;
  l->entries[i].mem = mem;
  l->entries[i].tag = tag;

  l->used++;
}

// Find and remove a memory block of the indicated tag, or if that
// does not exist, another memory block with exactly the desired size.
// Returns 0 on success.
static int free_list_find(struct free_list *l, size_t size,
                          size_t *size_out, fl_mem_t *mem_out) {
  int size_match = -1;
  int i;
  for (i = 0; i < l->capacity; i++) {
    if (l->entries[i].valid &&
        size <= l->entries[i].size &&
        (size_match < 0 || l->entries[i].size < l->entries[size_match].size)) {
      // If this entry is valid, has sufficient size, and is smaller than the
      // best entry found so far, use this entry.
      size_match = i;
    }
  }

  if (size_match >= 0) {
    l->entries[size_match].valid = 0;
    *size_out = l->entries[size_match].size;
    *mem_out = l->entries[size_match].mem;
    l->used--;
    return 0;
  } else {
    return 1;
  }
}

// Remove the first block in the free list.  Returns 0 if a block was
// removed, and nonzero if the free list was already empty.
static int free_list_first(struct free_list *l, fl_mem_t *mem_out) {
  for (int i = 0; i < l->capacity; i++) {
    if (l->entries[i].valid) {
      l->entries[i].valid = 0;
      *mem_out = l->entries[i].mem;
      l->used--;
      return 0;
    }
  }

  return 1;
}

// End of free_list.h.

// Start of opencl.h.

#define OPENCL_SUCCEED_FATAL(e) opencl_succeed_fatal(e, #e, __FILE__, __LINE__)
#define OPENCL_SUCCEED_NONFATAL(e) opencl_succeed_nonfatal(e, #e, __FILE__, __LINE__)
// Take care not to override an existing error.
#define OPENCL_SUCCEED_OR_RETURN(e) {             \
    char *serror = OPENCL_SUCCEED_NONFATAL(e);    \
    if (serror) {                                 \
      if (!ctx->error) {                          \
        ctx->error = serror;                      \
        return bad;                               \
      } else {                                    \
        free(serror);                             \
      }                                           \
    }                                             \
  }

// OPENCL_SUCCEED_OR_RETURN returns the value of the variable 'bad' in
// scope.  By default, it will be this one.  Create a local variable
// of some other type if needed.  This is a bit of a hack, but it
// saves effort in the code generator.
static const int bad = 1;

struct opencl_config {
  int debugging;
  int profiling;
  int logging;
  int preferred_device_num;
  const char *preferred_platform;
  const char *preferred_device;
  int ignore_blacklist;

  const char* dump_program_to;
  const char* load_program_from;
  const char* dump_binary_to;
  const char* load_binary_from;

  size_t default_group_size;
  size_t default_num_groups;
  size_t default_tile_size;
  size_t default_threshold;

  int default_group_size_changed;
  int default_tile_size_changed;

  int num_sizes;
  const char **size_names;
  const char **size_vars;
  size_t *size_values;
  const char **size_classes;
};

static void opencl_config_init(struct opencl_config *cfg,
                               int num_sizes,
                               const char *size_names[],
                               const char *size_vars[],
                               size_t *size_values,
                               const char *size_classes[]) {
  cfg->debugging = 0;
  cfg->logging = 0;
  cfg->profiling = 0;
  cfg->preferred_device_num = 0;
  cfg->preferred_platform = "";
  cfg->preferred_device = "";
  cfg->ignore_blacklist = 0;
  cfg->dump_program_to = NULL;
  cfg->load_program_from = NULL;
  cfg->dump_binary_to = NULL;
  cfg->load_binary_from = NULL;

  // The following are dummy sizes that mean the concrete defaults
  // will be set during initialisation via hardware-inspection-based
  // heuristics.
  cfg->default_group_size = 0;
  cfg->default_num_groups = 0;
  cfg->default_tile_size = 0;
  cfg->default_threshold = 0;

  cfg->default_group_size_changed = 0;
  cfg->default_tile_size_changed = 0;

  cfg->num_sizes = num_sizes;
  cfg->size_names = size_names;
  cfg->size_vars = size_vars;
  cfg->size_values = size_values;
  cfg->size_classes = size_classes;
}

// A record of something that happened.
struct profiling_record {
  cl_event *event;
  int *runs;
  int64_t *runtime;
};

struct opencl_context {
  cl_device_id device;
  cl_context ctx;
  cl_command_queue queue;

  struct opencl_config cfg;

  struct free_list free_list;

  size_t max_group_size;
  size_t max_num_groups;
  size_t max_tile_size;
  size_t max_threshold;
  size_t max_local_memory;

  size_t lockstep_width;

  struct profiling_record *profiling_records;
  int profiling_records_capacity;
  int profiling_records_used;
};

struct opencl_device_option {
  cl_platform_id platform;
  cl_device_id device;
  cl_device_type device_type;
  char *platform_name;
  char *device_name;
};

// This function must be defined by the user.  It is invoked by
// setup_opencl() after the platform and device has been found, but
// before the program is loaded.  Its intended use is to tune
// constants based on the selected platform and device.
static void post_opencl_setup(struct opencl_context*, struct opencl_device_option*);

static char *strclone(const char *str) {
  size_t size = strlen(str) + 1;
  char *copy = (char*) malloc(size);
  if (copy == NULL) {
    return NULL;
  }

  memcpy(copy, str, size);
  return copy;
}

static const char* opencl_error_string(cl_int err)
{
    switch (err) {
        case CL_SUCCESS:                            return "Success!";
        case CL_DEVICE_NOT_FOUND:                   return "Device not found.";
        case CL_DEVICE_NOT_AVAILABLE:               return "Device not available";
        case CL_COMPILER_NOT_AVAILABLE:             return "Compiler not available";
        case CL_MEM_OBJECT_ALLOCATION_FAILURE:      return "Memory object allocation failure";
        case CL_OUT_OF_RESOURCES:                   return "Out of resources";
        case CL_OUT_OF_HOST_MEMORY:                 return "Out of host memory";
        case CL_PROFILING_INFO_NOT_AVAILABLE:       return "Profiling information not available";
        case CL_MEM_COPY_OVERLAP:                   return "Memory copy overlap";
        case CL_IMAGE_FORMAT_MISMATCH:              return "Image format mismatch";
        case CL_IMAGE_FORMAT_NOT_SUPPORTED:         return "Image format not supported";
        case CL_BUILD_PROGRAM_FAILURE:              return "Program build failure";
        case CL_MAP_FAILURE:                        return "Map failure";
        case CL_INVALID_VALUE:                      return "Invalid value";
        case CL_INVALID_DEVICE_TYPE:                return "Invalid device type";
        case CL_INVALID_PLATFORM:                   return "Invalid platform";
        case CL_INVALID_DEVICE:                     return "Invalid device";
        case CL_INVALID_CONTEXT:                    return "Invalid context";
        case CL_INVALID_QUEUE_PROPERTIES:           return "Invalid queue properties";
        case CL_INVALID_COMMAND_QUEUE:              return "Invalid command queue";
        case CL_INVALID_HOST_PTR:                   return "Invalid host pointer";
        case CL_INVALID_MEM_OBJECT:                 return "Invalid memory object";
        case CL_INVALID_IMAGE_FORMAT_DESCRIPTOR:    return "Invalid image format descriptor";
        case CL_INVALID_IMAGE_SIZE:                 return "Invalid image size";
        case CL_INVALID_SAMPLER:                    return "Invalid sampler";
        case CL_INVALID_BINARY:                     return "Invalid binary";
        case CL_INVALID_BUILD_OPTIONS:              return "Invalid build options";
        case CL_INVALID_PROGRAM:                    return "Invalid program";
        case CL_INVALID_PROGRAM_EXECUTABLE:         return "Invalid program executable";
        case CL_INVALID_KERNEL_NAME:                return "Invalid kernel name";
        case CL_INVALID_KERNEL_DEFINITION:          return "Invalid kernel definition";
        case CL_INVALID_KERNEL:                     return "Invalid kernel";
        case CL_INVALID_ARG_INDEX:                  return "Invalid argument index";
        case CL_INVALID_ARG_VALUE:                  return "Invalid argument value";
        case CL_INVALID_ARG_SIZE:                   return "Invalid argument size";
        case CL_INVALID_KERNEL_ARGS:                return "Invalid kernel arguments";
        case CL_INVALID_WORK_DIMENSION:             return "Invalid work dimension";
        case CL_INVALID_WORK_GROUP_SIZE:            return "Invalid work group size";
        case CL_INVALID_WORK_ITEM_SIZE:             return "Invalid work item size";
        case CL_INVALID_GLOBAL_OFFSET:              return "Invalid global offset";
        case CL_INVALID_EVENT_WAIT_LIST:            return "Invalid event wait list";
        case CL_INVALID_EVENT:                      return "Invalid event";
        case CL_INVALID_OPERATION:                  return "Invalid operation";
        case CL_INVALID_GL_OBJECT:                  return "Invalid OpenGL object";
        case CL_INVALID_BUFFER_SIZE:                return "Invalid buffer size";
        case CL_INVALID_MIP_LEVEL:                  return "Invalid mip-map level";
        default:                                    return "Unknown";
    }
}

static void opencl_succeed_fatal(unsigned int ret,
                                 const char *call,
                                 const char *file,
                                 int line) {
  if (ret != CL_SUCCESS) {
    futhark_panic(-1, "%s:%d: OpenCL call\n  %s\nfailed with error code %d (%s)\n",
          file, line, call, ret, opencl_error_string(ret));
  }
}

static char* opencl_succeed_nonfatal(unsigned int ret,
                                     const char *call,
                                     const char *file,
                                     int line) {
  if (ret != CL_SUCCESS) {
    return msgprintf("%s:%d: OpenCL call\n  %s\nfailed with error code %d (%s)\n",
                     file, line, call, ret, opencl_error_string(ret));
  } else {
    return NULL;
  }
}

static void set_preferred_platform(struct opencl_config *cfg, const char *s) {
  cfg->preferred_platform = s;
  cfg->ignore_blacklist = 1;
}

static void set_preferred_device(struct opencl_config *cfg, const char *s) {
  int x = 0;
  if (*s == '#') {
    s++;
    while (isdigit(*s)) {
      x = x * 10 + (*s++)-'0';
    }
    // Skip trailing spaces.
    while (isspace(*s)) {
      s++;
    }
  }
  cfg->preferred_device = s;
  cfg->preferred_device_num = x;
  cfg->ignore_blacklist = 1;
}

static char* opencl_platform_info(cl_platform_id platform,
                                  cl_platform_info param) {
  size_t req_bytes;
  char *info;

  OPENCL_SUCCEED_FATAL(clGetPlatformInfo(platform, param, 0, NULL, &req_bytes));

  info = (char*) malloc(req_bytes);

  OPENCL_SUCCEED_FATAL(clGetPlatformInfo(platform, param, req_bytes, info, NULL));

  return info;
}

static char* opencl_device_info(cl_device_id device,
                                cl_device_info param) {
  size_t req_bytes;
  char *info;

  OPENCL_SUCCEED_FATAL(clGetDeviceInfo(device, param, 0, NULL, &req_bytes));

  info = (char*) malloc(req_bytes);

  OPENCL_SUCCEED_FATAL(clGetDeviceInfo(device, param, req_bytes, info, NULL));

  return info;
}

static void opencl_all_device_options(struct opencl_device_option **devices_out,
                                      size_t *num_devices_out) {
  size_t num_devices = 0, num_devices_added = 0;

  cl_platform_id *all_platforms;
  cl_uint *platform_num_devices;

  cl_uint num_platforms;

  // Find the number of platforms.
  OPENCL_SUCCEED_FATAL(clGetPlatformIDs(0, NULL, &num_platforms));

  // Make room for them.
  all_platforms = calloc(num_platforms, sizeof(cl_platform_id));
  platform_num_devices = calloc(num_platforms, sizeof(cl_uint));

  // Fetch all the platforms.
  OPENCL_SUCCEED_FATAL(clGetPlatformIDs(num_platforms, all_platforms, NULL));

  // Count the number of devices for each platform, as well as the
  // total number of devices.
  for (cl_uint i = 0; i < num_platforms; i++) {
    if (clGetDeviceIDs(all_platforms[i], CL_DEVICE_TYPE_ALL,
                       0, NULL, &platform_num_devices[i]) == CL_SUCCESS) {
      num_devices += platform_num_devices[i];
    } else {
      platform_num_devices[i] = 0;
    }
  }

  // Make room for all the device options.
  struct opencl_device_option *devices =
    calloc(num_devices, sizeof(struct opencl_device_option));

  // Loop through the platforms, getting information about their devices.
  for (cl_uint i = 0; i < num_platforms; i++) {
    cl_platform_id platform = all_platforms[i];
    cl_uint num_platform_devices = platform_num_devices[i];

    if (num_platform_devices == 0) {
      continue;
    }

    char *platform_name = opencl_platform_info(platform, CL_PLATFORM_NAME);
    cl_device_id *platform_devices =
      calloc(num_platform_devices, sizeof(cl_device_id));

    // Fetch all the devices.
    OPENCL_SUCCEED_FATAL(clGetDeviceIDs(platform, CL_DEVICE_TYPE_ALL,
                                  num_platform_devices, platform_devices, NULL));

    // Loop through the devices, adding them to the devices array.
    for (cl_uint i = 0; i < num_platform_devices; i++) {
      char *device_name = opencl_device_info(platform_devices[i], CL_DEVICE_NAME);
      devices[num_devices_added].platform = platform;
      devices[num_devices_added].device = platform_devices[i];
      OPENCL_SUCCEED_FATAL(clGetDeviceInfo(platform_devices[i], CL_DEVICE_TYPE,
                                     sizeof(cl_device_type),
                                     &devices[num_devices_added].device_type,
                                     NULL));
      // We don't want the structs to share memory, so copy the platform name.
      // Each device name is already unique.
      devices[num_devices_added].platform_name = strclone(platform_name);
      devices[num_devices_added].device_name = device_name;
      num_devices_added++;
    }
    free(platform_devices);
    free(platform_name);
  }
  free(all_platforms);
  free(platform_num_devices);

  *devices_out = devices;
  *num_devices_out = num_devices;
}

// Returns 0 on success.
static int list_devices(struct opencl_config *cfg) {
  struct opencl_device_option *devices;
  size_t num_devices;

  opencl_all_device_options(&devices, &num_devices);

  const char *cur_platform = "";
  for (size_t i = 0; i < num_devices; i++) {
    struct opencl_device_option device = devices[i];
    if (strcmp(cur_platform, device.platform_name) != 0) {
      printf("Platform: %s\n", device.platform_name);
      cur_platform = device.platform_name;
    }
    printf("[%d]: %s\n", (int)i, device.device_name);
  }

  // Free all the platform and device names.
  for (size_t j = 0; j < num_devices; j++) {
    free(devices[j].platform_name);
    free(devices[j].device_name);
  }
  free(devices);

  return 0;
}

// Returns 0 on success.
static int select_device_interactively(struct opencl_config *cfg) {
  struct opencl_device_option *devices;
  size_t num_devices;
  int ret = 1;

  opencl_all_device_options(&devices, &num_devices);

  printf("Choose OpenCL device:\n");
  const char *cur_platform = "";
  for (size_t i = 0; i < num_devices; i++) {
    struct opencl_device_option device = devices[i];
    if (strcmp(cur_platform, device.platform_name) != 0) {
      printf("Platform: %s\n", device.platform_name);
      cur_platform = device.platform_name;
    }
    printf("[%d] %s\n", (int)i, device.device_name);
  }

  int selection;
  printf("Choice: ");
  if (scanf("%d", &selection) == 1) {
    ret = 0;
    cfg->preferred_platform = "";
    cfg->preferred_device = "";
    cfg->preferred_device_num = selection;
    cfg->ignore_blacklist = 1;
  }

  // Free all the platform and device names.
  for (size_t j = 0; j < num_devices; j++) {
    free(devices[j].platform_name);
    free(devices[j].device_name);
  }
  free(devices);

  return ret;
}

static int is_blacklisted(const char *platform_name, const char *device_name,
                          const struct opencl_config *cfg) {
  if (strcmp(cfg->preferred_platform, "") != 0 ||
      strcmp(cfg->preferred_device, "") != 0) {
    return 0;
  } else if (strstr(platform_name, "Apple") != NULL &&
             strstr(device_name, "Intel(R) Core(TM)") != NULL) {
    return 1;
  } else {
    return 0;
  }
}

static struct opencl_device_option get_preferred_device(const struct opencl_config *cfg) {
  struct opencl_device_option *devices;
  size_t num_devices;

  opencl_all_device_options(&devices, &num_devices);

  int num_device_matches = 0;

  for (size_t i = 0; i < num_devices; i++) {
    struct opencl_device_option device = devices[i];
    if (strstr(device.platform_name, cfg->preferred_platform) != NULL &&
        strstr(device.device_name, cfg->preferred_device) != NULL &&
        (cfg->ignore_blacklist ||
         !is_blacklisted(device.platform_name, device.device_name, cfg)) &&
        num_device_matches++ == cfg->preferred_device_num) {
      // Free all the platform and device names, except the ones we have chosen.
      for (size_t j = 0; j < num_devices; j++) {
        if (j != i) {
          free(devices[j].platform_name);
          free(devices[j].device_name);
        }
      }
      free(devices);
      return device;
    }
  }

  futhark_panic(1, "Could not find acceptable OpenCL device.\n");
  exit(1); // Never reached
}

static void describe_device_option(struct opencl_device_option device) {
  fprintf(stderr, "Using platform: %s\n", device.platform_name);
  fprintf(stderr, "Using device: %s\n", device.device_name);
}

static cl_build_status build_opencl_program(cl_program program, cl_device_id device, const char* options) {
  cl_int clBuildProgram_error = clBuildProgram(program, 1, &device, options, NULL, NULL);

  // Avoid termination due to CL_BUILD_PROGRAM_FAILURE
  if (clBuildProgram_error != CL_SUCCESS &&
      clBuildProgram_error != CL_BUILD_PROGRAM_FAILURE) {
    OPENCL_SUCCEED_FATAL(clBuildProgram_error);
  }

  cl_build_status build_status;
  OPENCL_SUCCEED_FATAL(clGetProgramBuildInfo(program,
                                             device,
                                             CL_PROGRAM_BUILD_STATUS,
                                             sizeof(cl_build_status),
                                             &build_status,
                                             NULL));

  if (build_status != CL_SUCCESS) {
    char *build_log;
    size_t ret_val_size;
    OPENCL_SUCCEED_FATAL(clGetProgramBuildInfo(program, device, CL_PROGRAM_BUILD_LOG, 0, NULL, &ret_val_size));

    build_log = (char*) malloc(ret_val_size+1);
    OPENCL_SUCCEED_FATAL(clGetProgramBuildInfo(program, device, CL_PROGRAM_BUILD_LOG, ret_val_size, build_log, NULL));

    // The spec technically does not say whether the build log is zero-terminated, so let's be careful.
    build_log[ret_val_size] = '\0';

    fprintf(stderr, "Build log:\n%s\n", build_log);

    free(build_log);
  }

  return build_status;
}

// Fields in a bitmask indicating which types we must be sure are
// available.
enum opencl_required_type { OPENCL_F64 = 1 };

// We take as input several strings representing the program, because
// C does not guarantee that the compiler supports particularly large
// literals.  Notably, Visual C has a limit of 2048 characters.  The
// array must be NULL-terminated.
static cl_program setup_opencl_with_command_queue(struct opencl_context *ctx,
                                                  cl_command_queue queue,
                                                  const char *srcs[],
                                                  int required_types,
                                                  const char *extra_build_opts[]) {
  int error;

  free_list_init(&ctx->free_list);
  ctx->queue = queue;

  OPENCL_SUCCEED_FATAL(clGetCommandQueueInfo(ctx->queue, CL_QUEUE_CONTEXT, sizeof(cl_context), &ctx->ctx, NULL));

  // Fill out the device info.  This is redundant work if we are
  // called from setup_opencl() (which is the common case), but I
  // doubt it matters much.
  struct opencl_device_option device_option;
  OPENCL_SUCCEED_FATAL(clGetCommandQueueInfo(ctx->queue, CL_QUEUE_DEVICE,
                                       sizeof(cl_device_id),
                                       &device_option.device,
                                       NULL));
  OPENCL_SUCCEED_FATAL(clGetDeviceInfo(device_option.device, CL_DEVICE_PLATFORM,
                                 sizeof(cl_platform_id),
                                 &device_option.platform,
                                 NULL));
  OPENCL_SUCCEED_FATAL(clGetDeviceInfo(device_option.device, CL_DEVICE_TYPE,
                                 sizeof(cl_device_type),
                                 &device_option.device_type,
                                 NULL));
  device_option.platform_name = opencl_platform_info(device_option.platform, CL_PLATFORM_NAME);
  device_option.device_name = opencl_device_info(device_option.device, CL_DEVICE_NAME);

  ctx->device = device_option.device;

  if (required_types & OPENCL_F64) {
    cl_uint supported;
    OPENCL_SUCCEED_FATAL(clGetDeviceInfo(device_option.device, CL_DEVICE_PREFERRED_VECTOR_WIDTH_DOUBLE,
                                   sizeof(cl_uint), &supported, NULL));
    if (!supported) {
      futhark_panic(1, "Program uses double-precision floats, but this is not supported on the chosen device: %s\n",
            device_option.device_name);
    }
  }

  size_t max_group_size;
  OPENCL_SUCCEED_FATAL(clGetDeviceInfo(device_option.device, CL_DEVICE_MAX_WORK_GROUP_SIZE,
                                 sizeof(size_t), &max_group_size, NULL));

  size_t max_tile_size = sqrt(max_group_size);

  cl_ulong max_local_memory;
  OPENCL_SUCCEED_FATAL(clGetDeviceInfo(device_option.device, CL_DEVICE_LOCAL_MEM_SIZE,
                                       sizeof(size_t), &max_local_memory, NULL));

  // Futhark reserves 4 bytes for bookkeeping information.
  max_local_memory -= 4;

  // The OpenCL implementation may reserve some local memory bytes for
  // various purposes.  In principle, we should use
  // clGetKernelWorkGroupInfo() to figure out for each kernel how much
  // is actually available, but our current code generator design
  // makes this infeasible.  Instead, we have this nasty hack where we
  // arbitrarily subtract some bytes, based on empirical measurements
  // (but which might be arbitrarily wrong).  Fortunately, we rarely
  // try to really push the local memory usage.
  if (strstr(device_option.platform_name, "NVIDIA CUDA") != NULL) {
    max_local_memory -= 12;
  } else if (strstr(device_option.platform_name, "AMD") != NULL) {
    max_local_memory -= 16;
  }

  // Make sure this function is defined.
  post_opencl_setup(ctx, &device_option);

  if (max_group_size < ctx->cfg.default_group_size) {
    if (ctx->cfg.default_group_size_changed) {
      fprintf(stderr, "Note: Device limits default group size to %zu (down from %zu).\n",
              max_group_size, ctx->cfg.default_group_size);
    }
    ctx->cfg.default_group_size = max_group_size;
  }

  if (max_tile_size < ctx->cfg.default_tile_size) {
    if (ctx->cfg.default_tile_size_changed) {
      fprintf(stderr, "Note: Device limits default tile size to %zu (down from %zu).\n",
              max_tile_size, ctx->cfg.default_tile_size);
    }
    ctx->cfg.default_tile_size = max_tile_size;
  }

  ctx->max_group_size = max_group_size;
  ctx->max_tile_size = max_tile_size; // No limit.
  ctx->max_threshold = ctx->max_num_groups = 0; // No limit.
  ctx->max_local_memory = max_local_memory;

  // Now we go through all the sizes, clamp them to the valid range,
  // or set them to the default.
  for (int i = 0; i < ctx->cfg.num_sizes; i++) {
    const char *size_class = ctx->cfg.size_classes[i];
    size_t *size_value = &ctx->cfg.size_values[i];
    const char* size_name = ctx->cfg.size_names[i];
    size_t max_value = 0, default_value = 0;
    if (strstr(size_class, "group_size") == size_class) {
      max_value = max_group_size;
      default_value = ctx->cfg.default_group_size;
    } else if (strstr(size_class, "num_groups") == size_class) {
      max_value = max_group_size; // Futhark assumes this constraint.
      default_value = ctx->cfg.default_num_groups;
      // XXX: as a quick and dirty hack, use twice as many threads for
      // histograms by default.  We really should just be smarter
      // about sizes somehow.
      if (strstr(size_name, ".seghist_") != NULL) {
        default_value *= 2;
      }
    } else if (strstr(size_class, "tile_size") == size_class) {
      max_value = sqrt(max_group_size);
      default_value = ctx->cfg.default_tile_size;
    } else if (strstr(size_class, "threshold") == size_class) {
      // Threshold can be as large as it takes.
      default_value = ctx->cfg.default_threshold;
    } else {
      // Bespoke sizes have no limit or default.
    }
    if (*size_value == 0) {
      *size_value = default_value;
    } else if (max_value > 0 && *size_value > max_value) {
      fprintf(stderr, "Note: Device limits %s to %d (down from %d)\n",
              size_name, (int)max_value, (int)*size_value);
      *size_value = max_value;
    }
  }

  if (ctx->lockstep_width == 0) {
    ctx->lockstep_width = 1;
  }

  if (ctx->cfg.logging) {
    fprintf(stderr, "Lockstep width: %d\n", (int)ctx->lockstep_width);
    fprintf(stderr, "Default group size: %d\n", (int)ctx->cfg.default_group_size);
    fprintf(stderr, "Default number of groups: %d\n", (int)ctx->cfg.default_num_groups);
  }

  char *fut_opencl_src = NULL;
  cl_program prog;
  error = CL_SUCCESS;

  if (ctx->cfg.load_binary_from == NULL) {
    size_t src_size = 0;

    // Maybe we have to read OpenCL source from somewhere else (used for debugging).
    if (ctx->cfg.load_program_from != NULL) {
      fut_opencl_src = slurp_file(ctx->cfg.load_program_from, NULL);
      assert(fut_opencl_src != NULL);
    } else {
      // Construct the OpenCL source concatenating all the fragments.
      for (const char **src = srcs; src && *src; src++) {
        src_size += strlen(*src);
      }

      fut_opencl_src = (char*) malloc(src_size + 1);

      size_t n, i;
      for (i = 0, n = 0; srcs && srcs[i]; i++) {
        strncpy(fut_opencl_src+n, srcs[i], src_size-n);
        n += strlen(srcs[i]);
      }
      fut_opencl_src[src_size] = 0;
    }

    if (ctx->cfg.dump_program_to != NULL) {
      if (ctx->cfg.debugging) {
        fprintf(stderr, "Dumping OpenCL source to %s...\n", ctx->cfg.dump_program_to);
      }

      dump_file(ctx->cfg.dump_program_to, fut_opencl_src, strlen(fut_opencl_src));
    }

    if (ctx->cfg.debugging) {
      fprintf(stderr, "Creating OpenCL program...\n");
    }

    const char* src_ptr[] = {fut_opencl_src};
    prog = clCreateProgramWithSource(ctx->ctx, 1, src_ptr, &src_size, &error);
    OPENCL_SUCCEED_FATAL(error);
  } else {
    if (ctx->cfg.debugging) {
      fprintf(stderr, "Loading OpenCL binary from %s...\n", ctx->cfg.load_binary_from);
    }
    size_t binary_size;
    unsigned char *fut_opencl_bin =
      (unsigned char*) slurp_file(ctx->cfg.load_binary_from, &binary_size);
    assert(fut_opencl_bin != NULL);
    const unsigned char *binaries[1] = { fut_opencl_bin };
    cl_int status = 0;

    prog = clCreateProgramWithBinary(ctx->ctx, 1, &device_option.device,
                                     &binary_size, binaries,
                                     &status, &error);

    OPENCL_SUCCEED_FATAL(status);
    OPENCL_SUCCEED_FATAL(error);
  }

  int compile_opts_size = 1024;

  for (int i = 0; i < ctx->cfg.num_sizes; i++) {
    compile_opts_size += strlen(ctx->cfg.size_names[i]) + 20;
  }

  for (int i = 0; extra_build_opts[i] != NULL; i++) {
    compile_opts_size += strlen(extra_build_opts[i] + 1);
  }

  char *compile_opts = (char*) malloc(compile_opts_size);

  int w = snprintf(compile_opts, compile_opts_size,
                   "-DLOCKSTEP_WIDTH=%d ",
                   (int)ctx->lockstep_width);

  for (int i = 0; i < ctx->cfg.num_sizes; i++) {
    w += snprintf(compile_opts+w, compile_opts_size-w,
                  "-D%s=%d ",
                  ctx->cfg.size_vars[i],
                  (int)ctx->cfg.size_values[i]);
  }

  for (int i = 0; extra_build_opts[i] != NULL; i++) {
    w += snprintf(compile_opts+w, compile_opts_size-w,
                  "%s ", extra_build_opts[i]);
  }

  if (ctx->cfg.debugging) {
    fprintf(stderr, "OpenCL compiler options: %s\n", compile_opts);
    fprintf(stderr, "Building OpenCL program...\n");
  }
  OPENCL_SUCCEED_FATAL(build_opencl_program(prog, device_option.device, compile_opts));

  free(compile_opts);
  free(fut_opencl_src);

  if (ctx->cfg.dump_binary_to != NULL) {
    if (ctx->cfg.debugging) {
      fprintf(stderr, "Dumping OpenCL binary to %s...\n", ctx->cfg.dump_binary_to);
    }

    size_t binary_size;
    OPENCL_SUCCEED_FATAL(clGetProgramInfo(prog, CL_PROGRAM_BINARY_SIZES,
                                          sizeof(size_t), &binary_size, NULL));
    unsigned char *binary = (unsigned char*) malloc(binary_size);
    unsigned char *binaries[1] = { binary };
    OPENCL_SUCCEED_FATAL(clGetProgramInfo(prog, CL_PROGRAM_BINARIES,
                                          sizeof(unsigned char*), binaries, NULL));

    dump_file(ctx->cfg.dump_binary_to, binary, binary_size);
  }

  return prog;
}

static cl_program setup_opencl(struct opencl_context *ctx,
                               const char *srcs[],
                               int required_types,
                               const char *extra_build_opts[]) {

  ctx->lockstep_width = 0; // Real value set later.

  struct opencl_device_option device_option = get_preferred_device(&ctx->cfg);

  if (ctx->cfg.logging) {
    describe_device_option(device_option);
  }

  // Note that NVIDIA's OpenCL requires the platform property
  cl_context_properties properties[] = {
    CL_CONTEXT_PLATFORM,
    (cl_context_properties)device_option.platform,
    0
  };

  cl_int clCreateContext_error;
  ctx->ctx = clCreateContext(properties, 1, &device_option.device, NULL, NULL, &clCreateContext_error);
  OPENCL_SUCCEED_FATAL(clCreateContext_error);

  cl_int clCreateCommandQueue_error;
  cl_command_queue queue =
    clCreateCommandQueue(ctx->ctx,
                         device_option.device,
                         ctx->cfg.profiling ? CL_QUEUE_PROFILING_ENABLE : 0,
                         &clCreateCommandQueue_error);
  OPENCL_SUCCEED_FATAL(clCreateCommandQueue_error);

  return setup_opencl_with_command_queue(ctx, queue, srcs, required_types, extra_build_opts);
}

// Count up the runtime all the profiling_records that occured during execution.
// Also clears the buffer of profiling_records.
static cl_int opencl_tally_profiling_records(struct opencl_context *ctx) {
  cl_int err;
  for (int i = 0; i < ctx->profiling_records_used; i++) {
    struct profiling_record record = ctx->profiling_records[i];

    cl_ulong start_t, end_t;

    if ((err = clGetEventProfilingInfo(*record.event,
                                       CL_PROFILING_COMMAND_START,
                                       sizeof(start_t),
                                       &start_t,
                                       NULL)) != CL_SUCCESS) {
      return err;
    }

    if ((err = clGetEventProfilingInfo(*record.event,
                                       CL_PROFILING_COMMAND_END,
                                       sizeof(end_t),
                                       &end_t,
                                       NULL)) != CL_SUCCESS) {
      return err;
    }

    // OpenCL provides nanosecond resolution, but we want
    // microseconds.
    *record.runs += 1;
    *record.runtime += (end_t - start_t)/1000;

    if ((err = clReleaseEvent(*record.event)) != CL_SUCCESS) {
      return err;
    }
    free(record.event);
  }

  ctx->profiling_records_used = 0;

  return CL_SUCCESS;
}

// If profiling, produce an event associated with a profiling record.
static cl_event* opencl_get_event(struct opencl_context *ctx, int *runs, int64_t *runtime) {
    if (ctx->profiling_records_used == ctx->profiling_records_capacity) {
      ctx->profiling_records_capacity *= 2;
      ctx->profiling_records =
        realloc(ctx->profiling_records,
                ctx->profiling_records_capacity *
                sizeof(struct profiling_record));
    }
    cl_event *event = malloc(sizeof(cl_event));
    ctx->profiling_records[ctx->profiling_records_used].event = event;
    ctx->profiling_records[ctx->profiling_records_used].runs = runs;
    ctx->profiling_records[ctx->profiling_records_used].runtime = runtime;
    ctx->profiling_records_used++;
    return event;
}

// Allocate memory from driver. The problem is that OpenCL may perform
// lazy allocation, so we cannot know whether an allocation succeeded
// until the first time we try to use it.  Hence we immediately
// perform a write to see if the allocation succeeded.  This is slow,
// but the assumption is that this operation will be rare (most things
// will go through the free list).
static int opencl_alloc_actual(struct opencl_context *ctx, size_t size, cl_mem *mem_out) {
  int error;
  *mem_out = clCreateBuffer(ctx->ctx, CL_MEM_READ_WRITE, size, NULL, &error);

  if (error != CL_SUCCESS) {
    return error;
  }

  int x = 2;
  error = clEnqueueWriteBuffer(ctx->queue, *mem_out, 1, 0, sizeof(x), &x, 0, NULL, NULL);

  // No need to wait for completion here. clWaitForEvents() cannot
  // return mem object allocation failures. This implies that the
  // buffer is faulted onto the device on enqueue. (Observation by
  // Andreas Kloeckner.)

  return error;
}

static int opencl_alloc(struct opencl_context *ctx, size_t min_size, const char *tag, cl_mem *mem_out) {
  (void)tag;
  if (min_size < sizeof(int)) {
    min_size = sizeof(int);
  }

  size_t size;

  if (free_list_find(&ctx->free_list, min_size, &size, mem_out) == 0) {
    // Successfully found a free block.  Is it big enough?
    //
    // FIXME: we might also want to check whether the block is *too
    // big*, to avoid internal fragmentation.  However, this can
    // sharply impact performance on programs where arrays change size
    // frequently.  Fortunately, such allocations are usually fairly
    // short-lived, as they are necessarily within a loop, so the risk
    // of internal fragmentation resulting in an OOM situation is
    // limited.  However, it would be preferable if we could go back
    // and *shrink* oversize allocations when we encounter an OOM
    // condition.  That is technically feasible, since we do not
    // expose OpenCL pointer values directly to the application, but
    // instead rely on a level of indirection.
    if (size >= min_size) {
      if (ctx->cfg.debugging) {
        fprintf(stderr, "No need to allocate: Found a block in the free list.\n");
      }

      return CL_SUCCESS;
    } else {
      if (ctx->cfg.debugging) {
        fprintf(stderr, "Found a free block, but it was too small.\n");
      }

      // Not just right - free it.
      int error = clReleaseMemObject(*mem_out);
      if (error != CL_SUCCESS) {
        return error;
      }
    }
  }

  // We have to allocate a new block from the driver.  If the
  // allocation does not succeed, then we might be in an out-of-memory
  // situation.  We now start freeing things from the free list until
  // we think we have freed enough that the allocation will succeed.
  // Since we don't know how far the allocation is from fitting, we
  // have to check after every deallocation.  This might be pretty
  // expensive.  Let's hope that this case is hit rarely.

  if (ctx->cfg.debugging) {
    fprintf(stderr, "Actually allocating the desired block.\n");
  }

  int error = opencl_alloc_actual(ctx, min_size, mem_out);

  while (error == CL_MEM_OBJECT_ALLOCATION_FAILURE) {
    if (ctx->cfg.debugging) {
      fprintf(stderr, "Out of OpenCL memory: releasing entry from the free list...\n");
    }
    cl_mem mem;
    if (free_list_first(&ctx->free_list, &mem) == 0) {
      error = clReleaseMemObject(mem);
      if (error != CL_SUCCESS) {
        return error;
      }
    } else {
      break;
    }
    error = opencl_alloc_actual(ctx, min_size, mem_out);
  }

  return error;
}

static int opencl_free(struct opencl_context *ctx, cl_mem mem, const char *tag) {
  size_t size;
  cl_mem existing_mem;

  // If there is already a block with this tag, then remove it.
  if (free_list_find(&ctx->free_list, -1, &size, &existing_mem) == 0) {
    int error = clReleaseMemObject(existing_mem);
    if (error != CL_SUCCESS) {
      return error;
    }
  }

  int error = clGetMemObjectInfo(mem, CL_MEM_SIZE, sizeof(size_t), &size, NULL);

  if (error == CL_SUCCESS) {
    free_list_insert(&ctx->free_list, size, mem, tag);
  }

  return error;
}

static int opencl_free_all(struct opencl_context *ctx) {
  cl_mem mem;
  free_list_pack(&ctx->free_list);
  while (free_list_first(&ctx->free_list, &mem) == 0) {
    int error = clReleaseMemObject(mem);
    if (error != CL_SUCCESS) {
      return error;
    }
  }

  return CL_SUCCESS;
}

// Free everything that belongs to 'ctx', but do not free 'ctx'
// itself.
static void teardown_opencl(struct opencl_context *ctx) {
  (void)opencl_tally_profiling_records(ctx);
  free(ctx->profiling_records);
  (void)opencl_free_all(ctx);
  (void)clReleaseCommandQueue(ctx->queue);
  (void)clReleaseContext(ctx->ctx);
}

// End of opencl.h.

static const char *opencl_program[] =
                  {"#ifdef cl_clang_storage_class_specifiers\n#pragma OPENCL EXTENSION cl_clang_storage_class_specifiers : enable\n#endif\n#pragma OPENCL EXTENSION cl_khr_byte_addressable_store : enable\n__kernel void dummy_kernel(__global unsigned char *dummy, int n)\n{\n    const int thread_gid = get_global_id(0);\n    \n    if (thread_gid >= n)\n        return;\n}\ntypedef char int8_t;\ntypedef short int16_t;\ntypedef int int32_t;\ntypedef long int64_t;\ntypedef uchar uint8_t;\ntypedef ushort uint16_t;\ntypedef uint uint32_t;\ntypedef ulong uint64_t;\n#ifdef cl_nv_pragma_unroll\nstatic inline void mem_fence_global()\n{\n    asm(\"membar.gl;\");\n}\n#else\nstatic inline void mem_fence_global()\n{\n    mem_fence(CLK_LOCAL_MEM_FENCE | CLK_GLOBAL_MEM_FENCE);\n}\n#endif\nstatic inline void mem_fence_local()\n{\n    mem_fence(CLK_LOCAL_MEM_FENCE);\n}\nstatic inline uint8_t add8(uint8_t x, uint8_t y)\n{\n    return x + y;\n}\nstatic inline uint16_t add16(uint16_t x, uint16_t y)\n{\n    return x + y;\n}\nstatic inline uint32_t add32(uint32_t x, uint32_t y)\n{\n    return x + y;\n}\nstatic inline uint64_t add64(uint64_t x, uint64_t y)\n{\n    return x + y;\n}\nstatic inline uint8_t sub8(uint8_t x, uint8_t y)\n{\n    return x - y;\n}\nstatic inline uint16_t sub16(uint16_t x, uint16_t y)\n{\n    return x - y;\n}\nstatic inline uint32_t sub32(uint32_t x, uint32_t y)\n{\n    return x - y;\n}\nstatic inline uint64_t sub64(uint64_t x, uint64_t y)\n{\n    return x - y;\n}\nstatic inline uint8_t mul8(uint8_t x, uint8_t y)\n{\n    return x * y;\n}\nstatic inline uint16_t mul16(uint16_t x, uint16_t y)\n{\n    return x * y;\n}\nstatic inline uint32_t mul32(uint32_t x, uint32_t y)\n{\n    return x * y;\n}\nstatic inline uint64_t mul64(uint64_t x, uint64_t y)\n{\n    return x * y;\n}\nstatic inline uint8_t udiv8(uint8_t x, uint8_t y)\n{\n    return x / y;\n}\nstatic inline uint16_t udiv16(uint16_t x, uint16_t y)\n{\n    return x / y;\n}\nstatic inline uint32_t udiv32(uint32_t x, uint32_t y)\n{\n    return x / y;\n}\nstatic inline uint64_t udiv64(uint64_t x, uint64_t y)\n{\n    return x / y;\n}\nstatic ",
                   "inline uint8_t udiv_up8(uint8_t x, uint8_t y)\n{\n    return (x + y - 1) / y;\n}\nstatic inline uint16_t udiv_up16(uint16_t x, uint16_t y)\n{\n    return (x + y - 1) / y;\n}\nstatic inline uint32_t udiv_up32(uint32_t x, uint32_t y)\n{\n    return (x + y - 1) / y;\n}\nstatic inline uint64_t udiv_up64(uint64_t x, uint64_t y)\n{\n    return (x + y - 1) / y;\n}\nstatic inline uint8_t umod8(uint8_t x, uint8_t y)\n{\n    return x % y;\n}\nstatic inline uint16_t umod16(uint16_t x, uint16_t y)\n{\n    return x % y;\n}\nstatic inline uint32_t umod32(uint32_t x, uint32_t y)\n{\n    return x % y;\n}\nstatic inline uint64_t umod64(uint64_t x, uint64_t y)\n{\n    return x % y;\n}\nstatic inline uint8_t udiv_safe8(uint8_t x, uint8_t y)\n{\n    return y == 0 ? 0 : x / y;\n}\nstatic inline uint16_t udiv_safe16(uint16_t x, uint16_t y)\n{\n    return y == 0 ? 0 : x / y;\n}\nstatic inline uint32_t udiv_safe32(uint32_t x, uint32_t y)\n{\n    return y == 0 ? 0 : x / y;\n}\nstatic inline uint64_t udiv_safe64(uint64_t x, uint64_t y)\n{\n    return y == 0 ? 0 : x / y;\n}\nstatic inline uint8_t udiv_up_safe8(uint8_t x, uint8_t y)\n{\n    return y == 0 ? 0 : (x + y - 1) / y;\n}\nstatic inline uint16_t udiv_up_safe16(uint16_t x, uint16_t y)\n{\n    return y == 0 ? 0 : (x + y - 1) / y;\n}\nstatic inline uint32_t udiv_up_safe32(uint32_t x, uint32_t y)\n{\n    return y == 0 ? 0 : (x + y - 1) / y;\n}\nstatic inline uint64_t udiv_up_safe64(uint64_t x, uint64_t y)\n{\n    return y == 0 ? 0 : (x + y - 1) / y;\n}\nstatic inline uint8_t umod_safe8(uint8_t x, uint8_t y)\n{\n    return y == 0 ? 0 : x % y;\n}\nstatic inline uint16_t umod_safe16(uint16_t x, uint16_t y)\n{\n    return y == 0 ? 0 : x % y;\n}\nstatic inline uint32_t umod_safe32(uint32_t x, uint32_t y)\n{\n    return y == 0 ? 0 : x % y;\n}\nstatic inline uint64_t umod_safe64(uint64_t x, uint64_t y)\n{\n    return y == 0 ? 0 : x % y;\n}\nstatic inline int8_t sdiv8(int8_t x, int8_t y)\n{\n    int8_t q = x / y;\n    int8_t r = x % y;\n    \n    return q - ((r != 0 && r < 0 != y < 0) ? 1 : 0);\n}\nstatic inline int16_t sdiv16(int16",
                   "_t x, int16_t y)\n{\n    int16_t q = x / y;\n    int16_t r = x % y;\n    \n    return q - ((r != 0 && r < 0 != y < 0) ? 1 : 0);\n}\nstatic inline int32_t sdiv32(int32_t x, int32_t y)\n{\n    int32_t q = x / y;\n    int32_t r = x % y;\n    \n    return q - ((r != 0 && r < 0 != y < 0) ? 1 : 0);\n}\nstatic inline int64_t sdiv64(int64_t x, int64_t y)\n{\n    int64_t q = x / y;\n    int64_t r = x % y;\n    \n    return q - ((r != 0 && r < 0 != y < 0) ? 1 : 0);\n}\nstatic inline int8_t sdiv_up8(int8_t x, int8_t y)\n{\n    return sdiv8(x + y - 1, y);\n}\nstatic inline int16_t sdiv_up16(int16_t x, int16_t y)\n{\n    return sdiv16(x + y - 1, y);\n}\nstatic inline int32_t sdiv_up32(int32_t x, int32_t y)\n{\n    return sdiv32(x + y - 1, y);\n}\nstatic inline int64_t sdiv_up64(int64_t x, int64_t y)\n{\n    return sdiv64(x + y - 1, y);\n}\nstatic inline int8_t smod8(int8_t x, int8_t y)\n{\n    int8_t r = x % y;\n    \n    return r + (r == 0 || (x > 0 && y > 0) || (x < 0 && y < 0) ? 0 : y);\n}\nstatic inline int16_t smod16(int16_t x, int16_t y)\n{\n    int16_t r = x % y;\n    \n    return r + (r == 0 || (x > 0 && y > 0) || (x < 0 && y < 0) ? 0 : y);\n}\nstatic inline int32_t smod32(int32_t x, int32_t y)\n{\n    int32_t r = x % y;\n    \n    return r + (r == 0 || (x > 0 && y > 0) || (x < 0 && y < 0) ? 0 : y);\n}\nstatic inline int64_t smod64(int64_t x, int64_t y)\n{\n    int64_t r = x % y;\n    \n    return r + (r == 0 || (x > 0 && y > 0) || (x < 0 && y < 0) ? 0 : y);\n}\nstatic inline int8_t sdiv_safe8(int8_t x, int8_t y)\n{\n    return y == 0 ? 0 : sdiv8(x, y);\n}\nstatic inline int16_t sdiv_safe16(int16_t x, int16_t y)\n{\n    return y == 0 ? 0 : sdiv16(x, y);\n}\nstatic inline int32_t sdiv_safe32(int32_t x, int32_t y)\n{\n    return y == 0 ? 0 : sdiv32(x, y);\n}\nstatic inline int64_t sdiv_safe64(int64_t x, int64_t y)\n{\n    return y == 0 ? 0 : sdiv64(x, y);\n}\nstatic inline int8_t sdiv_up_safe8(int8_t x, int8_t y)\n{\n    return sdiv_safe8(x + y - 1, y);\n}\nstatic inline int16_t sdiv_up_safe16(int16_t x, int16_t y)\n{\n    return sdiv_safe16(x + y - 1, y",
                   ");\n}\nstatic inline int32_t sdiv_up_safe32(int32_t x, int32_t y)\n{\n    return sdiv_safe32(x + y - 1, y);\n}\nstatic inline int64_t sdiv_up_safe64(int64_t x, int64_t y)\n{\n    return sdiv_safe64(x + y - 1, y);\n}\nstatic inline int8_t smod_safe8(int8_t x, int8_t y)\n{\n    return y == 0 ? 0 : smod8(x, y);\n}\nstatic inline int16_t smod_safe16(int16_t x, int16_t y)\n{\n    return y == 0 ? 0 : smod16(x, y);\n}\nstatic inline int32_t smod_safe32(int32_t x, int32_t y)\n{\n    return y == 0 ? 0 : smod32(x, y);\n}\nstatic inline int64_t smod_safe64(int64_t x, int64_t y)\n{\n    return y == 0 ? 0 : smod64(x, y);\n}\nstatic inline int8_t squot8(int8_t x, int8_t y)\n{\n    return x / y;\n}\nstatic inline int16_t squot16(int16_t x, int16_t y)\n{\n    return x / y;\n}\nstatic inline int32_t squot32(int32_t x, int32_t y)\n{\n    return x / y;\n}\nstatic inline int64_t squot64(int64_t x, int64_t y)\n{\n    return x / y;\n}\nstatic inline int8_t srem8(int8_t x, int8_t y)\n{\n    return x % y;\n}\nstatic inline int16_t srem16(int16_t x, int16_t y)\n{\n    return x % y;\n}\nstatic inline int32_t srem32(int32_t x, int32_t y)\n{\n    return x % y;\n}\nstatic inline int64_t srem64(int64_t x, int64_t y)\n{\n    return x % y;\n}\nstatic inline int8_t squot_safe8(int8_t x, int8_t y)\n{\n    return y == 0 ? 0 : x / y;\n}\nstatic inline int16_t squot_safe16(int16_t x, int16_t y)\n{\n    return y == 0 ? 0 : x / y;\n}\nstatic inline int32_t squot_safe32(int32_t x, int32_t y)\n{\n    return y == 0 ? 0 : x / y;\n}\nstatic inline int64_t squot_safe64(int64_t x, int64_t y)\n{\n    return y == 0 ? 0 : x / y;\n}\nstatic inline int8_t srem_safe8(int8_t x, int8_t y)\n{\n    return y == 0 ? 0 : x % y;\n}\nstatic inline int16_t srem_safe16(int16_t x, int16_t y)\n{\n    return y == 0 ? 0 : x % y;\n}\nstatic inline int32_t srem_safe32(int32_t x, int32_t y)\n{\n    return y == 0 ? 0 : x % y;\n}\nstatic inline int64_t srem_safe64(int64_t x, int64_t y)\n{\n    return y == 0 ? 0 : x % y;\n}\nstatic inline int8_t smin8(int8_t x, int8_t y)\n{\n    return x < y ? x : y;\n}\nstatic inline int16_t smi",
                   "n16(int16_t x, int16_t y)\n{\n    return x < y ? x : y;\n}\nstatic inline int32_t smin32(int32_t x, int32_t y)\n{\n    return x < y ? x : y;\n}\nstatic inline int64_t smin64(int64_t x, int64_t y)\n{\n    return x < y ? x : y;\n}\nstatic inline uint8_t umin8(uint8_t x, uint8_t y)\n{\n    return x < y ? x : y;\n}\nstatic inline uint16_t umin16(uint16_t x, uint16_t y)\n{\n    return x < y ? x : y;\n}\nstatic inline uint32_t umin32(uint32_t x, uint32_t y)\n{\n    return x < y ? x : y;\n}\nstatic inline uint64_t umin64(uint64_t x, uint64_t y)\n{\n    return x < y ? x : y;\n}\nstatic inline int8_t smax8(int8_t x, int8_t y)\n{\n    return x < y ? y : x;\n}\nstatic inline int16_t smax16(int16_t x, int16_t y)\n{\n    return x < y ? y : x;\n}\nstatic inline int32_t smax32(int32_t x, int32_t y)\n{\n    return x < y ? y : x;\n}\nstatic inline int64_t smax64(int64_t x, int64_t y)\n{\n    return x < y ? y : x;\n}\nstatic inline uint8_t umax8(uint8_t x, uint8_t y)\n{\n    return x < y ? y : x;\n}\nstatic inline uint16_t umax16(uint16_t x, uint16_t y)\n{\n    return x < y ? y : x;\n}\nstatic inline uint32_t umax32(uint32_t x, uint32_t y)\n{\n    return x < y ? y : x;\n}\nstatic inline uint64_t umax64(uint64_t x, uint64_t y)\n{\n    return x < y ? y : x;\n}\nstatic inline uint8_t shl8(uint8_t x, uint8_t y)\n{\n    return x << y;\n}\nstatic inline uint16_t shl16(uint16_t x, uint16_t y)\n{\n    return x << y;\n}\nstatic inline uint32_t shl32(uint32_t x, uint32_t y)\n{\n    return x << y;\n}\nstatic inline uint64_t shl64(uint64_t x, uint64_t y)\n{\n    return x << y;\n}\nstatic inline uint8_t lshr8(uint8_t x, uint8_t y)\n{\n    return x >> y;\n}\nstatic inline uint16_t lshr16(uint16_t x, uint16_t y)\n{\n    return x >> y;\n}\nstatic inline uint32_t lshr32(uint32_t x, uint32_t y)\n{\n    return x >> y;\n}\nstatic inline uint64_t lshr64(uint64_t x, uint64_t y)\n{\n    return x >> y;\n}\nstatic inline int8_t ashr8(int8_t x, int8_t y)\n{\n    return x >> y;\n}\nstatic inline int16_t ashr16(int16_t x, int16_t y)\n{\n    return x >> y;\n}\nstatic inline int32_t ashr32(int32_t x, int32_t y)",
                   "\n{\n    return x >> y;\n}\nstatic inline int64_t ashr64(int64_t x, int64_t y)\n{\n    return x >> y;\n}\nstatic inline uint8_t and8(uint8_t x, uint8_t y)\n{\n    return x & y;\n}\nstatic inline uint16_t and16(uint16_t x, uint16_t y)\n{\n    return x & y;\n}\nstatic inline uint32_t and32(uint32_t x, uint32_t y)\n{\n    return x & y;\n}\nstatic inline uint64_t and64(uint64_t x, uint64_t y)\n{\n    return x & y;\n}\nstatic inline uint8_t or8(uint8_t x, uint8_t y)\n{\n    return x | y;\n}\nstatic inline uint16_t or16(uint16_t x, uint16_t y)\n{\n    return x | y;\n}\nstatic inline uint32_t or32(uint32_t x, uint32_t y)\n{\n    return x | y;\n}\nstatic inline uint64_t or64(uint64_t x, uint64_t y)\n{\n    return x | y;\n}\nstatic inline uint8_t xor8(uint8_t x, uint8_t y)\n{\n    return x ^ y;\n}\nstatic inline uint16_t xor16(uint16_t x, uint16_t y)\n{\n    return x ^ y;\n}\nstatic inline uint32_t xor32(uint32_t x, uint32_t y)\n{\n    return x ^ y;\n}\nstatic inline uint64_t xor64(uint64_t x, uint64_t y)\n{\n    return x ^ y;\n}\nstatic inline bool ult8(uint8_t x, uint8_t y)\n{\n    return x < y;\n}\nstatic inline bool ult16(uint16_t x, uint16_t y)\n{\n    return x < y;\n}\nstatic inline bool ult32(uint32_t x, uint32_t y)\n{\n    return x < y;\n}\nstatic inline bool ult64(uint64_t x, uint64_t y)\n{\n    return x < y;\n}\nstatic inline bool ule8(uint8_t x, uint8_t y)\n{\n    return x <= y;\n}\nstatic inline bool ule16(uint16_t x, uint16_t y)\n{\n    return x <= y;\n}\nstatic inline bool ule32(uint32_t x, uint32_t y)\n{\n    return x <= y;\n}\nstatic inline bool ule64(uint64_t x, uint64_t y)\n{\n    return x <= y;\n}\nstatic inline bool slt8(int8_t x, int8_t y)\n{\n    return x < y;\n}\nstatic inline bool slt16(int16_t x, int16_t y)\n{\n    return x < y;\n}\nstatic inline bool slt32(int32_t x, int32_t y)\n{\n    return x < y;\n}\nstatic inline bool slt64(int64_t x, int64_t y)\n{\n    return x < y;\n}\nstatic inline bool sle8(int8_t x, int8_t y)\n{\n    return x <= y;\n}\nstatic inline bool sle16(int16_t x, int16_t y)\n{\n    return x <= y;\n}\nstatic inline bool sle32(int32_t x, int32_",
                   "t y)\n{\n    return x <= y;\n}\nstatic inline bool sle64(int64_t x, int64_t y)\n{\n    return x <= y;\n}\nstatic inline int8_t pow8(int8_t x, int8_t y)\n{\n    int8_t res = 1, rem = y;\n    \n    while (rem != 0) {\n        if (rem & 1)\n            res *= x;\n        rem >>= 1;\n        x *= x;\n    }\n    return res;\n}\nstatic inline int16_t pow16(int16_t x, int16_t y)\n{\n    int16_t res = 1, rem = y;\n    \n    while (rem != 0) {\n        if (rem & 1)\n            res *= x;\n        rem >>= 1;\n        x *= x;\n    }\n    return res;\n}\nstatic inline int32_t pow32(int32_t x, int32_t y)\n{\n    int32_t res = 1, rem = y;\n    \n    while (rem != 0) {\n        if (rem & 1)\n            res *= x;\n        rem >>= 1;\n        x *= x;\n    }\n    return res;\n}\nstatic inline int64_t pow64(int64_t x, int64_t y)\n{\n    int64_t res = 1, rem = y;\n    \n    while (rem != 0) {\n        if (rem & 1)\n            res *= x;\n        rem >>= 1;\n        x *= x;\n    }\n    return res;\n}\nstatic inline bool itob_i8_bool(int8_t x)\n{\n    return x;\n}\nstatic inline bool itob_i16_bool(int16_t x)\n{\n    return x;\n}\nstatic inline bool itob_i32_bool(int32_t x)\n{\n    return x;\n}\nstatic inline bool itob_i64_bool(int64_t x)\n{\n    return x;\n}\nstatic inline int8_t btoi_bool_i8(bool x)\n{\n    return x;\n}\nstatic inline int16_t btoi_bool_i16(bool x)\n{\n    return x;\n}\nstatic inline int32_t btoi_bool_i32(bool x)\n{\n    return x;\n}\nstatic inline int64_t btoi_bool_i64(bool x)\n{\n    return x;\n}\n#define sext_i8_i8(x) ((int8_t) (int8_t) x)\n#define sext_i8_i16(x) ((int16_t) (int8_t) x)\n#define sext_i8_i32(x) ((int32_t) (int8_t) x)\n#define sext_i8_i64(x) ((int64_t) (int8_t) x)\n#define sext_i16_i8(x) ((int8_t) (int16_t) x)\n#define sext_i16_i16(x) ((int16_t) (int16_t) x)\n#define sext_i16_i32(x) ((int32_t) (int16_t) x)\n#define sext_i16_i64(x) ((int64_t) (int16_t) x)\n#define sext_i32_i8(x) ((int8_t) (int32_t) x)\n#define sext_i32_i16(x) ((int16_t) (int32_t) x)\n#define sext_i32_i32(x) ((int32_t) (int32_t) x)\n#define sext_i32_i64(x) ((int64_t) (int32_t) x)\n#defi",
                   "ne sext_i64_i8(x) ((int8_t) (int64_t) x)\n#define sext_i64_i16(x) ((int16_t) (int64_t) x)\n#define sext_i64_i32(x) ((int32_t) (int64_t) x)\n#define sext_i64_i64(x) ((int64_t) (int64_t) x)\n#define zext_i8_i8(x) ((int8_t) (uint8_t) x)\n#define zext_i8_i16(x) ((int16_t) (uint8_t) x)\n#define zext_i8_i32(x) ((int32_t) (uint8_t) x)\n#define zext_i8_i64(x) ((int64_t) (uint8_t) x)\n#define zext_i16_i8(x) ((int8_t) (uint16_t) x)\n#define zext_i16_i16(x) ((int16_t) (uint16_t) x)\n#define zext_i16_i32(x) ((int32_t) (uint16_t) x)\n#define zext_i16_i64(x) ((int64_t) (uint16_t) x)\n#define zext_i32_i8(x) ((int8_t) (uint32_t) x)\n#define zext_i32_i16(x) ((int16_t) (uint32_t) x)\n#define zext_i32_i32(x) ((int32_t) (uint32_t) x)\n#define zext_i32_i64(x) ((int64_t) (uint32_t) x)\n#define zext_i64_i8(x) ((int8_t) (uint64_t) x)\n#define zext_i64_i16(x) ((int16_t) (uint64_t) x)\n#define zext_i64_i32(x) ((int32_t) (uint64_t) x)\n#define zext_i64_i64(x) ((int64_t) (uint64_t) x)\n#if defined(__OPENCL_VERSION__)\nstatic int32_t futrts_popc8(int8_t x)\n{\n    return popcount(x);\n}\nstatic int32_t futrts_popc16(int16_t x)\n{\n    return popcount(x);\n}\nstatic int32_t futrts_popc32(int32_t x)\n{\n    return popcount(x);\n}\nstatic int32_t futrts_popc64(int64_t x)\n{\n    return popcount(x);\n}\n#elif defined(__CUDA_ARCH__)\nstatic int32_t futrts_popc8(int8_t x)\n{\n    return __popc(zext_i8_i32(x));\n}\nstatic int32_t futrts_popc16(int16_t x)\n{\n    return __popc(zext_i16_i32(x));\n}\nstatic int32_t futrts_popc32(int32_t x)\n{\n    return __popc(x);\n}\nstatic int32_t futrts_popc64(int64_t x)\n{\n    return __popcll(x);\n}\n#else\nstatic int32_t futrts_popc8(int8_t x)\n{\n    int c = 0;\n    \n    for (; x; ++c)\n        x &= x - 1;\n    return c;\n}\nstatic int32_t futrts_popc16(int16_t x)\n{\n    int c = 0;\n    \n    for (; x; ++c)\n        x &= x - 1;\n    return c;\n}\nstatic int32_t futrts_popc32(int32_t x)\n{\n    int c = 0;\n    \n    for (; x; ++c)\n        x &= x - 1;\n    return c;\n}\nstatic int32_t futrts_popc64(int64_t x)\n{\n    int c = 0;\n    \n    for ",
                   "(; x; ++c)\n        x &= x - 1;\n    return c;\n}\n#endif\n#if defined(__OPENCL_VERSION__)\nstatic uint8_t futrts_mul_hi8(uint8_t a, uint8_t b)\n{\n    return mul_hi(a, b);\n}\nstatic uint16_t futrts_mul_hi16(uint16_t a, uint16_t b)\n{\n    return mul_hi(a, b);\n}\nstatic uint32_t futrts_mul_hi32(uint32_t a, uint32_t b)\n{\n    return mul_hi(a, b);\n}\nstatic uint64_t futrts_mul_hi64(uint64_t a, uint64_t b)\n{\n    return mul_hi(a, b);\n}\n#elif defined(__CUDA_ARCH__)\nstatic uint8_t futrts_mul_hi8(uint8_t a, uint8_t b)\n{\n    uint16_t aa = a;\n    uint16_t bb = b;\n    \n    return aa * bb >> 8;\n}\nstatic uint16_t futrts_mul_hi16(uint16_t a, uint16_t b)\n{\n    uint32_t aa = a;\n    uint32_t bb = b;\n    \n    return aa * bb >> 16;\n}\nstatic uint32_t futrts_mul_hi32(uint32_t a, uint32_t b)\n{\n    return mulhi(a, b);\n}\nstatic uint64_t futrts_mul_hi64(uint64_t a, uint64_t b)\n{\n    return mul64hi(a, b);\n}\n#else\nstatic uint8_t futrts_mul_hi8(uint8_t a, uint8_t b)\n{\n    uint16_t aa = a;\n    uint16_t bb = b;\n    \n    return aa * bb >> 8;\n}\nstatic uint16_t futrts_mul_hi16(uint16_t a, uint16_t b)\n{\n    uint32_t aa = a;\n    uint32_t bb = b;\n    \n    return aa * bb >> 16;\n}\nstatic uint32_t futrts_mul_hi32(uint32_t a, uint32_t b)\n{\n    uint64_t aa = a;\n    uint64_t bb = b;\n    \n    return aa * bb >> 32;\n}\nstatic uint64_t futrts_mul_hi64(uint64_t a, uint64_t b)\n{\n    __uint128_t aa = a;\n    __uint128_t bb = b;\n    \n    return aa * bb >> 64;\n}\n#endif\n#if defined(__OPENCL_VERSION__)\nstatic uint8_t futrts_mad_hi8(uint8_t a, uint8_t b, uint8_t c)\n{\n    return mad_hi(a, b, c);\n}\nstatic uint16_t futrts_mad_hi16(uint16_t a, uint16_t b, uint16_t c)\n{\n    return mad_hi(a, b, c);\n}\nstatic uint32_t futrts_mad_hi32(uint32_t a, uint32_t b, uint32_t c)\n{\n    return mad_hi(a, b, c);\n}\nstatic uint64_t futrts_mad_hi64(uint64_t a, uint64_t b, uint64_t c)\n{\n    return mad_hi(a, b, c);\n}\n#else\nstatic uint8_t futrts_mad_hi8(uint8_t a, uint8_t b, uint8_t c)\n{\n    return futrts_mul_hi8(a, b) + c;\n}\nstatic uint16_t futrts_mad_hi16(uin",
                   "t16_t a, uint16_t b, uint16_t c)\n{\n    return futrts_mul_hi16(a, b) + c;\n}\nstatic uint32_t futrts_mad_hi32(uint32_t a, uint32_t b, uint32_t c)\n{\n    return futrts_mul_hi32(a, b) + c;\n}\nstatic uint64_t futrts_mad_hi64(uint64_t a, uint64_t b, uint64_t c)\n{\n    return futrts_mul_hi64(a, b) + c;\n}\n#endif\n#if defined(__OPENCL_VERSION__)\nstatic int32_t futrts_clzz8(int8_t x)\n{\n    return clz(x);\n}\nstatic int32_t futrts_clzz16(int16_t x)\n{\n    return clz(x);\n}\nstatic int32_t futrts_clzz32(int32_t x)\n{\n    return clz(x);\n}\nstatic int32_t futrts_clzz64(int64_t x)\n{\n    return clz(x);\n}\n#elif defined(__CUDA_ARCH__)\nstatic int32_t futrts_clzz8(int8_t x)\n{\n    return __clz(zext_i8_i32(x)) - 24;\n}\nstatic int32_t futrts_clzz16(int16_t x)\n{\n    return __clz(zext_i16_i32(x)) - 16;\n}\nstatic int32_t futrts_clzz32(int32_t x)\n{\n    return __clz(x);\n}\nstatic int32_t futrts_clzz64(int64_t x)\n{\n    return __clzll(x);\n}\n#else\nstatic int32_t futrts_clzz8(int8_t x)\n{\n    int n = 0;\n    int bits = sizeof(x) * 8;\n    \n    for (int i = 0; i < bits; i++) {\n        if (x < 0)\n            break;\n        n++;\n        x <<= 1;\n    }\n    return n;\n}\nstatic int32_t futrts_clzz16(int16_t x)\n{\n    int n = 0;\n    int bits = sizeof(x) * 8;\n    \n    for (int i = 0; i < bits; i++) {\n        if (x < 0)\n            break;\n        n++;\n        x <<= 1;\n    }\n    return n;\n}\nstatic int32_t futrts_clzz32(int32_t x)\n{\n    int n = 0;\n    int bits = sizeof(x) * 8;\n    \n    for (int i = 0; i < bits; i++) {\n        if (x < 0)\n            break;\n        n++;\n        x <<= 1;\n    }\n    return n;\n}\nstatic int32_t futrts_clzz64(int64_t x)\n{\n    int n = 0;\n    int bits = sizeof(x) * 8;\n    \n    for (int i = 0; i < bits; i++) {\n        if (x < 0)\n            break;\n        n++;\n        x <<= 1;\n    }\n    return n;\n}\n#endif\n#if defined(__OPENCL_VERSION__)\nstatic int32_t futrts_ctzz8(int8_t x)\n{\n    int i = 0;\n    \n    for (; i < 8 && (x & 1) == 0; i++, x >>= 1)\n        ;\n    return i;\n}\nstatic int32_t futrts_ctzz16(int16_t ",
                   "x)\n{\n    int i = 0;\n    \n    for (; i < 16 && (x & 1) == 0; i++, x >>= 1)\n        ;\n    return i;\n}\nstatic int32_t futrts_ctzz32(int32_t x)\n{\n    int i = 0;\n    \n    for (; i < 32 && (x & 1) == 0; i++, x >>= 1)\n        ;\n    return i;\n}\nstatic int32_t futrts_ctzz64(int64_t x)\n{\n    int i = 0;\n    \n    for (; i < 64 && (x & 1) == 0; i++, x >>= 1)\n        ;\n    return i;\n}\n#elif defined(__CUDA_ARCH__)\nstatic int32_t futrts_ctzz8(int8_t x)\n{\n    int y = __ffs(x);\n    \n    return y == 0 ? 8 : y - 1;\n}\nstatic int32_t futrts_ctzz16(int16_t x)\n{\n    int y = __ffs(x);\n    \n    return y == 0 ? 16 : y - 1;\n}\nstatic int32_t futrts_ctzz32(int32_t x)\n{\n    int y = __ffs(x);\n    \n    return y == 0 ? 32 : y - 1;\n}\nstatic int32_t futrts_ctzz64(int64_t x)\n{\n    int y = __ffsll(x);\n    \n    return y == 0 ? 64 : y - 1;\n}\n#else\nstatic int32_t futrts_ctzz8(int8_t x)\n{\n    return x == 0 ? 8 : __builtin_ctz((uint32_t) x);\n}\nstatic int32_t futrts_ctzz16(int16_t x)\n{\n    return x == 0 ? 16 : __builtin_ctz((uint32_t) x);\n}\nstatic int32_t futrts_ctzz32(int32_t x)\n{\n    return x == 0 ? 32 : __builtin_ctz(x);\n}\nstatic int32_t futrts_ctzz64(int64_t x)\n{\n    return x == 0 ? 64 : __builtin_ctzl(x);\n}\n#endif\nstatic inline float fdiv32(float x, float y)\n{\n    return x / y;\n}\nstatic inline float fadd32(float x, float y)\n{\n    return x + y;\n}\nstatic inline float fsub32(float x, float y)\n{\n    return x - y;\n}\nstatic inline float fmul32(float x, float y)\n{\n    return x * y;\n}\nstatic inline float fmin32(float x, float y)\n{\n    return fmin(x, y);\n}\nstatic inline float fmax32(float x, float y)\n{\n    return fmax(x, y);\n}\nstatic inline float fpow32(float x, float y)\n{\n    return pow(x, y);\n}\nstatic inline bool cmplt32(float x, float y)\n{\n    return x < y;\n}\nstatic inline bool cmple32(float x, float y)\n{\n    return x <= y;\n}\nstatic inline float sitofp_i8_f32(int8_t x)\n{\n    return (float) x;\n}\nstatic inline float sitofp_i16_f32(int16_t x)\n{\n    return (float) x;\n}\nstatic inline float sitofp_i32_f32(int32_t x)",
                   "\n{\n    return (float) x;\n}\nstatic inline float sitofp_i64_f32(int64_t x)\n{\n    return (float) x;\n}\nstatic inline float uitofp_i8_f32(uint8_t x)\n{\n    return (float) x;\n}\nstatic inline float uitofp_i16_f32(uint16_t x)\n{\n    return (float) x;\n}\nstatic inline float uitofp_i32_f32(uint32_t x)\n{\n    return (float) x;\n}\nstatic inline float uitofp_i64_f32(uint64_t x)\n{\n    return (float) x;\n}\nstatic inline int8_t fptosi_f32_i8(float x)\n{\n    return (int8_t) x;\n}\nstatic inline int16_t fptosi_f32_i16(float x)\n{\n    return (int16_t) x;\n}\nstatic inline int32_t fptosi_f32_i32(float x)\n{\n    return (int32_t) x;\n}\nstatic inline int64_t fptosi_f32_i64(float x)\n{\n    return (int64_t) x;\n}\nstatic inline uint8_t fptoui_f32_i8(float x)\n{\n    return (uint8_t) x;\n}\nstatic inline uint16_t fptoui_f32_i16(float x)\n{\n    return (uint16_t) x;\n}\nstatic inline uint32_t fptoui_f32_i32(float x)\n{\n    return (uint32_t) x;\n}\nstatic inline uint64_t fptoui_f32_i64(float x)\n{\n    return (uint64_t) x;\n}\nstatic inline float futrts_log32(float x)\n{\n    return log(x);\n}\nstatic inline float futrts_log2_32(float x)\n{\n    return log2(x);\n}\nstatic inline float futrts_log10_32(float x)\n{\n    return log10(x);\n}\nstatic inline float futrts_sqrt32(float x)\n{\n    return sqrt(x);\n}\nstatic inline float futrts_exp32(float x)\n{\n    return exp(x);\n}\nstatic inline float futrts_cos32(float x)\n{\n    return cos(x);\n}\nstatic inline float futrts_sin32(float x)\n{\n    return sin(x);\n}\nstatic inline float futrts_tan32(float x)\n{\n    return tan(x);\n}\nstatic inline float futrts_acos32(float x)\n{\n    return acos(x);\n}\nstatic inline float futrts_asin32(float x)\n{\n    return asin(x);\n}\nstatic inline float futrts_atan32(float x)\n{\n    return atan(x);\n}\nstatic inline float futrts_cosh32(float x)\n{\n    return cosh(x);\n}\nstatic inline float futrts_sinh32(float x)\n{\n    return sinh(x);\n}\nstatic inline float futrts_tanh32(float x)\n{\n    return tanh(x);\n}\nstatic inline float futrts_acosh32(float x)\n{\n    return acosh(x);\n}\nstatic inline fl",
                   "oat futrts_asinh32(float x)\n{\n    return asinh(x);\n}\nstatic inline float futrts_atanh32(float x)\n{\n    return atanh(x);\n}\nstatic inline float futrts_atan2_32(float x, float y)\n{\n    return atan2(x, y);\n}\nstatic inline float futrts_gamma32(float x)\n{\n    return tgamma(x);\n}\nstatic inline float futrts_lgamma32(float x)\n{\n    return lgamma(x);\n}\nstatic inline bool futrts_isnan32(float x)\n{\n    return isnan(x);\n}\nstatic inline bool futrts_isinf32(float x)\n{\n    return isinf(x);\n}\nstatic inline int32_t futrts_to_bits32(float x)\n{\n    union {\n        float f;\n        int32_t t;\n    } p;\n    \n    p.f = x;\n    return p.t;\n}\nstatic inline float futrts_from_bits32(int32_t x)\n{\n    union {\n        int32_t f;\n        float t;\n    } p;\n    \n    p.f = x;\n    return p.t;\n}\n#ifdef __OPENCL_VERSION__\nstatic inline float fmod32(float x, float y)\n{\n    return fmod(x, y);\n}\nstatic inline float futrts_round32(float x)\n{\n    return rint(x);\n}\nstatic inline float futrts_floor32(float x)\n{\n    return floor(x);\n}\nstatic inline float futrts_ceil32(float x)\n{\n    return ceil(x);\n}\nstatic inline float futrts_lerp32(float v0, float v1, float t)\n{\n    return mix(v0, v1, t);\n}\nstatic inline float futrts_mad32(float a, float b, float c)\n{\n    return mad(a, b, c);\n}\nstatic inline float futrts_fma32(float a, float b, float c)\n{\n    return fma(a, b, c);\n}\n#else\nstatic inline float fmod32(float x, float y)\n{\n    return fmodf(x, y);\n}\nstatic inline float futrts_round32(float x)\n{\n    return rintf(x);\n}\nstatic inline float futrts_floor32(float x)\n{\n    return floorf(x);\n}\nstatic inline float futrts_ceil32(float x)\n{\n    return ceilf(x);\n}\nstatic inline float futrts_lerp32(float v0, float v1, float t)\n{\n    return v0 + (v1 - v0) * t;\n}\nstatic inline float futrts_mad32(float a, float b, float c)\n{\n    return a * b + c;\n}\nstatic inline float futrts_fma32(float a, float b, float c)\n{\n    return fmaf(a, b, c);\n}\n#endif\n// Start of atomics.h\n\ninline int32_t atomic_add_i32_global(volatile __global int32_t *p, ",
                   "int32_t x) {\n#ifdef FUTHARK_CUDA\n  return atomicAdd((int32_t*)p, x);\n#else\n  return atomic_add(p, x);\n#endif\n}\n\ninline int32_t atomic_add_i32_local(volatile __local int32_t *p, int32_t x) {\n#ifdef FUTHARK_CUDA\n  return atomicAdd((int32_t*)p, x);\n#else\n  return atomic_add(p, x);\n#endif\n}\n\ninline float atomic_fadd_f32_global(volatile __global float *p, float x) {\n#ifdef FUTHARK_CUDA\n  return atomicAdd((float*)p, x);\n#else\n  union { int32_t i; float f; } old;\n  union { int32_t i; float f; } assumed;\n  old.f = *p;\n  do {\n    assumed.f = old.f;\n    old.f = old.f + x;\n    old.i = atomic_cmpxchg((volatile __global int32_t*)p, assumed.i, old.i);\n  } while (assumed.i != old.i);\n  return old.f;\n#endif\n}\n\ninline float atomic_fadd_f32_local(volatile __local float *p, float x) {\n#ifdef FUTHARK_CUDA\n  return atomicAdd((float*)p, x);\n#else\n  union { int32_t i; float f; } old;\n  union { int32_t i; float f; } assumed;\n  old.f = *p;\n  do {\n    assumed.f = old.f;\n    old.f = old.f + x;\n    old.i = atomic_cmpxchg((volatile __local int32_t*)p, assumed.i, old.i);\n  } while (assumed.i != old.i);\n  return old.f;\n#endif\n}\n\ninline int32_t atomic_smax_i32_global(volatile __global int32_t *p, int32_t x) {\n#ifdef FUTHARK_CUDA\n  return atomicMax((int32_t*)p, x);\n#else\n  return atomic_max(p, x);\n#endif\n}\n\ninline int32_t atomic_smax_i32_local(volatile __local int32_t *p, int32_t x) {\n#ifdef FUTHARK_CUDA\n  return atomicMax((int32_t*)p, x);\n#else\n  return atomic_max(p, x);\n#endif\n}\n\ninline int32_t atomic_smin_i32_global(volatile __global int32_t *p, int32_t x) {\n#ifdef FUTHARK_CUDA\n  return atomicMin((int32_t*)p, x);\n#else\n  return atomic_min(p, x);\n#endif\n}\n\ninline int32_t atomic_smin_i32_local(volatile __local int32_t *p, int32_t x) {\n#ifdef FUTHARK_CUDA\n  return atomicMin((int32_t*)p, x);\n#else\n  return atomic_min(p, x);\n#endif\n}\n\ninline uint32_t atomic_umax_i32_global(volatile __global uint32_t *p, uint32_t x) {\n#ifdef FUTHARK_CUDA\n  return atomicMax((uint32_t*)p, x);\n#else\n  return atomic_max(p",
                   ", x);\n#endif\n}\n\ninline uint32_t atomic_umax_i32_local(volatile __local uint32_t *p, uint32_t x) {\n#ifdef FUTHARK_CUDA\n  return atomicMax((uint32_t*)p, x);\n#else\n  return atomic_max(p, x);\n#endif\n}\n\ninline uint32_t atomic_umin_i32_global(volatile __global uint32_t *p, uint32_t x) {\n#ifdef FUTHARK_CUDA\n  return atomicMin((uint32_t*)p, x);\n#else\n  return atomic_min(p, x);\n#endif\n}\n\ninline uint32_t atomic_umin_i32_local(volatile __local uint32_t *p, uint32_t x) {\n#ifdef FUTHARK_CUDA\n  return atomicMin((uint32_t*)p, x);\n#else\n  return atomic_min(p, x);\n#endif\n}\n\ninline int32_t atomic_and_i32_global(volatile __global int32_t *p, int32_t x) {\n#ifdef FUTHARK_CUDA\n  return atomicAnd((int32_t*)p, x);\n#else\n  return atomic_and(p, x);\n#endif\n}\n\ninline int32_t atomic_and_i32_local(volatile __local int32_t *p, int32_t x) {\n#ifdef FUTHARK_CUDA\n  return atomicAnd((int32_t*)p, x);\n#else\n  return atomic_and(p, x);\n#endif\n}\n\ninline int32_t atomic_or_i32_global(volatile __global int32_t *p, int32_t x) {\n#ifdef FUTHARK_CUDA\n  return atomicOr((int32_t*)p, x);\n#else\n  return atomic_or(p, x);\n#endif\n}\n\ninline int32_t atomic_or_i32_local(volatile __local int32_t *p, int32_t x) {\n#ifdef FUTHARK_CUDA\n  return atomicOr((int32_t*)p, x);\n#else\n  return atomic_or(p, x);\n#endif\n}\n\ninline int32_t atomic_xor_i32_global(volatile __global int32_t *p, int32_t x) {\n#ifdef FUTHARK_CUDA\n  return atomicXor((int32_t*)p, x);\n#else\n  return atomic_xor(p, x);\n#endif\n}\n\ninline int32_t atomic_xor_i32_local(volatile __local int32_t *p, int32_t x) {\n#ifdef FUTHARK_CUDA\n  return atomicXor((int32_t*)p, x);\n#else\n  return atomic_xor(p, x);\n#endif\n}\n\ninline int32_t atomic_xchg_i32_global(volatile __global int32_t *p, int32_t x) {\n#ifdef FUTHARK_CUDA\n  return atomicExch((int32_t*)p, x);\n#else\n  return atomic_xor(p, x);\n#endif\n}\n\ninline int32_t atomic_xchg_i32_local(volatile __local int32_t *p, int32_t x) {\n#ifdef FUTHARK_CUDA\n  return atomicExch((int32_t*)p, x);\n#else\n  return atomic_xor(p, x);\n#endif\n}\n\ninline int32_t",
                   " atomic_cmpxchg_i32_global(volatile __global int32_t *p,\n                                         int32_t cmp, int32_t val) {\n#ifdef FUTHARK_CUDA\n  return atomicCAS((int32_t*)p, cmp, val);\n#else\n  return atomic_cmpxchg(p, cmp, val);\n#endif\n}\n\ninline int32_t atomic_cmpxchg_i32_local(volatile __local int32_t *p,\n                                         int32_t cmp, int32_t val) {\n#ifdef FUTHARK_CUDA\n  return atomicCAS((int32_t*)p, cmp, val);\n#else\n  return atomic_cmpxchg(p, cmp, val);\n#endif\n}\n\n// End of atomics.h\n\n\n\n\n__kernel void gpu_map_transpose_f32(__local volatile\n                                    int64_t *block_9_backing_aligned_0,\n                                    int32_t destoffset_1, int32_t srcoffset_3,\n                                    int32_t num_arrays_4, int32_t x_elems_5,\n                                    int32_t y_elems_6, int32_t mulx_7,\n                                    int32_t muly_8, __global\n                                    unsigned char *destmem_0, __global\n                                    unsigned char *srcmem_2)\n{\n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    __local volatile char *restrict block_9_backing_0 = (__local volatile\n                                                         char *) block_9_backing_aligned_0;\n    __local char *block_9;\n    \n    block_9 = (__local char *) block_9_backing_0;\n    \n    int32_t get_global_id_0_37;\n    \n    get_global_id_0_37 = get_global_id(0);\n    \n    int32_t get_local_id_0_38;\n    \n    get_local_id_0_38 = get_local_id(0);\n    \n    int32_t get_local_id_1_39;\n    \n    get_local_id_1_39 = get_local_id(1);\n    \n    int32_t get_group_id_0_40;\n    \n    get_group_id_0_40 = get_group_id(0);\n    \n    int32_t get_group_id_1_41;\n    \n    get_group_id_1_41 = get_group_id(1);\n    \n    int32_t get_group_id_2_42;\n    \n    get_group_id_2_42 = get_group_id(2);\n    \n    int32_t our_array_offset_30 = get_group_id_2_42 * x_elems_5 * y_elems_6;\n    int32_t odat",
                   "a_offset_33 = squot32(destoffset_1, 4) + our_array_offset_30;\n    int32_t idata_offset_34 = squot32(srcoffset_3, 4) + our_array_offset_30;\n    int32_t x_index_31 = get_global_id_0_37;\n    int32_t y_index_32 = get_group_id_1_41 * 32 + get_local_id_1_39;\n    \n    if (slt32(x_index_31, x_elems_5)) {\n        for (int32_t j_43 = 0; j_43 < 4; j_43++) {\n            int32_t index_in_35 = (y_index_32 + j_43 * 8) * x_elems_5 +\n                    x_index_31;\n            \n            if (slt32(y_index_32 + j_43 * 8, y_elems_6)) {\n                ((__local float *) block_9)[sext_i32_i64((get_local_id_1_39 +\n                                                          j_43 * 8) * 33 +\n                                            get_local_id_0_38)] = ((__global\n                                                                    float *) srcmem_2)[sext_i32_i64(idata_offset_34 +\n                                                                                       index_in_35)];\n            }\n        }\n    }\n    barrier(CLK_LOCAL_MEM_FENCE);\n    x_index_31 = get_group_id_1_41 * 32 + get_local_id_0_38;\n    y_index_32 = get_group_id_0_40 * 32 + get_local_id_1_39;\n    if (slt32(x_index_31, y_elems_6)) {\n        for (int32_t j_43 = 0; j_43 < 4; j_43++) {\n            int32_t index_out_36 = (y_index_32 + j_43 * 8) * y_elems_6 +\n                    x_index_31;\n            \n            if (slt32(y_index_32 + j_43 * 8, x_elems_5)) {\n                ((__global float *) destmem_0)[sext_i32_i64(odata_offset_33 +\n                                               index_out_36)] = ((__local\n                                                                  float *) block_9)[sext_i32_i64(get_local_id_0_38 *\n                                                                                    33 +\n                                                                                    get_local_id_1_39 +\n                                                                                    j_43 *\n                  ",
                   "                                                                  8)];\n            }\n        }\n    }\n    \n  error_0:\n    return;\n}\n__kernel void gpu_map_transpose_f32_low_height(__local volatile\n                                               int64_t *block_9_backing_aligned_0,\n                                               int32_t destoffset_1,\n                                               int32_t srcoffset_3,\n                                               int32_t num_arrays_4,\n                                               int32_t x_elems_5,\n                                               int32_t y_elems_6,\n                                               int32_t mulx_7, int32_t muly_8,\n                                               __global\n                                               unsigned char *destmem_0,\n                                               __global unsigned char *srcmem_2)\n{\n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    __local volatile char *restrict block_9_backing_0 = (__local volatile\n                                                         char *) block_9_backing_aligned_0;\n    __local char *block_9;\n    \n    block_9 = (__local char *) block_9_backing_0;\n    \n    int32_t get_global_id_0_37;\n    \n    get_global_id_0_37 = get_global_id(0);\n    \n    int32_t get_local_id_0_38;\n    \n    get_local_id_0_38 = get_local_id(0);\n    \n    int32_t get_local_id_1_39;\n    \n    get_local_id_1_39 = get_local_id(1);\n    \n    int32_t get_group_id_0_40;\n    \n    get_group_id_0_40 = get_group_id(0);\n    \n    int32_t get_group_id_1_41;\n    \n    get_group_id_1_41 = get_group_id(1);\n    \n    int32_t get_group_id_2_42;\n    \n    get_group_id_2_42 = get_group_id(2);\n    \n    int32_t our_array_offset_30 = get_group_id_2_42 * x_elems_5 * y_elems_6;\n    int32_t odata_offset_33 = squot32(destoffset_1, 4) + our_array_offset_30;\n    int32_t idata_offset_34 = squot32(srcoffset_3, 4) + our_array_offset_30;\n    int32_t x_index_31 ",
                   "= get_group_id_0_40 * 16 * mulx_7 + get_local_id_0_38 +\n            srem32(get_local_id_1_39, mulx_7) * 16;\n    int32_t y_index_32 = get_group_id_1_41 * 16 + squot32(get_local_id_1_39,\n                                                          mulx_7);\n    int32_t index_in_35 = y_index_32 * x_elems_5 + x_index_31;\n    \n    if (slt32(x_index_31, x_elems_5) && slt32(y_index_32, y_elems_6)) {\n        ((__local float *) block_9)[sext_i32_i64(get_local_id_1_39 * 17 +\n                                    get_local_id_0_38)] = ((__global\n                                                            float *) srcmem_2)[sext_i32_i64(idata_offset_34 +\n                                                                               index_in_35)];\n    }\n    barrier(CLK_LOCAL_MEM_FENCE);\n    x_index_31 = get_group_id_1_41 * 16 + squot32(get_local_id_0_38, mulx_7);\n    y_index_32 = get_group_id_0_40 * 16 * mulx_7 + get_local_id_1_39 +\n        srem32(get_local_id_0_38, mulx_7) * 16;\n    \n    int32_t index_out_36 = y_index_32 * y_elems_6 + x_index_31;\n    \n    if (slt32(x_index_31, y_elems_6) && slt32(y_index_32, x_elems_5)) {\n        ((__global float *) destmem_0)[sext_i32_i64(odata_offset_33 +\n                                       index_out_36)] = ((__local\n                                                          float *) block_9)[sext_i32_i64(get_local_id_0_38 *\n                                                                            17 +\n                                                                            get_local_id_1_39)];\n    }\n    \n  error_0:\n    return;\n}\n__kernel void gpu_map_transpose_f32_low_width(__local volatile\n                                              int64_t *block_9_backing_aligned_0,\n                                              int32_t destoffset_1,\n                                              int32_t srcoffset_3,\n                                              int32_t num_arrays_4,\n                                              int32_t x_elems_5,\n      ",
                   "                                        int32_t y_elems_6, int32_t mulx_7,\n                                              int32_t muly_8, __global\n                                              unsigned char *destmem_0, __global\n                                              unsigned char *srcmem_2)\n{\n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    __local volatile char *restrict block_9_backing_0 = (__local volatile\n                                                         char *) block_9_backing_aligned_0;\n    __local char *block_9;\n    \n    block_9 = (__local char *) block_9_backing_0;\n    \n    int32_t get_global_id_0_37;\n    \n    get_global_id_0_37 = get_global_id(0);\n    \n    int32_t get_local_id_0_38;\n    \n    get_local_id_0_38 = get_local_id(0);\n    \n    int32_t get_local_id_1_39;\n    \n    get_local_id_1_39 = get_local_id(1);\n    \n    int32_t get_group_id_0_40;\n    \n    get_group_id_0_40 = get_group_id(0);\n    \n    int32_t get_group_id_1_41;\n    \n    get_group_id_1_41 = get_group_id(1);\n    \n    int32_t get_group_id_2_42;\n    \n    get_group_id_2_42 = get_group_id(2);\n    \n    int32_t our_array_offset_30 = get_group_id_2_42 * x_elems_5 * y_elems_6;\n    int32_t odata_offset_33 = squot32(destoffset_1, 4) + our_array_offset_30;\n    int32_t idata_offset_34 = squot32(srcoffset_3, 4) + our_array_offset_30;\n    int32_t x_index_31 = get_group_id_0_40 * 16 + squot32(get_local_id_0_38,\n                                                          muly_8);\n    int32_t y_index_32 = get_group_id_1_41 * 16 * muly_8 + get_local_id_1_39 +\n            srem32(get_local_id_0_38, muly_8) * 16;\n    int32_t index_in_35 = y_index_32 * x_elems_5 + x_index_31;\n    \n    if (slt32(x_index_31, x_elems_5) && slt32(y_index_32, y_elems_6)) {\n        ((__local float *) block_9)[sext_i32_i64(get_local_id_1_39 * 17 +\n                                    get_local_id_0_38)] = ((__global\n                                                            float *) src",
                   "mem_2)[sext_i32_i64(idata_offset_34 +\n                                                                               index_in_35)];\n    }\n    barrier(CLK_LOCAL_MEM_FENCE);\n    x_index_31 = get_group_id_1_41 * 16 * muly_8 + get_local_id_0_38 +\n        srem32(get_local_id_1_39, muly_8) * 16;\n    y_index_32 = get_group_id_0_40 * 16 + squot32(get_local_id_1_39, muly_8);\n    \n    int32_t index_out_36 = y_index_32 * y_elems_6 + x_index_31;\n    \n    if (slt32(x_index_31, y_elems_6) && slt32(y_index_32, x_elems_5)) {\n        ((__global float *) destmem_0)[sext_i32_i64(odata_offset_33 +\n                                       index_out_36)] = ((__local\n                                                          float *) block_9)[sext_i32_i64(get_local_id_0_38 *\n                                                                            17 +\n                                                                            get_local_id_1_39)];\n    }\n    \n  error_0:\n    return;\n}\n__kernel void gpu_map_transpose_f32_small(__local volatile\n                                          int64_t *block_9_backing_aligned_0,\n                                          int32_t destoffset_1,\n                                          int32_t srcoffset_3,\n                                          int32_t num_arrays_4,\n                                          int32_t x_elems_5, int32_t y_elems_6,\n                                          int32_t mulx_7, int32_t muly_8,\n                                          __global unsigned char *destmem_0,\n                                          __global unsigned char *srcmem_2)\n{\n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    __local volatile char *restrict block_9_backing_0 = (__local volatile\n                                                         char *) block_9_backing_aligned_0;\n    __local char *block_9;\n    \n    block_9 = (__local char *) block_9_backing_0;\n    \n    int32_t get_global_id_0_37;\n    \n    get_g",
                   "lobal_id_0_37 = get_global_id(0);\n    \n    int32_t get_local_id_0_38;\n    \n    get_local_id_0_38 = get_local_id(0);\n    \n    int32_t get_local_id_1_39;\n    \n    get_local_id_1_39 = get_local_id(1);\n    \n    int32_t get_group_id_0_40;\n    \n    get_group_id_0_40 = get_group_id(0);\n    \n    int32_t get_group_id_1_41;\n    \n    get_group_id_1_41 = get_group_id(1);\n    \n    int32_t get_group_id_2_42;\n    \n    get_group_id_2_42 = get_group_id(2);\n    \n    int32_t our_array_offset_30 = squot32(get_global_id_0_37, y_elems_6 *\n                                          x_elems_5) * (y_elems_6 * x_elems_5);\n    int32_t x_index_31 = squot32(srem32(get_global_id_0_37, y_elems_6 *\n                                        x_elems_5), y_elems_6);\n    int32_t y_index_32 = srem32(get_global_id_0_37, y_elems_6);\n    int32_t odata_offset_33 = squot32(destoffset_1, 4) + our_array_offset_30;\n    int32_t idata_offset_34 = squot32(srcoffset_3, 4) + our_array_offset_30;\n    int32_t index_in_35 = y_index_32 * x_elems_5 + x_index_31;\n    int32_t index_out_36 = x_index_31 * y_elems_6 + y_index_32;\n    \n    if (slt32(get_global_id_0_37, x_elems_5 * y_elems_6 * num_arrays_4)) {\n        ((__global float *) destmem_0)[sext_i32_i64(odata_offset_33 +\n                                       index_out_36)] = ((__global\n                                                          float *) srcmem_2)[sext_i32_i64(idata_offset_34 +\n                                                                             index_in_35)];\n    }\n    \n  error_0:\n    return;\n}\n__kernel void mainzisegmap_18861(__global int *global_failure,\n                                 int failure_is_an_option, __global\n                                 int64_t *global_failure_args, int64_t n_18078,\n                                 float a_18086, float r0_18089, float x_18106,\n                                 float x_18108, float y_18110, float y_18111,\n                                 __global unsigned char *swap_term_mem_23220,\n                ",
                   "                 __global unsigned char *payments_mem_23221,\n                                 __global unsigned char *mem_23234, __global\n                                 unsigned char *mem_23248,\n                                 int64_t num_threads_23340)\n{\n    #define segmap_group_sizze_18939 (mainzisegmap_group_sizze_18863)\n    \n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    \n    if (*global_failure >= 0)\n        return;\n    \n    int32_t global_tid_23553;\n    int32_t local_tid_23554;\n    int64_t group_sizze_23557;\n    int32_t wave_sizze_23556;\n    int32_t group_tid_23555;\n    \n    global_tid_23553 = get_global_id(0);\n    local_tid_23554 = get_local_id(0);\n    group_sizze_23557 = get_local_size(0);\n    wave_sizze_23556 = LOCKSTEP_WIDTH;\n    group_tid_23555 = get_group_id(0);\n    \n    int32_t phys_tid_18861;\n    \n    phys_tid_18861 = global_tid_23553;\n    \n    int64_t gtid_18860;\n    \n    gtid_18860 = sext_i32_i64(group_tid_23555) * segmap_group_sizze_18939 +\n        sext_i32_i64(local_tid_23554);\n    if (slt64(gtid_18860, n_18078)) {\n        float res_18950 = ((__global float *) swap_term_mem_23220)[gtid_18860];\n        int64_t res_18951 = ((__global\n                              int64_t *) payments_mem_23221)[gtid_18860];\n        int64_t range_end_18953 = sub64(res_18951, 1);\n        bool bounds_invalid_upwards_18954 = slt64(range_end_18953, 0);\n        bool valid_18955 = !bounds_invalid_upwards_18954;\n        bool range_valid_c_18956;\n        \n        if (!valid_18955) {\n            {\n                if (atomic_cmpxchg_i32_global(global_failure, -1, 0) == -1) {\n                    global_failure_args[0] = 0;\n                    global_failure_args[1] = 1;\n                    global_failure_args[2] = range_end_18953;\n                    ;\n                }\n                return;\n            }\n        }\n        for (int64_t i_23182 = 0; i_23182 < res_18951; i_23182++) {\n            float res_18960 = sitofp_i64_f32(i_",
                   "23182);\n            float res_18961 = res_18950 * res_18960;\n            \n            ((__global float *) mem_23234)[phys_tid_18861 + i_23182 *\n                                           num_threads_23340] = res_18961;\n        }\n        \n        bool y_18962 = slt64(0, res_18951);\n        bool index_certs_18963;\n        \n        if (!y_18962) {\n            {\n                if (atomic_cmpxchg_i32_global(global_failure, -1, 1) == -1) {\n                    global_failure_args[0] = 0;\n                    global_failure_args[1] = res_18951;\n                    ;\n                }\n                return;\n            }\n        }\n        \n        float binop_y_18964 = sitofp_i64_f32(range_end_18953);\n        float index_primexp_18965 = res_18950 * binop_y_18964;\n        float negate_arg_18966 = a_18086 * index_primexp_18965;\n        float exp_arg_18967 = 0.0F - negate_arg_18966;\n        float res_18968 = fpow32(2.7182817F, exp_arg_18967);\n        float x_18969 = 1.0F - res_18968;\n        float B_18970 = x_18969 / a_18086;\n        float x_18971 = B_18970 - index_primexp_18965;\n        float x_18972 = y_18110 * x_18971;\n        float A1_18973 = x_18972 / x_18106;\n        float y_18974 = fpow32(B_18970, 2.0F);\n        float x_18975 = x_18108 * y_18974;\n        float A2_18976 = x_18975 / y_18111;\n        float exp_arg_18977 = A1_18973 - A2_18976;\n        float res_18978 = fpow32(2.7182817F, exp_arg_18977);\n        float negate_arg_18979 = r0_18089 * B_18970;\n        float exp_arg_18980 = 0.0F - negate_arg_18979;\n        float res_18981 = fpow32(2.7182817F, exp_arg_18980);\n        float res_18982 = res_18978 * res_18981;\n        bool empty_slice_18983 = range_end_18953 == 0;\n        bool zzero_leq_i_p_m_t_s_18984 = sle64(0, range_end_18953);\n        bool i_p_m_t_s_leq_w_18985 = slt64(range_end_18953, res_18951);\n        bool i_lte_j_18986 = sle64(1, res_18951);\n        bool y_18987 = zzero_leq_i_p_m_t_s_18984 && i_p_m_t_s_leq_w_18985;\n        bool y_18988 = i_lte_j_18986 && y_1",
                   "8987;\n        bool ok_or_empty_18989 = empty_slice_18983 || y_18988;\n        bool index_certs_18990;\n        \n        if (!ok_or_empty_18989) {\n            {\n                if (atomic_cmpxchg_i32_global(global_failure, -1, 2) == -1) {\n                    global_failure_args[0] = 1;\n                    global_failure_args[1] = res_18951;\n                    ;\n                }\n                return;\n            }\n        }\n        \n        float res_18992;\n        float redout_23184 = 0.0F;\n        \n        for (int64_t i_23185 = 0; i_23185 < range_end_18953; i_23185++) {\n            int64_t slice_23206 = 1 + i_23185;\n            float x_18996 = ((__global float *) mem_23234)[phys_tid_18861 +\n                                                           slice_23206 *\n                                                           num_threads_23340];\n            float negate_arg_18997 = a_18086 * x_18996;\n            float exp_arg_18998 = 0.0F - negate_arg_18997;\n            float res_18999 = fpow32(2.7182817F, exp_arg_18998);\n            float x_19000 = 1.0F - res_18999;\n            float B_19001 = x_19000 / a_18086;\n            float x_19002 = B_19001 - x_18996;\n            float x_19003 = y_18110 * x_19002;\n            float A1_19004 = x_19003 / x_18106;\n            float y_19005 = fpow32(B_19001, 2.0F);\n            float x_19006 = x_18108 * y_19005;\n            float A2_19007 = x_19006 / y_18111;\n            float exp_arg_19008 = A1_19004 - A2_19007;\n            float res_19009 = fpow32(2.7182817F, exp_arg_19008);\n            float negate_arg_19010 = r0_18089 * B_19001;\n            float exp_arg_19011 = 0.0F - negate_arg_19010;\n            float res_19012 = fpow32(2.7182817F, exp_arg_19011);\n            float res_19013 = res_19009 * res_19012;\n            float res_18995 = res_19013 + redout_23184;\n            float redout_tmp_23559 = res_18995;\n            \n            redout_23184 = redout_tmp_23559;\n        }\n        res_18992 = redout_23184;\n        \n        float x",
                   "_19014 = 1.0F - res_18982;\n        float y_19015 = res_18950 * res_18992;\n        float res_19016 = x_19014 / y_19015;\n        \n        ((__global float *) mem_23248)[gtid_18860] = res_19016;\n    }\n    \n  error_0:\n    return;\n    #undef segmap_group_sizze_18939\n}\n__kernel void mainzisegmap_19037(__global int *global_failure,\n                                 int failure_is_an_option, __global\n                                 int64_t *global_failure_args, int64_t n_18078,\n                                 float a_18086, float r0_18089, float x_18106,\n                                 float x_18108, float y_18110, float y_18111,\n                                 __global unsigned char *swap_term_mem_23220,\n                                 __global unsigned char *payments_mem_23221,\n                                 __global unsigned char *mem_23257, __global\n                                 unsigned char *mem_23271,\n                                 int64_t num_threads_23372)\n{\n    #define segmap_group_sizze_19115 (mainzisegmap_group_sizze_19039)\n    \n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    \n    if (*global_failure >= 0)\n        return;\n    \n    int32_t global_tid_23590;\n    int32_t local_tid_23591;\n    int64_t group_sizze_23594;\n    int32_t wave_sizze_23593;\n    int32_t group_tid_23592;\n    \n    global_tid_23590 = get_global_id(0);\n    local_tid_23591 = get_local_id(0);\n    group_sizze_23594 = get_local_size(0);\n    wave_sizze_23593 = LOCKSTEP_WIDTH;\n    group_tid_23592 = get_group_id(0);\n    \n    int32_t phys_tid_19037;\n    \n    phys_tid_19037 = global_tid_23590;\n    \n    int64_t gtid_19036;\n    \n    gtid_19036 = sext_i32_i64(group_tid_23592) * segmap_group_sizze_19115 +\n        sext_i32_i64(local_tid_23591);\n    if (slt64(gtid_19036, n_18078)) {\n        float res_19126 = ((__global float *) swap_term_mem_23220)[gtid_19036];\n        int64_t res_19127 = ((__global\n                              int64_t *) payments_mem_23",
                   "221)[gtid_19036];\n        int64_t range_end_19129 = sub64(res_19127, 1);\n        bool bounds_invalid_upwards_19130 = slt64(range_end_19129, 0);\n        bool valid_19131 = !bounds_invalid_upwards_19130;\n        bool range_valid_c_19132;\n        \n        if (!valid_19131) {\n            {\n                if (atomic_cmpxchg_i32_global(global_failure, -1, 3) == -1) {\n                    global_failure_args[0] = 0;\n                    global_failure_args[1] = 1;\n                    global_failure_args[2] = range_end_19129;\n                    ;\n                }\n                return;\n            }\n        }\n        for (int64_t i_23188 = 0; i_23188 < res_19127; i_23188++) {\n            float res_19136 = sitofp_i64_f32(i_23188);\n            float res_19137 = res_19126 * res_19136;\n            \n            ((__global float *) mem_23257)[phys_tid_19037 + i_23188 *\n                                           num_threads_23372] = res_19137;\n        }\n        \n        bool y_19138 = slt64(0, res_19127);\n        bool index_certs_19139;\n        \n        if (!y_19138) {\n            {\n                if (atomic_cmpxchg_i32_global(global_failure, -1, 4) == -1) {\n                    global_failure_args[0] = 0;\n                    global_failure_args[1] = res_19127;\n                    ;\n                }\n                return;\n            }\n        }\n        \n        float binop_y_19140 = sitofp_i64_f32(range_end_19129);\n        float index_primexp_19141 = res_19126 * binop_y_19140;\n        float negate_arg_19142 = a_18086 * index_primexp_19141;\n        float exp_arg_19143 = 0.0F - negate_arg_19142;\n        float res_19144 = fpow32(2.7182817F, exp_arg_19143);\n        float x_19145 = 1.0F - res_19144;\n        float B_19146 = x_19145 / a_18086;\n        float x_19147 = B_19146 - index_primexp_19141;\n        float x_19148 = y_18110 * x_19147;\n        float A1_19149 = x_19148 / x_18106;\n        float y_19150 = fpow32(B_19146, 2.0F);\n        float x_19151 = x_18108 * y_19150;\n        flo",
                   "at A2_19152 = x_19151 / y_18111;\n        float exp_arg_19153 = A1_19149 - A2_19152;\n        float res_19154 = fpow32(2.7182817F, exp_arg_19153);\n        float negate_arg_19155 = r0_18089 * B_19146;\n        float exp_arg_19156 = 0.0F - negate_arg_19155;\n        float res_19157 = fpow32(2.7182817F, exp_arg_19156);\n        float res_19158 = res_19154 * res_19157;\n        bool empty_slice_19159 = range_end_19129 == 0;\n        bool zzero_leq_i_p_m_t_s_19160 = sle64(0, range_end_19129);\n        bool i_p_m_t_s_leq_w_19161 = slt64(range_end_19129, res_19127);\n        bool i_lte_j_19162 = sle64(1, res_19127);\n        bool y_19163 = zzero_leq_i_p_m_t_s_19160 && i_p_m_t_s_leq_w_19161;\n        bool y_19164 = i_lte_j_19162 && y_19163;\n        bool ok_or_empty_19165 = empty_slice_19159 || y_19164;\n        bool index_certs_19166;\n        \n        if (!ok_or_empty_19165) {\n            {\n                if (atomic_cmpxchg_i32_global(global_failure, -1, 5) == -1) {\n                    global_failure_args[0] = 1;\n                    global_failure_args[1] = res_19127;\n                    ;\n                }\n                return;\n            }\n        }\n        \n        float res_19168;\n        float redout_23190 = 0.0F;\n        \n        for (int64_t i_23191 = 0; i_23191 < range_end_19129; i_23191++) {\n            int64_t slice_23209 = 1 + i_23191;\n            float x_19172 = ((__global float *) mem_23257)[phys_tid_19037 +\n                                                           slice_23209 *\n                                                           num_threads_23372];\n            float negate_arg_19173 = a_18086 * x_19172;\n            float exp_arg_19174 = 0.0F - negate_arg_19173;\n            float res_19175 = fpow32(2.7182817F, exp_arg_19174);\n            float x_19176 = 1.0F - res_19175;\n            float B_19177 = x_19176 / a_18086;\n            float x_19178 = B_19177 - x_19172;\n            float x_19179 = y_18110 * x_19178;\n            float A1_19180 = x_19179 / x_18106;\n    ",
                   "        float y_19181 = fpow32(B_19177, 2.0F);\n            float x_19182 = x_18108 * y_19181;\n            float A2_19183 = x_19182 / y_18111;\n            float exp_arg_19184 = A1_19180 - A2_19183;\n            float res_19185 = fpow32(2.7182817F, exp_arg_19184);\n            float negate_arg_19186 = r0_18089 * B_19177;\n            float exp_arg_19187 = 0.0F - negate_arg_19186;\n            float res_19188 = fpow32(2.7182817F, exp_arg_19187);\n            float res_19189 = res_19185 * res_19188;\n            float res_19171 = res_19189 + redout_23190;\n            float redout_tmp_23596 = res_19171;\n            \n            redout_23190 = redout_tmp_23596;\n        }\n        res_19168 = redout_23190;\n        \n        float x_19190 = 1.0F - res_19158;\n        float y_19191 = res_19126 * res_19168;\n        float res_19192 = x_19190 / y_19191;\n        \n        ((__global float *) mem_23271)[gtid_19036] = res_19192;\n    }\n    \n  error_0:\n    return;\n    #undef segmap_group_sizze_19115\n}\n__kernel void mainzisegmap_19370(__global int *global_failure,\n                                 int failure_is_an_option, __global\n                                 int64_t *global_failure_args,\n                                 int64_t paths_18081, int64_t steps_18082,\n                                 float a_18086, float b_18087,\n                                 float sigma_18088, float r0_18089,\n                                 float dt_18104, int64_t upper_bound_18202,\n                                 float res_18203, int64_t num_groups_19622,\n                                 __global unsigned char *mem_23285, __global\n                                 unsigned char *mem_23288, __global\n                                 unsigned char *mem_23303)\n{\n    #define segmap_group_sizze_19621 (mainzisegmap_group_sizze_19372)\n    \n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    volatile __local bool local_failure;\n    \n    if (failure_is_an_option) {\n        i",
                   "nt failed = *global_failure >= 0;\n        \n        if (failed)\n            return;\n    }\n    local_failure = false;\n    barrier(CLK_LOCAL_MEM_FENCE);\n    \n    int32_t global_tid_23609;\n    int32_t local_tid_23610;\n    int64_t group_sizze_23613;\n    int32_t wave_sizze_23612;\n    int32_t group_tid_23611;\n    \n    global_tid_23609 = get_global_id(0);\n    local_tid_23610 = get_local_id(0);\n    group_sizze_23613 = get_local_size(0);\n    wave_sizze_23612 = LOCKSTEP_WIDTH;\n    group_tid_23611 = get_group_id(0);\n    \n    int32_t phys_tid_19370;\n    \n    phys_tid_19370 = global_tid_23609;\n    \n    int32_t phys_group_id_23614;\n    \n    phys_group_id_23614 = get_group_id(0);\n    for (int32_t i_23615 = 0; i_23615 <\n         sdiv_up32(sext_i64_i32(sdiv_up64(paths_18081,\n                                          segmap_group_sizze_19621)) -\n                   phys_group_id_23614, sext_i64_i32(num_groups_19622));\n         i_23615++) {\n        int32_t virt_group_id_23616 = phys_group_id_23614 + i_23615 *\n                sext_i64_i32(num_groups_19622);\n        int64_t gtid_19369 = sext_i32_i64(virt_group_id_23616) *\n                segmap_group_sizze_19621 + sext_i32_i64(local_tid_23610);\n        \n        if (slt64(gtid_19369, paths_18081)) {\n            for (int64_t i_23617 = 0; i_23617 < steps_18082; i_23617++) {\n                ((__global float *) mem_23288)[phys_tid_19370 + i_23617 *\n                                               (num_groups_19622 *\n                                                segmap_group_sizze_19621)] =\n                    r0_18089;\n            }\n            for (int64_t i_19628 = 0; i_19628 < upper_bound_18202; i_19628++) {\n                bool y_19630 = slt64(i_19628, steps_18082);\n                bool index_certs_19631;\n                \n                if (!y_19630) {\n                    {\n                        if (atomic_cmpxchg_i32_global(global_failure, -1, 6) ==\n                            -1) {\n                            global_failure_args[0] = ",
                   "i_19628;\n                            global_failure_args[1] = steps_18082;\n                            ;\n                        }\n                        local_failure = true;\n                        goto error_0;\n                    }\n                }\n                \n                float shortstep_arg_19632 = ((__global\n                                              float *) mem_23285)[i_19628 *\n                                                                  paths_18081 +\n                                                                  gtid_19369];\n                float shortstep_arg_19633 = ((__global\n                                              float *) mem_23288)[phys_tid_19370 +\n                                                                  i_19628 *\n                                                                  (num_groups_19622 *\n                                                                   segmap_group_sizze_19621)];\n                float y_19634 = b_18087 - shortstep_arg_19633;\n                float x_19635 = a_18086 * y_19634;\n                float x_19636 = dt_18104 * x_19635;\n                float x_19637 = res_18203 * shortstep_arg_19632;\n                float y_19638 = sigma_18088 * x_19637;\n                float delta_r_19639 = x_19636 + y_19638;\n                float res_19640 = shortstep_arg_19633 + delta_r_19639;\n                int64_t i_19641 = add64(1, i_19628);\n                bool x_19642 = sle64(0, i_19641);\n                bool y_19643 = slt64(i_19641, steps_18082);\n                bool bounds_check_19644 = x_19642 && y_19643;\n                bool index_certs_19645;\n                \n                if (!bounds_check_19644) {\n                    {\n                        if (atomic_cmpxchg_i32_global(global_failure, -1, 7) ==\n                            -1) {\n                            global_failure_args[0] = i_19641;\n                            global_failure_args[1] = steps_18082;\n                            ;\n          ",
                   "              }\n                        local_failure = true;\n                        goto error_0;\n                    }\n                }\n                ((__global float *) mem_23288)[phys_tid_19370 + i_19641 *\n                                               (num_groups_19622 *\n                                                segmap_group_sizze_19621)] =\n                    res_19640;\n            }\n            for (int64_t i_23619 = 0; i_23619 < steps_18082; i_23619++) {\n                ((__global float *) mem_23303)[i_23619 * paths_18081 +\n                                               gtid_19369] = ((__global\n                                                               float *) mem_23288)[phys_tid_19370 +\n                                                                                   i_23619 *\n                                                                                   (num_groups_19622 *\n                                                                                    segmap_group_sizze_19621)];\n            }\n        }\n        barrier(CLK_GLOBAL_MEM_FENCE | CLK_LOCAL_MEM_FENCE);\n    }\n    \n  error_0:\n    return;\n    #undef segmap_group_sizze_19621\n}\n__kernel void mainzisegmap_19468(__global int *global_failure,\n                                 int64_t paths_18081, int64_t steps_18082,\n                                 __global unsigned char *mem_23278, __global\n                                 unsigned char *mem_23282)\n{\n    #define segmap_group_sizze_19576 (mainzisegmap_group_sizze_19471)\n    \n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    \n    if (*global_failure >= 0)\n        return;\n    \n    int32_t global_tid_23603;\n    int32_t local_tid_23604;\n    int64_t group_sizze_23607;\n    int32_t wave_sizze_23606;\n    int32_t group_tid_23605;\n    \n    global_tid_23603 = get_global_id(0);\n    local_tid_23604 = get_local_id(0);\n    group_sizze_23607 = get_local_size(0);\n    wave_sizze_23606 = LOCKSTEP_WIDTH;\n  ",
                   "  group_tid_23605 = get_group_id(0);\n    \n    int32_t phys_tid_19468;\n    \n    phys_tid_19468 = global_tid_23603;\n    \n    int64_t gtid_19466;\n    \n    gtid_19466 = squot64(sext_i32_i64(group_tid_23605) *\n                         segmap_group_sizze_19576 +\n                         sext_i32_i64(local_tid_23604), steps_18082);\n    \n    int64_t gtid_19467;\n    \n    gtid_19467 = sext_i32_i64(group_tid_23605) * segmap_group_sizze_19576 +\n        sext_i32_i64(local_tid_23604) - squot64(sext_i32_i64(group_tid_23605) *\n                                                segmap_group_sizze_19576 +\n                                                sext_i32_i64(local_tid_23604),\n                                                steps_18082) * steps_18082;\n    if (slt64(gtid_19466, paths_18081) && slt64(gtid_19467, steps_18082)) {\n        int32_t unsign_arg_19579 = ((__global int32_t *) mem_23278)[gtid_19466];\n        int32_t res_19581 = sext_i64_i32(gtid_19467);\n        int32_t x_19582 = lshr32(res_19581, 16);\n        int32_t x_19583 = res_19581 ^ x_19582;\n        int32_t x_19584 = mul32(73244475, x_19583);\n        int32_t x_19585 = lshr32(x_19584, 16);\n        int32_t x_19586 = x_19584 ^ x_19585;\n        int32_t x_19587 = mul32(73244475, x_19586);\n        int32_t x_19588 = lshr32(x_19587, 16);\n        int32_t x_19589 = x_19587 ^ x_19588;\n        int32_t unsign_arg_19590 = unsign_arg_19579 ^ x_19589;\n        int32_t unsign_arg_19591 = mul32(48271, unsign_arg_19590);\n        int32_t unsign_arg_19592 = umod32(unsign_arg_19591, 2147483647);\n        int32_t unsign_arg_19593 = mul32(48271, unsign_arg_19592);\n        int32_t unsign_arg_19594 = umod32(unsign_arg_19593, 2147483647);\n        float res_19595 = uitofp_i32_f32(unsign_arg_19592);\n        float res_19596 = res_19595 / 2.1474836e9F;\n        float res_19597 = uitofp_i32_f32(unsign_arg_19594);\n        float res_19598 = res_19597 / 2.1474836e9F;\n        float res_19599;\n        \n        res_19599 = futrts_log32(res_19596);\n        \n   ",
                   "     float res_19600 = -2.0F * res_19599;\n        float res_19601;\n        \n        res_19601 = futrts_sqrt32(res_19600);\n        \n        float res_19602 = 6.2831855F * res_19598;\n        float res_19603;\n        \n        res_19603 = futrts_cos32(res_19602);\n        \n        float res_19604 = res_19601 * res_19603;\n        \n        ((__global float *) mem_23282)[gtid_19466 * steps_18082 + gtid_19467] =\n            res_19604;\n    }\n    \n  error_0:\n    return;\n    #undef segmap_group_sizze_19576\n}\n__kernel void mainzisegmap_19532(__global int *global_failure,\n                                 int64_t paths_18081, __global\n                                 unsigned char *mem_23278)\n{\n    #define segmap_group_sizze_19551 (mainzisegmap_group_sizze_19534)\n    \n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    \n    if (*global_failure >= 0)\n        return;\n    \n    int32_t global_tid_23598;\n    int32_t local_tid_23599;\n    int64_t group_sizze_23602;\n    int32_t wave_sizze_23601;\n    int32_t group_tid_23600;\n    \n    global_tid_23598 = get_global_id(0);\n    local_tid_23599 = get_local_id(0);\n    group_sizze_23602 = get_local_size(0);\n    wave_sizze_23601 = LOCKSTEP_WIDTH;\n    group_tid_23600 = get_group_id(0);\n    \n    int32_t phys_tid_19532;\n    \n    phys_tid_19532 = global_tid_23598;\n    \n    int64_t gtid_19531;\n    \n    gtid_19531 = sext_i32_i64(group_tid_23600) * segmap_group_sizze_19551 +\n        sext_i32_i64(local_tid_23599);\n    if (slt64(gtid_19531, paths_18081)) {\n        int32_t res_19555 = sext_i64_i32(gtid_19531);\n        int32_t x_19556 = lshr32(res_19555, 16);\n        int32_t x_19557 = res_19555 ^ x_19556;\n        int32_t x_19558 = mul32(73244475, x_19557);\n        int32_t x_19559 = lshr32(x_19558, 16);\n        int32_t x_19560 = x_19558 ^ x_19559;\n        int32_t x_19561 = mul32(73244475, x_19560);\n        int32_t x_19562 = lshr32(x_19561, 16);\n        int32_t x_19563 = x_19561 ^ x_19562;\n        int32_t unsign_arg_19",
                   "564 = 777822902 ^ x_19563;\n        int32_t unsign_arg_19565 = mul32(48271, unsign_arg_19564);\n        int32_t unsign_arg_19566 = umod32(unsign_arg_19565, 2147483647);\n        \n        ((__global int32_t *) mem_23278)[gtid_19531] = unsign_arg_19566;\n    }\n    \n  error_0:\n    return;\n    #undef segmap_group_sizze_19551\n}\n__kernel void mainzisegmap_19816(__global int *global_failure,\n                                 int failure_is_an_option, __global\n                                 int64_t *global_failure_args, int64_t n_18078,\n                                 int64_t paths_18081, int64_t steps_18082,\n                                 float a_18086, float b_18087,\n                                 float sigma_18088, float x_18106,\n                                 float x_18108, float y_18110, float y_18111,\n                                 float sims_per_year_18188, float res_18265,\n                                 __global unsigned char *res_mem_23272, __global\n                                 unsigned char *res_mem_23273, __global\n                                 unsigned char *res_mem_23274, __global\n                                 unsigned char *res_mem_23275, __global\n                                 unsigned char *mem_23303, __global\n                                 unsigned char *mem_23311, __global\n                                 unsigned char *mem_23313)\n{\n    #define segmap_group_sizze_20570 (mainzisegmap_group_sizze_19818)\n    \n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    \n    if (*global_failure >= 0)\n        return;\n    \n    int32_t global_tid_23656;\n    int32_t local_tid_23657;\n    int64_t group_sizze_23660;\n    int32_t wave_sizze_23659;\n    int32_t group_tid_23658;\n    \n    global_tid_23656 = get_global_id(0);\n    local_tid_23657 = get_local_id(0);\n    group_sizze_23660 = get_local_size(0);\n    wave_sizze_23659 = LOCKSTEP_WIDTH;\n    group_tid_23658 = get_group_id(0);\n    \n    int32_t phys_tid_19816;\n    \n",
                   "    phys_tid_19816 = global_tid_23656;\n    \n    int64_t gtid_19815;\n    \n    gtid_19815 = sext_i32_i64(group_tid_23658) * segmap_group_sizze_20570 +\n        sext_i32_i64(local_tid_23657);\n    if (slt64(gtid_19815, steps_18082)) {\n        int64_t index_primexp_23131 = add64(1, gtid_19815);\n        float res_20577 = sitofp_i64_f32(index_primexp_23131);\n        float res_20578 = res_20577 / sims_per_year_18188;\n        float res_20579;\n        float redout_23196 = 0.0F;\n        \n        for (int64_t i_23197 = 0; i_23197 < paths_18081; i_23197++) {\n            float x_20583 = ((__global float *) mem_23303)[gtid_19815 *\n                                                           paths_18081 +\n                                                           i_23197];\n            float res_20585;\n            float redout_23198 = 0.0F;\n            \n            for (int64_t i_23199 = 0; i_23199 < n_18078; i_23199++) {\n                int64_t x_20591 = ((__global int64_t *) res_mem_23274)[i_23199];\n                float x_20592 = ((__global float *) res_mem_23275)[i_23199];\n                int64_t i64_arg_20593 = sub64(x_20591, 1);\n                float res_20594 = sitofp_i64_f32(i64_arg_20593);\n                float y_20595 = x_20592 * res_20594;\n                bool cond_20596 = y_20595 < res_20578;\n                float ceil_arg_20597 = res_20578 / x_20592;\n                float res_20598;\n                \n                res_20598 = futrts_ceil32(ceil_arg_20597);\n                \n                int64_t res_20599 = fptosi_f32_i64(res_20598);\n                int64_t remaining_20600 = sub64(x_20591, res_20599);\n                float res_20601;\n                \n                if (cond_20596) {\n                    res_20601 = 0.0F;\n                } else {\n                    float x_20589 = ((__global float *) res_mem_23272)[i_23199];\n                    float x_20590 = ((__global float *) res_mem_23273)[i_23199];\n                    float nextpayment_20602 = x_20592 * res_20598;\n",
                   "                    bool bounds_invalid_upwards_20603 = slt64(remaining_20600,\n                                                              1);\n                    bool valid_20604 = !bounds_invalid_upwards_20603;\n                    bool range_valid_c_20605;\n                    \n                    if (!valid_20604) {\n                        {\n                            if (atomic_cmpxchg_i32_global(global_failure, -1,\n                                                          10) == -1) {\n                                global_failure_args[0] = 1;\n                                global_failure_args[1] = 2;\n                                global_failure_args[2] = remaining_20600;\n                                ;\n                            }\n                            return;\n                        }\n                    }\n                    \n                    float y_20607 = nextpayment_20602 - res_20578;\n                    float negate_arg_20608 = a_18086 * y_20607;\n                    float exp_arg_20609 = 0.0F - negate_arg_20608;\n                    float res_20610 = fpow32(2.7182817F, exp_arg_20609);\n                    float x_20611 = 1.0F - res_20610;\n                    float B_20612 = x_20611 / a_18086;\n                    float x_20613 = B_20612 - nextpayment_20602;\n                    float x_20614 = res_20578 + x_20613;\n                    float x_20615 = fpow32(a_18086, 2.0F);\n                    float x_20616 = b_18087 * x_20615;\n                    float x_20617 = fpow32(sigma_18088, 2.0F);\n                    float y_20618 = x_20617 / 2.0F;\n                    float y_20619 = x_20616 - y_20618;\n                    float x_20620 = x_20614 * y_20619;\n                    float A1_20621 = x_20620 / x_20615;\n                    float y_20622 = fpow32(B_20612, 2.0F);\n                    float x_20623 = x_20617 * y_20622;\n                    float y_20624 = 4.0F * a_18086;\n                    float A2_20625 = x_20623 / y_20624;\n                    f",
                   "loat exp_arg_20626 = A1_20621 - A2_20625;\n                    float res_20627 = fpow32(2.7182817F, exp_arg_20626);\n                    float negate_arg_20628 = x_20583 * B_20612;\n                    float exp_arg_20629 = 0.0F - negate_arg_20628;\n                    float res_20630 = fpow32(2.7182817F, exp_arg_20629);\n                    float res_20631 = res_20627 * res_20630;\n                    bool y_20632 = slt64(0, remaining_20600);\n                    bool index_certs_20633;\n                    \n                    if (!y_20632) {\n                        {\n                            if (atomic_cmpxchg_i32_global(global_failure, -1,\n                                                          11) == -1) {\n                                global_failure_args[0] = 0;\n                                global_failure_args[1] = remaining_20600;\n                                ;\n                            }\n                            return;\n                        }\n                    }\n                    \n                    float binop_y_20634 = sitofp_i64_f32(remaining_20600);\n                    float binop_y_20635 = x_20592 * binop_y_20634;\n                    float index_primexp_20636 = nextpayment_20602 +\n                          binop_y_20635;\n                    float y_20637 = index_primexp_20636 - res_20578;\n                    float negate_arg_20638 = a_18086 * y_20637;\n                    float exp_arg_20639 = 0.0F - negate_arg_20638;\n                    float res_20640 = fpow32(2.7182817F, exp_arg_20639);\n                    float x_20641 = 1.0F - res_20640;\n                    float B_20642 = x_20641 / a_18086;\n                    float x_20643 = B_20642 - index_primexp_20636;\n                    float x_20644 = res_20578 + x_20643;\n                    float x_20645 = y_20619 * x_20644;\n                    float A1_20646 = x_20645 / x_20615;\n                    float y_20647 = fpow32(B_20642, 2.0F);\n                    float x_20648 = x_20617 * y_2064",
                   "7;\n                    float A2_20649 = x_20648 / y_20624;\n                    float exp_arg_20650 = A1_20646 - A2_20649;\n                    float res_20651 = fpow32(2.7182817F, exp_arg_20650);\n                    float negate_arg_20652 = x_20583 * B_20642;\n                    float exp_arg_20653 = 0.0F - negate_arg_20652;\n                    float res_20654 = fpow32(2.7182817F, exp_arg_20653);\n                    float res_20655 = res_20651 * res_20654;\n                    float res_20656;\n                    float redout_23128 = 0.0F;\n                    \n                    for (int64_t i_23129 = 0; i_23129 < remaining_20600;\n                         i_23129++) {\n                        int64_t index_primexp_23161 = add64(1, i_23129);\n                        float res_20661 = sitofp_i64_f32(index_primexp_23161);\n                        float res_20662 = x_20592 * res_20661;\n                        float res_20663 = nextpayment_20602 + res_20662;\n                        float y_20664 = res_20663 - res_20578;\n                        float negate_arg_20665 = a_18086 * y_20664;\n                        float exp_arg_20666 = 0.0F - negate_arg_20665;\n                        float res_20667 = fpow32(2.7182817F, exp_arg_20666);\n                        float x_20668 = 1.0F - res_20667;\n                        float B_20669 = x_20668 / a_18086;\n                        float x_20670 = B_20669 - res_20663;\n                        float x_20671 = res_20578 + x_20670;\n                        float x_20672 = y_20619 * x_20671;\n                        float A1_20673 = x_20672 / x_20615;\n                        float y_20674 = fpow32(B_20669, 2.0F);\n                        float x_20675 = x_20617 * y_20674;\n                        float A2_20676 = x_20675 / y_20624;\n                        float exp_arg_20677 = A1_20673 - A2_20676;\n                        float res_20678 = fpow32(2.7182817F, exp_arg_20677);\n                        float negate_arg_20679 = x_20583 * B_20669;\n     ",
                   "                   float exp_arg_20680 = 0.0F - negate_arg_20679;\n                        float res_20681 = fpow32(2.7182817F, exp_arg_20680);\n                        float res_20682 = res_20678 * res_20681;\n                        float res_20659 = res_20682 + redout_23128;\n                        float redout_tmp_23663 = res_20659;\n                        \n                        redout_23128 = redout_tmp_23663;\n                    }\n                    res_20656 = redout_23128;\n                    \n                    float x_20683 = res_20631 - res_20655;\n                    float x_20684 = x_20589 * x_20592;\n                    float y_20685 = res_20656 * x_20684;\n                    float y_20686 = x_20683 - y_20685;\n                    float res_20687 = x_20590 * y_20686;\n                    \n                    res_20601 = res_20687;\n                }\n                \n                float res_20588 = res_20601 + redout_23198;\n                float redout_tmp_23662 = res_20588;\n                \n                redout_23198 = redout_tmp_23662;\n            }\n            res_20585 = redout_23198;\n            \n            float res_20688 = fmax32(0.0F, res_20585);\n            float res_20582 = res_20688 + redout_23196;\n            float redout_tmp_23661 = res_20582;\n            \n            redout_23196 = redout_tmp_23661;\n        }\n        res_20579 = redout_23196;\n        \n        float res_20689 = res_20579 / res_18265;\n        float negate_arg_20690 = a_18086 * res_20578;\n        float exp_arg_20691 = 0.0F - negate_arg_20690;\n        float res_20692 = fpow32(2.7182817F, exp_arg_20691);\n        float x_20693 = 1.0F - res_20692;\n        float B_20694 = x_20693 / a_18086;\n        float x_20695 = B_20694 - res_20578;\n        float x_20696 = y_18110 * x_20695;\n        float A1_20697 = x_20696 / x_18106;\n        float y_20698 = fpow32(B_20694, 2.0F);\n        float x_20699 = x_18108 * y_20698;\n        float A2_20700 = x_20699 / y_18111;\n        float exp_arg_20701 ",
                   "= A1_20697 - A2_20700;\n        float res_20702 = fpow32(2.7182817F, exp_arg_20701);\n        float negate_arg_20703 = 5.0e-2F * B_20694;\n        float exp_arg_20704 = 0.0F - negate_arg_20703;\n        float res_20705 = fpow32(2.7182817F, exp_arg_20704);\n        float res_20706 = res_20702 * res_20705;\n        float res_20707 = res_20689 * res_20706;\n        \n        ((__global float *) mem_23311)[gtid_19815] = res_20707;\n        ((__global float *) mem_23313)[gtid_19815] = res_20689;\n    }\n    \n  error_0:\n    return;\n    #undef segmap_group_sizze_20570\n}\n__kernel void mainzisegmap_20238(__global int *global_failure,\n                                 int64_t steps_18082, float a_18086,\n                                 float x_18106, float x_18108, float y_18110,\n                                 float y_18111, float sims_per_year_18188,\n                                 float res_18265, __global\n                                 unsigned char *mem_23322, __global\n                                 unsigned char *mem_23325, __global\n                                 unsigned char *mem_23327)\n{\n    #define segmap_group_sizze_20971 (mainzisegmap_group_sizze_20240)\n    \n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    \n    if (*global_failure >= 0)\n        return;\n    \n    int32_t global_tid_23740;\n    int32_t local_tid_23741;\n    int64_t group_sizze_23744;\n    int32_t wave_sizze_23743;\n    int32_t group_tid_23742;\n    \n    global_tid_23740 = get_global_id(0);\n    local_tid_23741 = get_local_id(0);\n    group_sizze_23744 = get_local_size(0);\n    wave_sizze_23743 = LOCKSTEP_WIDTH;\n    group_tid_23742 = get_group_id(0);\n    \n    int32_t phys_tid_20238;\n    \n    phys_tid_20238 = global_tid_23740;\n    \n    int64_t gtid_20237;\n    \n    gtid_20237 = sext_i32_i64(group_tid_23742) * segmap_group_sizze_20971 +\n        sext_i32_i64(local_tid_23741);\n    if (slt64(gtid_20237, steps_18082)) {\n        int64_t convop_x_23149 = add64(1, gtid_20237);\n ",
                   "       float binop_x_23150 = sitofp_i64_f32(convop_x_23149);\n        float index_primexp_23151 = binop_x_23150 / sims_per_year_18188;\n        float res_20976 = ((__global float *) mem_23322)[gtid_20237];\n        float res_20977 = res_20976 / res_18265;\n        float negate_arg_20978 = a_18086 * index_primexp_23151;\n        float exp_arg_20979 = 0.0F - negate_arg_20978;\n        float res_20980 = fpow32(2.7182817F, exp_arg_20979);\n        float x_20981 = 1.0F - res_20980;\n        float B_20982 = x_20981 / a_18086;\n        float x_20983 = B_20982 - index_primexp_23151;\n        float x_20984 = y_18110 * x_20983;\n        float A1_20985 = x_20984 / x_18106;\n        float y_20986 = fpow32(B_20982, 2.0F);\n        float x_20987 = x_18108 * y_20986;\n        float A2_20988 = x_20987 / y_18111;\n        float exp_arg_20989 = A1_20985 - A2_20988;\n        float res_20990 = fpow32(2.7182817F, exp_arg_20989);\n        float negate_arg_20991 = 5.0e-2F * B_20982;\n        float exp_arg_20992 = 0.0F - negate_arg_20991;\n        float res_20993 = fpow32(2.7182817F, exp_arg_20992);\n        float res_20994 = res_20990 * res_20993;\n        float res_20995 = res_20977 * res_20994;\n        \n        ((__global float *) mem_23325)[gtid_20237] = res_20995;\n        ((__global float *) mem_23327)[gtid_20237] = res_20977;\n    }\n    \n  error_0:\n    return;\n    #undef segmap_group_sizze_20971\n}\n__kernel void mainzisegmap_intragroup_19814(__global int *global_failure,\n                                            int failure_is_an_option, __global\n                                            int64_t *global_failure_args,\n                                            __local volatile\n                                            int64_t *red_arr_mem_23670_backing_aligned_0,\n                                            int64_t n_18078,\n                                            int64_t paths_18081, float a_18086,\n                                            float b_18087, float sigma_18088,\n                      ",
                   "                      float x_18106, float x_18108,\n                                            float y_18110, float y_18111,\n                                            float sims_per_year_18188,\n                                            float res_18265, __global\n                                            unsigned char *res_mem_23272,\n                                            __global\n                                            unsigned char *res_mem_23273,\n                                            __global\n                                            unsigned char *res_mem_23274,\n                                            __global\n                                            unsigned char *res_mem_23275,\n                                            __global unsigned char *mem_23303,\n                                            __global unsigned char *mem_23317,\n                                            __global unsigned char *mem_23319)\n{\n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    __local volatile char *restrict red_arr_mem_23670_backing_0 =\n                          (__local volatile\n                           char *) red_arr_mem_23670_backing_aligned_0;\n    volatile __local bool local_failure;\n    \n    if (failure_is_an_option) {\n        int failed = *global_failure >= 0;\n        \n        if (failed)\n            return;\n    }\n    local_failure = false;\n    barrier(CLK_LOCAL_MEM_FENCE);\n    \n    int32_t global_tid_23664;\n    int32_t local_tid_23665;\n    int64_t group_sizze_23668;\n    int32_t wave_sizze_23667;\n    int32_t group_tid_23666;\n    \n    global_tid_23664 = get_global_id(0);\n    local_tid_23665 = get_local_id(0);\n    group_sizze_23668 = get_local_size(0);\n    wave_sizze_23667 = LOCKSTEP_WIDTH;\n    group_tid_23666 = get_group_id(0);\n    \n    int32_t phys_tid_19814;\n    \n    phys_tid_19814 = group_tid_23666;\n    \n    int32_t ltid_pre_23669;\n    \n    ltid_pre_23669 = local_tid_23665;\n    \n    int64_t g",
                   "tid_19809;\n    \n    gtid_19809 = sext_i32_i64(group_tid_23666);\n    \n    int64_t index_primexp_23139;\n    \n    index_primexp_23139 = add64(1, gtid_19809);\n    \n    float res_20715 = sitofp_i64_f32(index_primexp_23139);\n    float res_20716 = res_20715 / sims_per_year_18188;\n    float res_20717;\n    int64_t gtid_19812 = sext_i32_i64(ltid_pre_23669);\n    int32_t phys_tid_19813 = local_tid_23665;\n    __local char *red_arr_mem_23670;\n    \n    red_arr_mem_23670 = (__local char *) red_arr_mem_23670_backing_0;\n    if (slt64(gtid_19812, paths_18081)) {\n        float x_20721 = ((__global float *) mem_23303)[gtid_19809 *\n                                                       paths_18081 +\n                                                       gtid_19812];\n        float res_20723;\n        float redout_23200 = 0.0F;\n        \n        for (int64_t i_23201 = 0; i_23201 < n_18078; i_23201++) {\n            int64_t x_20729 = ((__global int64_t *) res_mem_23274)[i_23201];\n            float x_20730 = ((__global float *) res_mem_23275)[i_23201];\n            int64_t i64_arg_20731 = sub64(x_20729, 1);\n            float res_20732 = sitofp_i64_f32(i64_arg_20731);\n            float y_20733 = x_20730 * res_20732;\n            bool cond_20734 = y_20733 < res_20716;\n            float ceil_arg_20735 = res_20716 / x_20730;\n            float res_20736;\n            \n            res_20736 = futrts_ceil32(ceil_arg_20735);\n            \n            int64_t res_20737 = fptosi_f32_i64(res_20736);\n            int64_t remaining_20738 = sub64(x_20729, res_20737);\n            float res_20739;\n            \n            if (cond_20734) {\n                res_20739 = 0.0F;\n            } else {\n                float x_20727 = ((__global float *) res_mem_23272)[i_23201];\n                float x_20728 = ((__global float *) res_mem_23273)[i_23201];\n                float nextpayment_20740 = x_20730 * res_20736;\n                bool bounds_invalid_upwards_20741 = slt64(remaining_20738, 1);\n                bool valid_2074",
                   "2 = !bounds_invalid_upwards_20741;\n                bool range_valid_c_20743;\n                \n                if (!valid_20742) {\n                    {\n                        if (atomic_cmpxchg_i32_global(global_failure, -1, 12) ==\n                            -1) {\n                            global_failure_args[0] = 1;\n                            global_failure_args[1] = 2;\n                            global_failure_args[2] = remaining_20738;\n                            ;\n                        }\n                        local_failure = true;\n                        goto error_0;\n                    }\n                }\n                \n                float y_20745 = nextpayment_20740 - res_20716;\n                float negate_arg_20746 = a_18086 * y_20745;\n                float exp_arg_20747 = 0.0F - negate_arg_20746;\n                float res_20748 = fpow32(2.7182817F, exp_arg_20747);\n                float x_20749 = 1.0F - res_20748;\n                float B_20750 = x_20749 / a_18086;\n                float x_20751 = B_20750 - nextpayment_20740;\n                float x_20752 = res_20716 + x_20751;\n                float x_20753 = fpow32(a_18086, 2.0F);\n                float x_20754 = b_18087 * x_20753;\n                float x_20755 = fpow32(sigma_18088, 2.0F);\n                float y_20756 = x_20755 / 2.0F;\n                float y_20757 = x_20754 - y_20756;\n                float x_20758 = x_20752 * y_20757;\n                float A1_20759 = x_20758 / x_20753;\n                float y_20760 = fpow32(B_20750, 2.0F);\n                float x_20761 = x_20755 * y_20760;\n                float y_20762 = 4.0F * a_18086;\n                float A2_20763 = x_20761 / y_20762;\n                float exp_arg_20764 = A1_20759 - A2_20763;\n                float res_20765 = fpow32(2.7182817F, exp_arg_20764);\n                float negate_arg_20766 = x_20721 * B_20750;\n                float exp_arg_20767 = 0.0F - negate_arg_20766;\n                float res_20768 = fpow32(2.7182817F, exp_arg",
                   "_20767);\n                float res_20769 = res_20765 * res_20768;\n                bool y_20770 = slt64(0, remaining_20738);\n                bool index_certs_20771;\n                \n                if (!y_20770) {\n                    {\n                        if (atomic_cmpxchg_i32_global(global_failure, -1, 13) ==\n                            -1) {\n                            global_failure_args[0] = 0;\n                            global_failure_args[1] = remaining_20738;\n                            ;\n                        }\n                        local_failure = true;\n                        goto error_0;\n                    }\n                }\n                \n                float binop_y_20772 = sitofp_i64_f32(remaining_20738);\n                float binop_y_20773 = x_20730 * binop_y_20772;\n                float index_primexp_20774 = nextpayment_20740 + binop_y_20773;\n                float y_20775 = index_primexp_20774 - res_20716;\n                float negate_arg_20776 = a_18086 * y_20775;\n                float exp_arg_20777 = 0.0F - negate_arg_20776;\n                float res_20778 = fpow32(2.7182817F, exp_arg_20777);\n                float x_20779 = 1.0F - res_20778;\n                float B_20780 = x_20779 / a_18086;\n                float x_20781 = B_20780 - index_primexp_20774;\n                float x_20782 = res_20716 + x_20781;\n                float x_20783 = y_20757 * x_20782;\n                float A1_20784 = x_20783 / x_20753;\n                float y_20785 = fpow32(B_20780, 2.0F);\n                float x_20786 = x_20755 * y_20785;\n                float A2_20787 = x_20786 / y_20762;\n                float exp_arg_20788 = A1_20784 - A2_20787;\n                float res_20789 = fpow32(2.7182817F, exp_arg_20788);\n                float negate_arg_20790 = x_20721 * B_20780;\n                float exp_arg_20791 = 0.0F - negate_arg_20790;\n                float res_20792 = fpow32(2.7182817F, exp_arg_20791);\n                float res_20793 = res_20789 * res_20792;\n  ",
                   "              float res_20794;\n                float redout_23132 = 0.0F;\n                \n                for (int64_t i_23133 = 0; i_23133 < remaining_20738;\n                     i_23133++) {\n                    int64_t index_primexp_23163 = add64(1, i_23133);\n                    float res_20799 = sitofp_i64_f32(index_primexp_23163);\n                    float res_20800 = x_20730 * res_20799;\n                    float res_20801 = nextpayment_20740 + res_20800;\n                    float y_20802 = res_20801 - res_20716;\n                    float negate_arg_20803 = a_18086 * y_20802;\n                    float exp_arg_20804 = 0.0F - negate_arg_20803;\n                    float res_20805 = fpow32(2.7182817F, exp_arg_20804);\n                    float x_20806 = 1.0F - res_20805;\n                    float B_20807 = x_20806 / a_18086;\n                    float x_20808 = B_20807 - res_20801;\n                    float x_20809 = res_20716 + x_20808;\n                    float x_20810 = y_20757 * x_20809;\n                    float A1_20811 = x_20810 / x_20753;\n                    float y_20812 = fpow32(B_20807, 2.0F);\n                    float x_20813 = x_20755 * y_20812;\n                    float A2_20814 = x_20813 / y_20762;\n                    float exp_arg_20815 = A1_20811 - A2_20814;\n                    float res_20816 = fpow32(2.7182817F, exp_arg_20815);\n                    float negate_arg_20817 = x_20721 * B_20807;\n                    float exp_arg_20818 = 0.0F - negate_arg_20817;\n                    float res_20819 = fpow32(2.7182817F, exp_arg_20818);\n                    float res_20820 = res_20816 * res_20819;\n                    float res_20797 = res_20820 + redout_23132;\n                    float redout_tmp_23673 = res_20797;\n                    \n                    redout_23132 = redout_tmp_23673;\n                }\n                res_20794 = redout_23132;\n                \n                float x_20821 = res_20769 - res_20793;\n                float x_20822 = x_20727 ",
                   "* x_20730;\n                float y_20823 = res_20794 * x_20822;\n                float y_20824 = x_20821 - y_20823;\n                float res_20825 = x_20728 * y_20824;\n                \n                res_20739 = res_20825;\n            }\n            \n            float res_20726 = res_20739 + redout_23200;\n            float redout_tmp_23672 = res_20726;\n            \n            redout_23200 = redout_tmp_23672;\n        }\n        res_20723 = redout_23200;\n        \n        float res_20826 = fmax32(0.0F, res_20723);\n        \n        ((__local float *) red_arr_mem_23670)[gtid_19812] = res_20826;\n    }\n    \n  error_0:\n    barrier(CLK_LOCAL_MEM_FENCE);\n    if (local_failure)\n        return;\n    barrier(CLK_LOCAL_MEM_FENCE);\n    \n    int32_t offset_23674;\n    int32_t skip_waves_23675;\n    \n    skip_waves_23675 = 1;\n    \n    float x_20718;\n    float x_20719;\n    \n    offset_23674 = 0;\n    // participating threads read initial accumulator\n    {\n        if (slt32(local_tid_23665, sext_i64_i32(paths_18081))) {\n            x_20718 = ((__local\n                        float *) red_arr_mem_23670)[sext_i32_i64(local_tid_23665 +\n                                                    offset_23674)];\n        }\n    }\n    offset_23674 = 1;\n    while (slt32(offset_23674, wave_sizze_23667)) {\n        if (slt32(local_tid_23665 + offset_23674, sext_i64_i32(paths_18081)) &&\n            ((local_tid_23665 - squot32(local_tid_23665, wave_sizze_23667) *\n              wave_sizze_23667) & (2 * offset_23674 - 1)) == 0) {\n            // read array element\n            {\n                x_20719 = ((volatile __local\n                            float *) red_arr_mem_23670)[sext_i32_i64(local_tid_23665 +\n                                                        offset_23674)];\n            }\n            // apply reduction operation\n            {\n                float res_20720 = x_20718 + x_20719;\n                \n                x_20718 = res_20720;\n            }\n            // write result of operation\n        ",
                   "    {\n                ((volatile __local\n                  float *) red_arr_mem_23670)[sext_i32_i64(local_tid_23665)] =\n                    x_20718;\n            }\n        }\n        offset_23674 *= 2;\n    }\n    while (slt32(skip_waves_23675, squot32(sext_i64_i32(paths_18081) +\n                                           wave_sizze_23667 - 1,\n                                           wave_sizze_23667))) {\n        barrier(CLK_LOCAL_MEM_FENCE);\n        offset_23674 = skip_waves_23675 * wave_sizze_23667;\n        if (slt32(local_tid_23665 + offset_23674, sext_i64_i32(paths_18081)) &&\n            ((local_tid_23665 - squot32(local_tid_23665, wave_sizze_23667) *\n              wave_sizze_23667) == 0 && (squot32(local_tid_23665,\n                                                 wave_sizze_23667) & (2 *\n                                                                      skip_waves_23675 -\n                                                                      1)) ==\n             0)) {\n            // read array element\n            {\n                x_20719 = ((__local\n                            float *) red_arr_mem_23670)[sext_i32_i64(local_tid_23665 +\n                                                        offset_23674)];\n            }\n            // apply reduction operation\n            {\n                float res_20720 = x_20718 + x_20719;\n                \n                x_20718 = res_20720;\n            }\n            // write result of operation\n            {\n                ((__local\n                  float *) red_arr_mem_23670)[sext_i32_i64(local_tid_23665)] =\n                    x_20718;\n            }\n        }\n        skip_waves_23675 *= 2;\n    }\n    barrier(CLK_LOCAL_MEM_FENCE);\n    res_20717 = ((__local float *) red_arr_mem_23670)[0];\n    \n    float res_20827 = res_20717 / res_18265;\n    float negate_arg_20828 = a_18086 * res_20716;\n    float exp_arg_20829 = 0.0F - negate_arg_20828;\n    float res_20830 = fpow32(2.7182817F, exp_arg_20829);\n    float x_20831 = 1.0F - res",
                   "_20830;\n    float B_20832 = x_20831 / a_18086;\n    float x_20833 = B_20832 - res_20716;\n    float x_20834 = y_18110 * x_20833;\n    float A1_20835 = x_20834 / x_18106;\n    float y_20836 = fpow32(B_20832, 2.0F);\n    float x_20837 = x_18108 * y_20836;\n    float A2_20838 = x_20837 / y_18111;\n    float exp_arg_20839 = A1_20835 - A2_20838;\n    float res_20840 = fpow32(2.7182817F, exp_arg_20839);\n    float negate_arg_20841 = 5.0e-2F * B_20832;\n    float exp_arg_20842 = 0.0F - negate_arg_20841;\n    float res_20843 = fpow32(2.7182817F, exp_arg_20842);\n    float res_20844 = res_20840 * res_20843;\n    float res_20845 = res_20827 * res_20844;\n    \n    if (local_tid_23665 == 0) {\n        ((__global float *) mem_23317)[gtid_19809] = res_20845;\n    }\n    if (local_tid_23665 == 0) {\n        ((__global float *) mem_23319)[gtid_19809] = res_20827;\n    }\n    \n  error_2:\n    return;\n}\n__kernel void mainzisegred_large_20273(__global int *global_failure,\n                                       int failure_is_an_option, __global\n                                       int64_t *global_failure_args,\n                                       __local volatile\n                                       int64_t *sync_arr_mem_23715_backing_aligned_0,\n                                       __local volatile\n                                       int64_t *red_arr_mem_23713_backing_aligned_1,\n                                       int64_t n_18078, int64_t paths_18081,\n                                       float a_18086, float b_18087,\n                                       float sigma_18088,\n                                       float sims_per_year_18188,\n                                       int64_t num_groups_20856, __global\n                                       unsigned char *res_mem_23272, __global\n                                       unsigned char *res_mem_23273, __global\n                                       unsigned char *res_mem_23274, __global\n                                       unsigned c",
                   "har *res_mem_23275, __global\n                                       unsigned char *mem_23303, __global\n                                       unsigned char *mem_23322,\n                                       int64_t groups_per_segment_23699,\n                                       int64_t elements_per_thread_23700,\n                                       int64_t virt_num_groups_23701,\n                                       int64_t threads_per_segment_23703,\n                                       __global\n                                       unsigned char *group_res_arr_mem_23704,\n                                       __global\n                                       unsigned char *mainzicounter_mem_23706)\n{\n    #define segred_group_sizze_20855 (mainzisegred_group_sizze_20267)\n    \n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    __local volatile char *restrict sync_arr_mem_23715_backing_1 =\n                          (__local volatile\n                           char *) sync_arr_mem_23715_backing_aligned_0;\n    __local volatile char *restrict red_arr_mem_23713_backing_0 =\n                          (__local volatile\n                           char *) red_arr_mem_23713_backing_aligned_1;\n    volatile __local bool local_failure;\n    \n    if (failure_is_an_option) {\n        int failed = *global_failure >= 0;\n        \n        if (failed)\n            return;\n    }\n    local_failure = false;\n    barrier(CLK_LOCAL_MEM_FENCE);\n    \n    int32_t global_tid_23708;\n    int32_t local_tid_23709;\n    int64_t group_sizze_23712;\n    int32_t wave_sizze_23711;\n    int32_t group_tid_23710;\n    \n    global_tid_23708 = get_global_id(0);\n    local_tid_23709 = get_local_id(0);\n    group_sizze_23712 = get_local_size(0);\n    wave_sizze_23711 = LOCKSTEP_WIDTH;\n    group_tid_23710 = get_group_id(0);\n    \n    int32_t phys_tid_20273;\n    \n    phys_tid_20273 = global_tid_23708;\n    \n    __local char *red_arr_mem_23713;\n    \n    red_arr_mem_23713 = (__local ",
                   "char *) red_arr_mem_23713_backing_0;\n    \n    __local char *sync_arr_mem_23715;\n    \n    sync_arr_mem_23715 = (__local char *) sync_arr_mem_23715_backing_1;\n    \n    int32_t phys_group_id_23717;\n    \n    phys_group_id_23717 = get_group_id(0);\n    for (int32_t i_23718 = 0; i_23718 <\n         sdiv_up32(sext_i64_i32(virt_num_groups_23701) - phys_group_id_23717,\n                   sext_i64_i32(num_groups_20856)); i_23718++) {\n        int32_t virt_group_id_23719 = phys_group_id_23717 + i_23718 *\n                sext_i64_i32(num_groups_20856);\n        int32_t flat_segment_id_23720 = squot32(virt_group_id_23719,\n                                                sext_i64_i32(groups_per_segment_23699));\n        int64_t global_tid_23721 = srem64(sext_i32_i64(virt_group_id_23719) *\n                                          segred_group_sizze_20855 +\n                                          sext_i32_i64(local_tid_23709),\n                                          segred_group_sizze_20855 *\n                                          groups_per_segment_23699);\n        int64_t gtid_20264 = sext_i32_i64(flat_segment_id_23720);\n        int64_t gtid_20272;\n        float x_acc_23722;\n        int64_t chunk_sizze_23723;\n        \n        chunk_sizze_23723 = smin64(elements_per_thread_23700,\n                                   sdiv_up64(paths_18081 -\n                                             sext_i32_i64(sext_i64_i32(global_tid_23721)),\n                                             threads_per_segment_23703));\n        \n        float x_20859;\n        float x_20860;\n        \n        // neutral-initialise the accumulators\n        {\n            x_acc_23722 = 0.0F;\n        }\n        for (int64_t i_23727 = 0; i_23727 < chunk_sizze_23723; i_23727++) {\n            gtid_20272 = sext_i32_i64(sext_i64_i32(global_tid_23721)) +\n                threads_per_segment_23703 * i_23727;\n            // apply map function\n            {\n                float x_20864 = ((__global float *) mem_23303)[gtid_20264 *\n ",
                   "                                                              paths_18081 +\n                                                               gtid_20272];\n                int64_t convop_x_23145 = add64(1, gtid_20264);\n                float binop_x_23146 = sitofp_i64_f32(convop_x_23145);\n                float index_primexp_23147 = binop_x_23146 / sims_per_year_18188;\n                float res_20866;\n                float redout_23202 = 0.0F;\n                \n                for (int64_t i_23203 = 0; i_23203 < n_18078; i_23203++) {\n                    int64_t x_20872 = ((__global\n                                        int64_t *) res_mem_23274)[i_23203];\n                    float x_20873 = ((__global float *) res_mem_23275)[i_23203];\n                    int64_t i64_arg_20874 = sub64(x_20872, 1);\n                    float res_20875 = sitofp_i64_f32(i64_arg_20874);\n                    float y_20876 = x_20873 * res_20875;\n                    bool cond_20877 = y_20876 < index_primexp_23147;\n                    float ceil_arg_20878 = index_primexp_23147 / x_20873;\n                    float res_20879;\n                    \n                    res_20879 = futrts_ceil32(ceil_arg_20878);\n                    \n                    int64_t res_20880 = fptosi_f32_i64(res_20879);\n                    int64_t remaining_20881 = sub64(x_20872, res_20880);\n                    float res_20882;\n                    \n                    if (cond_20877) {\n                        res_20882 = 0.0F;\n                    } else {\n                        float x_20870 = ((__global\n                                          float *) res_mem_23272)[i_23203];\n                        float x_20871 = ((__global\n                                          float *) res_mem_23273)[i_23203];\n                        float nextpayment_20883 = x_20873 * res_20879;\n                        bool bounds_invalid_upwards_20884 =\n                             slt64(remaining_20881, 1);\n                        bool valid_2088",
                   "5 = !bounds_invalid_upwards_20884;\n                        bool range_valid_c_20886;\n                        \n                        if (!valid_20885) {\n                            {\n                                if (atomic_cmpxchg_i32_global(global_failure,\n                                                              -1, 16) == -1) {\n                                    global_failure_args[0] = 1;\n                                    global_failure_args[1] = 2;\n                                    global_failure_args[2] = remaining_20881;\n                                    ;\n                                }\n                                local_failure = true;\n                                goto error_0;\n                            }\n                        }\n                        \n                        float y_20888 = nextpayment_20883 - index_primexp_23147;\n                        float negate_arg_20889 = a_18086 * y_20888;\n                        float exp_arg_20890 = 0.0F - negate_arg_20889;\n                        float res_20891 = fpow32(2.7182817F, exp_arg_20890);\n                        float x_20892 = 1.0F - res_20891;\n                        float B_20893 = x_20892 / a_18086;\n                        float x_20894 = B_20893 - nextpayment_20883;\n                        float x_20895 = x_20894 + index_primexp_23147;\n                        float x_20896 = fpow32(a_18086, 2.0F);\n                        float x_20897 = b_18087 * x_20896;\n                        float x_20898 = fpow32(sigma_18088, 2.0F);\n                        float y_20899 = x_20898 / 2.0F;\n                        float y_20900 = x_20897 - y_20899;\n                        float x_20901 = x_20895 * y_20900;\n                        float A1_20902 = x_20901 / x_20896;\n                        float y_20903 = fpow32(B_20893, 2.0F);\n                        float x_20904 = x_20898 * y_20903;\n                        float y_20905 = 4.0F * a_18086;\n                        float A2_20906 = x_20",
                   "904 / y_20905;\n                        float exp_arg_20907 = A1_20902 - A2_20906;\n                        float res_20908 = fpow32(2.7182817F, exp_arg_20907);\n                        float negate_arg_20909 = x_20864 * B_20893;\n                        float exp_arg_20910 = 0.0F - negate_arg_20909;\n                        float res_20911 = fpow32(2.7182817F, exp_arg_20910);\n                        float res_20912 = res_20908 * res_20911;\n                        bool y_20913 = slt64(0, remaining_20881);\n                        bool index_certs_20914;\n                        \n                        if (!y_20913) {\n                            {\n                                if (atomic_cmpxchg_i32_global(global_failure,\n                                                              -1, 17) == -1) {\n                                    global_failure_args[0] = 0;\n                                    global_failure_args[1] = remaining_20881;\n                                    ;\n                                }\n                                local_failure = true;\n                                goto error_0;\n                            }\n                        }\n                        \n                        float binop_y_20915 = sitofp_i64_f32(remaining_20881);\n                        float binop_y_20916 = x_20873 * binop_y_20915;\n                        float index_primexp_20917 = nextpayment_20883 +\n                              binop_y_20916;\n                        float y_20918 = index_primexp_20917 -\n                              index_primexp_23147;\n                        float negate_arg_20919 = a_18086 * y_20918;\n                        float exp_arg_20920 = 0.0F - negate_arg_20919;\n                        float res_20921 = fpow32(2.7182817F, exp_arg_20920);\n                        float x_20922 = 1.0F - res_20921;\n                        float B_20923 = x_20922 / a_18086;\n                        float x_20924 = B_20923 - index_primexp_20917;\n               ",
                   "         float x_20925 = x_20924 + index_primexp_23147;\n                        float x_20926 = y_20900 * x_20925;\n                        float A1_20927 = x_20926 / x_20896;\n                        float y_20928 = fpow32(B_20923, 2.0F);\n                        float x_20929 = x_20898 * y_20928;\n                        float A2_20930 = x_20929 / y_20905;\n                        float exp_arg_20931 = A1_20927 - A2_20930;\n                        float res_20932 = fpow32(2.7182817F, exp_arg_20931);\n                        float negate_arg_20933 = x_20864 * B_20923;\n                        float exp_arg_20934 = 0.0F - negate_arg_20933;\n                        float res_20935 = fpow32(2.7182817F, exp_arg_20934);\n                        float res_20936 = res_20932 * res_20935;\n                        float res_20937;\n                        float redout_23142 = 0.0F;\n                        \n                        for (int64_t i_23143 = 0; i_23143 < remaining_20881;\n                             i_23143++) {\n                            int64_t index_primexp_23165 = add64(1, i_23143);\n                            float res_20942 =\n                                  sitofp_i64_f32(index_primexp_23165);\n                            float res_20943 = x_20873 * res_20942;\n                            float res_20944 = nextpayment_20883 + res_20943;\n                            float y_20945 = res_20944 - index_primexp_23147;\n                            float negate_arg_20946 = a_18086 * y_20945;\n                            float exp_arg_20947 = 0.0F - negate_arg_20946;\n                            float res_20948 = fpow32(2.7182817F, exp_arg_20947);\n                            float x_20949 = 1.0F - res_20948;\n                            float B_20950 = x_20949 / a_18086;\n                            float x_20951 = B_20950 - res_20944;\n                            float x_20952 = x_20951 + index_primexp_23147;\n                            float x_20953 = y_20900 * x_20952;\n           ",
                   "                 float A1_20954 = x_20953 / x_20896;\n                            float y_20955 = fpow32(B_20950, 2.0F);\n                            float x_20956 = x_20898 * y_20955;\n                            float A2_20957 = x_20956 / y_20905;\n                            float exp_arg_20958 = A1_20954 - A2_20957;\n                            float res_20959 = fpow32(2.7182817F, exp_arg_20958);\n                            float negate_arg_20960 = x_20864 * B_20950;\n                            float exp_arg_20961 = 0.0F - negate_arg_20960;\n                            float res_20962 = fpow32(2.7182817F, exp_arg_20961);\n                            float res_20963 = res_20959 * res_20962;\n                            float res_20940 = res_20963 + redout_23142;\n                            float redout_tmp_23729 = res_20940;\n                            \n                            redout_23142 = redout_tmp_23729;\n                        }\n                        res_20937 = redout_23142;\n                        \n                        float x_20964 = res_20912 - res_20936;\n                        float x_20965 = x_20870 * x_20873;\n                        float y_20966 = res_20937 * x_20965;\n                        float y_20967 = x_20964 - y_20966;\n                        float res_20968 = x_20871 * y_20967;\n                        \n                        res_20882 = res_20968;\n                    }\n                    \n                    float res_20869 = res_20882 + redout_23202;\n                    float redout_tmp_23728 = res_20869;\n                    \n                    redout_23202 = redout_tmp_23728;\n                }\n                res_20866 = redout_23202;\n                \n                float res_20969 = fmax32(0.0F, res_20866);\n                \n                // save map-out results\n                { }\n                // load accumulator\n                {\n                    x_20859 = x_acc_23722;\n                }\n                // load new values\n  ",
                   "              {\n                    x_20860 = res_20969;\n                }\n                // apply reduction operator\n                {\n                    float res_20861 = x_20859 + x_20860;\n                    \n                    // store in accumulator\n                    {\n                        x_acc_23722 = res_20861;\n                    }\n                }\n            }\n        }\n        // to reduce current chunk, first store our result in memory\n        {\n            x_20859 = x_acc_23722;\n            ((__local\n              float *) red_arr_mem_23713)[sext_i32_i64(local_tid_23709)] =\n                x_20859;\n        }\n        \n      error_0:\n        barrier(CLK_LOCAL_MEM_FENCE);\n        if (local_failure)\n            return;\n        barrier(CLK_LOCAL_MEM_FENCE);\n        \n        int32_t offset_23730;\n        int32_t skip_waves_23731;\n        \n        skip_waves_23731 = 1;\n        \n        float x_23724;\n        float x_23725;\n        \n        offset_23730 = 0;\n        // participating threads read initial accumulator\n        {\n            if (slt32(local_tid_23709,\n                      sext_i64_i32(segred_group_sizze_20855))) {\n                x_23724 = ((__local\n                            float *) red_arr_mem_23713)[sext_i32_i64(local_tid_23709 +\n                                                        offset_23730)];\n            }\n        }\n        offset_23730 = 1;\n        while (slt32(offset_23730, wave_sizze_23711)) {\n            if (slt32(local_tid_23709 + offset_23730,\n                      sext_i64_i32(segred_group_sizze_20855)) &&\n                ((local_tid_23709 - squot32(local_tid_23709, wave_sizze_23711) *\n                  wave_sizze_23711) & (2 * offset_23730 - 1)) == 0) {\n                // read array element\n                {\n                    x_23725 = ((volatile __local\n                                float *) red_arr_mem_23713)[sext_i32_i64(local_tid_23709 +\n                                                            offset_23730",
                   ")];\n                }\n                // apply reduction operation\n                {\n                    float res_23726 = x_23724 + x_23725;\n                    \n                    x_23724 = res_23726;\n                }\n                // write result of operation\n                {\n                    ((volatile __local\n                      float *) red_arr_mem_23713)[sext_i32_i64(local_tid_23709)] =\n                        x_23724;\n                }\n            }\n            offset_23730 *= 2;\n        }\n        while (slt32(skip_waves_23731,\n                     squot32(sext_i64_i32(segred_group_sizze_20855) +\n                             wave_sizze_23711 - 1, wave_sizze_23711))) {\n            barrier(CLK_LOCAL_MEM_FENCE);\n            offset_23730 = skip_waves_23731 * wave_sizze_23711;\n            if (slt32(local_tid_23709 + offset_23730,\n                      sext_i64_i32(segred_group_sizze_20855)) &&\n                ((local_tid_23709 - squot32(local_tid_23709, wave_sizze_23711) *\n                  wave_sizze_23711) == 0 && (squot32(local_tid_23709,\n                                                     wave_sizze_23711) & (2 *\n                                                                          skip_waves_23731 -\n                                                                          1)) ==\n                 0)) {\n                // read array element\n                {\n                    x_23725 = ((__local\n                                float *) red_arr_mem_23713)[sext_i32_i64(local_tid_23709 +\n                                                            offset_23730)];\n                }\n                // apply reduction operation\n                {\n                    float res_23726 = x_23724 + x_23725;\n                    \n                    x_23724 = res_23726;\n                }\n                // write result of operation\n                {\n                    ((__local\n                      float *) red_arr_mem_23713)[sext_i32_i64(local_tid_23709)]",
                   " =\n                        x_23724;\n                }\n            }\n            skip_waves_23731 *= 2;\n        }\n        barrier(CLK_LOCAL_MEM_FENCE);\n        // first thread saves the result in accumulator\n        {\n            if (sext_i32_i64(local_tid_23709) == 0) {\n                x_acc_23722 = x_23724;\n            }\n        }\n        if (groups_per_segment_23699 == 1) {\n            // first thread in group saves final result to memory\n            {\n                if (local_tid_23709 == 0) {\n                    ((__global float *) mem_23322)[gtid_20264] = x_acc_23722;\n                }\n            }\n        } else {\n            int32_t old_counter_23732;\n            \n            // first thread in group saves group result to global memory\n            {\n                if (local_tid_23709 == 0) {\n                    ((__global\n                      float *) group_res_arr_mem_23704)[sext_i32_i64(virt_group_id_23719) *\n                                                        segred_group_sizze_20855] =\n                        x_acc_23722;\n                    mem_fence_global();\n                    old_counter_23732 =\n                        atomic_add_i32_global(&((volatile __global\n                                                 int *) mainzicounter_mem_23706)[sext_i32_i64(srem32(flat_segment_id_23720,\n                                                                                                     10240))],\n                                              (int) 1);\n                    ((__local bool *) sync_arr_mem_23715)[0] =\n                        old_counter_23732 == groups_per_segment_23699 - 1;\n                }\n            }\n            barrier(CLK_GLOBAL_MEM_FENCE | CLK_LOCAL_MEM_FENCE);\n            \n            bool is_last_group_23733;\n            \n            is_last_group_23733 = ((__local bool *) sync_arr_mem_23715)[0];\n            if (is_last_group_23733) {\n                if (local_tid_23709 == 0) {\n                    old_counter_23732 =\n       ",
                   "                 atomic_add_i32_global(&((volatile __global\n                                                 int *) mainzicounter_mem_23706)[sext_i32_i64(srem32(flat_segment_id_23720,\n                                                                                                     10240))],\n                                              (int) (0 -\n                                                     groups_per_segment_23699));\n                }\n                // read in the per-group-results\n                {\n                    int64_t read_per_thread_23734 =\n                            sdiv_up64(groups_per_segment_23699,\n                                      segred_group_sizze_20855);\n                    \n                    x_20859 = 0.0F;\n                    for (int64_t i_23735 = 0; i_23735 < read_per_thread_23734;\n                         i_23735++) {\n                        int64_t group_res_id_23736 =\n                                sext_i32_i64(local_tid_23709) *\n                                read_per_thread_23734 + i_23735;\n                        int64_t index_of_group_res_23737 =\n                                sext_i32_i64(flat_segment_id_23720) *\n                                groups_per_segment_23699 + group_res_id_23736;\n                        \n                        if (slt64(group_res_id_23736,\n                                  groups_per_segment_23699)) {\n                            x_20860 = ((__global\n                                        float *) group_res_arr_mem_23704)[index_of_group_res_23737 *\n                                                                          segred_group_sizze_20855];\n                            \n                            float res_20861;\n                            \n                            res_20861 = x_20859 + x_20860;\n                            x_20859 = res_20861;\n                        }\n                    }\n                }\n                ((__local\n                  float *) red_arr_mem_23",
                   "713)[sext_i32_i64(local_tid_23709)] =\n                    x_20859;\n                barrier(CLK_LOCAL_MEM_FENCE);\n                // reduce the per-group results\n                {\n                    int32_t offset_23738;\n                    int32_t skip_waves_23739;\n                    \n                    skip_waves_23739 = 1;\n                    \n                    float x_23724;\n                    float x_23725;\n                    \n                    offset_23738 = 0;\n                    // participating threads read initial accumulator\n                    {\n                        if (slt32(local_tid_23709,\n                                  sext_i64_i32(segred_group_sizze_20855))) {\n                            x_23724 = ((__local\n                                        float *) red_arr_mem_23713)[sext_i32_i64(local_tid_23709 +\n                                                                    offset_23738)];\n                        }\n                    }\n                    offset_23738 = 1;\n                    while (slt32(offset_23738, wave_sizze_23711)) {\n                        if (slt32(local_tid_23709 + offset_23738,\n                                  sext_i64_i32(segred_group_sizze_20855)) &&\n                            ((local_tid_23709 - squot32(local_tid_23709,\n                                                        wave_sizze_23711) *\n                              wave_sizze_23711) & (2 * offset_23738 - 1)) ==\n                            0) {\n                            // read array element\n                            {\n                                x_23725 = ((volatile __local\n                                            float *) red_arr_mem_23713)[sext_i32_i64(local_tid_23709 +\n                                                                        offset_23738)];\n                            }\n                            // apply reduction operation\n                            {\n                                float res_23726 = x_23724 + x_23",
                   "725;\n                                \n                                x_23724 = res_23726;\n                            }\n                            // write result of operation\n                            {\n                                ((volatile __local\n                                  float *) red_arr_mem_23713)[sext_i32_i64(local_tid_23709)] =\n                                    x_23724;\n                            }\n                        }\n                        offset_23738 *= 2;\n                    }\n                    while (slt32(skip_waves_23739,\n                                 squot32(sext_i64_i32(segred_group_sizze_20855) +\n                                         wave_sizze_23711 - 1,\n                                         wave_sizze_23711))) {\n                        barrier(CLK_LOCAL_MEM_FENCE);\n                        offset_23738 = skip_waves_23739 * wave_sizze_23711;\n                        if (slt32(local_tid_23709 + offset_23738,\n                                  sext_i64_i32(segred_group_sizze_20855)) &&\n                            ((local_tid_23709 - squot32(local_tid_23709,\n                                                        wave_sizze_23711) *\n                              wave_sizze_23711) == 0 &&\n                             (squot32(local_tid_23709, wave_sizze_23711) & (2 *\n                                                                            skip_waves_23739 -\n                                                                            1)) ==\n                             0)) {\n                            // read array element\n                            {\n                                x_23725 = ((__local\n                                            float *) red_arr_mem_23713)[sext_i32_i64(local_tid_23709 +\n                                                                        offset_23738)];\n                            }\n                            // apply reduction operation\n                            {\n          ",
                   "                      float res_23726 = x_23724 + x_23725;\n                                \n                                x_23724 = res_23726;\n                            }\n                            // write result of operation\n                            {\n                                ((__local\n                                  float *) red_arr_mem_23713)[sext_i32_i64(local_tid_23709)] =\n                                    x_23724;\n                            }\n                        }\n                        skip_waves_23739 *= 2;\n                    }\n                    // and back to memory with the final result\n                    {\n                        if (local_tid_23709 == 0) {\n                            ((__global float *) mem_23322)[gtid_20264] =\n                                x_23724;\n                        }\n                    }\n                }\n            }\n        }\n        barrier(CLK_GLOBAL_MEM_FENCE | CLK_LOCAL_MEM_FENCE);\n    }\n    \n  error_1:\n    return;\n    #undef segred_group_sizze_20855\n}\n__kernel void mainzisegred_nonseg_18847(__global int *global_failure,\n                                        __local volatile\n                                        int64_t *red_arr_mem_23505_backing_aligned_0,\n                                        __local volatile\n                                        int64_t *sync_arr_mem_23503_backing_aligned_1,\n                                        int64_t n_18078,\n                                        int64_t num_groups_18842, __global\n                                        unsigned char *swap_term_mem_23220,\n                                        __global\n                                        unsigned char *payments_mem_23221,\n                                        __global unsigned char *mem_23225,\n                                        __global\n                                        unsigned char *mainzicounter_mem_23493,\n                                        __global\n              ",
                   "                          unsigned char *group_res_arr_mem_23495,\n                                        int64_t num_threads_23497)\n{\n    #define segred_group_sizze_18840 (mainzisegred_group_sizze_18839)\n    \n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    __local volatile char *restrict red_arr_mem_23505_backing_1 =\n                          (__local volatile\n                           char *) red_arr_mem_23505_backing_aligned_0;\n    __local volatile char *restrict sync_arr_mem_23503_backing_0 =\n                          (__local volatile\n                           char *) sync_arr_mem_23503_backing_aligned_1;\n    \n    if (*global_failure >= 0)\n        return;\n    \n    int32_t global_tid_23498;\n    int32_t local_tid_23499;\n    int64_t group_sizze_23502;\n    int32_t wave_sizze_23501;\n    int32_t group_tid_23500;\n    \n    global_tid_23498 = get_global_id(0);\n    local_tid_23499 = get_local_id(0);\n    group_sizze_23502 = get_local_size(0);\n    wave_sizze_23501 = LOCKSTEP_WIDTH;\n    group_tid_23500 = get_group_id(0);\n    \n    int32_t phys_tid_18847;\n    \n    phys_tid_18847 = global_tid_23498;\n    \n    __local char *sync_arr_mem_23503;\n    \n    sync_arr_mem_23503 = (__local char *) sync_arr_mem_23503_backing_0;\n    \n    __local char *red_arr_mem_23505;\n    \n    red_arr_mem_23505 = (__local char *) red_arr_mem_23505_backing_1;\n    \n    int64_t dummy_18845;\n    \n    dummy_18845 = 0;\n    \n    int64_t gtid_18846;\n    \n    gtid_18846 = 0;\n    \n    float x_acc_23507;\n    int64_t chunk_sizze_23508;\n    \n    chunk_sizze_23508 = smin64(sdiv_up64(n_18078,\n                                         sext_i32_i64(sext_i64_i32(segred_group_sizze_18840 *\n                                         num_groups_18842))),\n                               sdiv_up64(n_18078 - sext_i32_i64(phys_tid_18847),\n                                         num_threads_23497));\n    \n    float x_18096;\n    float x_18097;\n    \n    // neutral-initialise the accumula",
                   "tors\n    {\n        x_acc_23507 = -INFINITY;\n    }\n    for (int64_t i_23512 = 0; i_23512 < chunk_sizze_23508; i_23512++) {\n        gtid_18846 = sext_i32_i64(phys_tid_18847) + num_threads_23497 * i_23512;\n        // apply map function\n        {\n            float x_18099 = ((__global\n                              float *) swap_term_mem_23220)[gtid_18846];\n            int64_t x_18100 = ((__global\n                                int64_t *) payments_mem_23221)[gtid_18846];\n            float res_18101 = sitofp_i64_f32(x_18100);\n            float res_18102 = x_18099 * res_18101;\n            \n            // save map-out results\n            { }\n            // load accumulator\n            {\n                x_18096 = x_acc_23507;\n            }\n            // load new values\n            {\n                x_18097 = res_18102;\n            }\n            // apply reduction operator\n            {\n                float res_18098 = fmax32(x_18096, x_18097);\n                \n                // store in accumulator\n                {\n                    x_acc_23507 = res_18098;\n                }\n            }\n        }\n    }\n    // to reduce current chunk, first store our result in memory\n    {\n        x_18096 = x_acc_23507;\n        ((__local float *) red_arr_mem_23505)[sext_i32_i64(local_tid_23499)] =\n            x_18096;\n    }\n    barrier(CLK_LOCAL_MEM_FENCE);\n    \n    int32_t offset_23513;\n    int32_t skip_waves_23514;\n    \n    skip_waves_23514 = 1;\n    \n    float x_23509;\n    float x_23510;\n    \n    offset_23513 = 0;\n    // participating threads read initial accumulator\n    {\n        if (slt32(local_tid_23499, sext_i64_i32(segred_group_sizze_18840))) {\n            x_23509 = ((__local\n                        float *) red_arr_mem_23505)[sext_i32_i64(local_tid_23499 +\n                                                    offset_23513)];\n        }\n    }\n    offset_23513 = 1;\n    while (slt32(offset_23513, wave_sizze_23501)) {\n        if (slt32(local_tid_23499 + offset_23513,\n               ",
                   "   sext_i64_i32(segred_group_sizze_18840)) && ((local_tid_23499 -\n                                                               squot32(local_tid_23499,\n                                                                       wave_sizze_23501) *\n                                                               wave_sizze_23501) &\n                                                              (2 *\n                                                               offset_23513 -\n                                                               1)) == 0) {\n            // read array element\n            {\n                x_23510 = ((volatile __local\n                            float *) red_arr_mem_23505)[sext_i32_i64(local_tid_23499 +\n                                                        offset_23513)];\n            }\n            // apply reduction operation\n            {\n                float res_23511 = fmax32(x_23509, x_23510);\n                \n                x_23509 = res_23511;\n            }\n            // write result of operation\n            {\n                ((volatile __local\n                  float *) red_arr_mem_23505)[sext_i32_i64(local_tid_23499)] =\n                    x_23509;\n            }\n        }\n        offset_23513 *= 2;\n    }\n    while (slt32(skip_waves_23514,\n                 squot32(sext_i64_i32(segred_group_sizze_18840) +\n                         wave_sizze_23501 - 1, wave_sizze_23501))) {\n        barrier(CLK_LOCAL_MEM_FENCE);\n        offset_23513 = skip_waves_23514 * wave_sizze_23501;\n        if (slt32(local_tid_23499 + offset_23513,\n                  sext_i64_i32(segred_group_sizze_18840)) && ((local_tid_23499 -\n                                                               squot32(local_tid_23499,\n                                                                       wave_sizze_23501) *\n                                                               wave_sizze_23501) ==\n                                                              0 &&\n                   ",
                   "                                           (squot32(local_tid_23499,\n                                                                       wave_sizze_23501) &\n                                                               (2 *\n                                                                skip_waves_23514 -\n                                                                1)) == 0)) {\n            // read array element\n            {\n                x_23510 = ((__local\n                            float *) red_arr_mem_23505)[sext_i32_i64(local_tid_23499 +\n                                                        offset_23513)];\n            }\n            // apply reduction operation\n            {\n                float res_23511 = fmax32(x_23509, x_23510);\n                \n                x_23509 = res_23511;\n            }\n            // write result of operation\n            {\n                ((__local\n                  float *) red_arr_mem_23505)[sext_i32_i64(local_tid_23499)] =\n                    x_23509;\n            }\n        }\n        skip_waves_23514 *= 2;\n    }\n    barrier(CLK_LOCAL_MEM_FENCE);\n    // first thread saves the result in accumulator\n    {\n        if (sext_i32_i64(local_tid_23499) == 0) {\n            x_acc_23507 = x_23509;\n        }\n    }\n    \n    int32_t old_counter_23515;\n    \n    // first thread in group saves group result to global memory\n    {\n        if (local_tid_23499 == 0) {\n            ((__global\n              float *) group_res_arr_mem_23495)[sext_i32_i64(group_tid_23500) *\n                                                segred_group_sizze_18840] =\n                x_acc_23507;\n            mem_fence_global();\n            old_counter_23515 = atomic_add_i32_global(&((volatile __global\n                                                         int *) mainzicounter_mem_23493)[0],\n                                                      (int) 1);\n            ((__local bool *) sync_arr_mem_23503)[0] = old_counter_23515 ==\n                num_groups_18842 ",
                   "- 1;\n        }\n    }\n    barrier(CLK_GLOBAL_MEM_FENCE | CLK_LOCAL_MEM_FENCE);\n    \n    bool is_last_group_23516;\n    \n    is_last_group_23516 = ((__local bool *) sync_arr_mem_23503)[0];\n    if (is_last_group_23516) {\n        if (local_tid_23499 == 0) {\n            old_counter_23515 = atomic_add_i32_global(&((volatile __global\n                                                         int *) mainzicounter_mem_23493)[0],\n                                                      (int) (0 -\n                                                             num_groups_18842));\n        }\n        // read in the per-group-results\n        {\n            int64_t read_per_thread_23517 = sdiv_up64(num_groups_18842,\n                                                      segred_group_sizze_18840);\n            \n            x_18096 = -INFINITY;\n            for (int64_t i_23518 = 0; i_23518 < read_per_thread_23517;\n                 i_23518++) {\n                int64_t group_res_id_23519 = sext_i32_i64(local_tid_23499) *\n                        read_per_thread_23517 + i_23518;\n                int64_t index_of_group_res_23520 = group_res_id_23519;\n                \n                if (slt64(group_res_id_23519, num_groups_18842)) {\n                    x_18097 = ((__global\n                                float *) group_res_arr_mem_23495)[index_of_group_res_23520 *\n                                                                  segred_group_sizze_18840];\n                    \n                    float res_18098;\n                    \n                    res_18098 = fmax32(x_18096, x_18097);\n                    x_18096 = res_18098;\n                }\n            }\n        }\n        ((__local float *) red_arr_mem_23505)[sext_i32_i64(local_tid_23499)] =\n            x_18096;\n        barrier(CLK_LOCAL_MEM_FENCE);\n        // reduce the per-group results\n        {\n            int32_t offset_23521;\n            int32_t skip_waves_23522;\n            \n            skip_waves_23522 = 1;\n            \n            floa",
                   "t x_23509;\n            float x_23510;\n            \n            offset_23521 = 0;\n            // participating threads read initial accumulator\n            {\n                if (slt32(local_tid_23499,\n                          sext_i64_i32(segred_group_sizze_18840))) {\n                    x_23509 = ((__local\n                                float *) red_arr_mem_23505)[sext_i32_i64(local_tid_23499 +\n                                                            offset_23521)];\n                }\n            }\n            offset_23521 = 1;\n            while (slt32(offset_23521, wave_sizze_23501)) {\n                if (slt32(local_tid_23499 + offset_23521,\n                          sext_i64_i32(segred_group_sizze_18840)) &&\n                    ((local_tid_23499 - squot32(local_tid_23499,\n                                                wave_sizze_23501) *\n                      wave_sizze_23501) & (2 * offset_23521 - 1)) == 0) {\n                    // read array element\n                    {\n                        x_23510 = ((volatile __local\n                                    float *) red_arr_mem_23505)[sext_i32_i64(local_tid_23499 +\n                                                                offset_23521)];\n                    }\n                    // apply reduction operation\n                    {\n                        float res_23511 = fmax32(x_23509, x_23510);\n                        \n                        x_23509 = res_23511;\n                    }\n                    // write result of operation\n                    {\n                        ((volatile __local\n                          float *) red_arr_mem_23505)[sext_i32_i64(local_tid_23499)] =\n                            x_23509;\n                    }\n                }\n                offset_23521 *= 2;\n            }\n            while (slt32(skip_waves_23522,\n                         squot32(sext_i64_i32(segred_group_sizze_18840) +\n                                 wave_sizze_23501 - 1, wave_sizze_23501))) {\n  ",
                   "              barrier(CLK_LOCAL_MEM_FENCE);\n                offset_23521 = skip_waves_23522 * wave_sizze_23501;\n                if (slt32(local_tid_23499 + offset_23521,\n                          sext_i64_i32(segred_group_sizze_18840)) &&\n                    ((local_tid_23499 - squot32(local_tid_23499,\n                                                wave_sizze_23501) *\n                      wave_sizze_23501) == 0 && (squot32(local_tid_23499,\n                                                         wave_sizze_23501) &\n                                                 (2 * skip_waves_23522 - 1)) ==\n                     0)) {\n                    // read array element\n                    {\n                        x_23510 = ((__local\n                                    float *) red_arr_mem_23505)[sext_i32_i64(local_tid_23499 +\n                                                                offset_23521)];\n                    }\n                    // apply reduction operation\n                    {\n                        float res_23511 = fmax32(x_23509, x_23510);\n                        \n                        x_23509 = res_23511;\n                    }\n                    // write result of operation\n                    {\n                        ((__local\n                          float *) red_arr_mem_23505)[sext_i32_i64(local_tid_23499)] =\n                            x_23509;\n                    }\n                }\n                skip_waves_23522 *= 2;\n            }\n            // and back to memory with the final result\n            {\n                if (local_tid_23499 == 0) {\n                    ((__global float *) mem_23225)[0] = x_23509;\n                }\n            }\n        }\n    }\n    \n  error_1:\n    return;\n    #undef segred_group_sizze_18840\n}\n__kernel void mainzisegred_nonseg_19659(__global int *global_failure,\n                                        int failure_is_an_option, __global\n                                        int64_t *global_failure_args,\n    ",
                   "                                    __local volatile\n                                        int64_t *red_arr_mem_23635_backing_aligned_0,\n                                        __local volatile\n                                        int64_t *sync_arr_mem_23633_backing_aligned_1,\n                                        int64_t n_18078, int64_t paths_18081,\n                                        int64_t steps_18082, float a_18086,\n                                        float b_18087, float sigma_18088,\n                                        float x_18106, float x_18108,\n                                        float y_18110, float y_18111,\n                                        float sims_per_year_18188,\n                                        float res_18265,\n                                        int64_t num_groups_19662, __global\n                                        unsigned char *res_mem_23272, __global\n                                        unsigned char *res_mem_23273, __global\n                                        unsigned char *res_mem_23274, __global\n                                        unsigned char *res_mem_23275, __global\n                                        unsigned char *mem_23303, __global\n                                        unsigned char *mem_23306, __global\n                                        unsigned char *mem_23308, __global\n                                        unsigned char *mainzicounter_mem_23623,\n                                        __global\n                                        unsigned char *group_res_arr_mem_23625,\n                                        int64_t num_threads_23627)\n{\n    #define segred_group_sizze_19661 (mainzisegred_group_sizze_19650)\n    \n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    __local volatile char *restrict red_arr_mem_23635_backing_1 =\n                          (__local volatile\n                           char *) red_arr_mem_23635_bac",
                   "king_aligned_0;\n    __local volatile char *restrict sync_arr_mem_23633_backing_0 =\n                          (__local volatile\n                           char *) sync_arr_mem_23633_backing_aligned_1;\n    volatile __local bool local_failure;\n    \n    if (failure_is_an_option) {\n        int failed = *global_failure >= 0;\n        \n        if (failed)\n            return;\n    }\n    local_failure = false;\n    barrier(CLK_LOCAL_MEM_FENCE);\n    \n    int32_t global_tid_23628;\n    int32_t local_tid_23629;\n    int64_t group_sizze_23632;\n    int32_t wave_sizze_23631;\n    int32_t group_tid_23630;\n    \n    global_tid_23628 = get_global_id(0);\n    local_tid_23629 = get_local_id(0);\n    group_sizze_23632 = get_local_size(0);\n    wave_sizze_23631 = LOCKSTEP_WIDTH;\n    group_tid_23630 = get_group_id(0);\n    \n    int32_t phys_tid_19659;\n    \n    phys_tid_19659 = global_tid_23628;\n    \n    __local char *sync_arr_mem_23633;\n    \n    sync_arr_mem_23633 = (__local char *) sync_arr_mem_23633_backing_0;\n    \n    __local char *red_arr_mem_23635;\n    \n    red_arr_mem_23635 = (__local char *) red_arr_mem_23635_backing_1;\n    \n    int64_t dummy_19657;\n    \n    dummy_19657 = 0;\n    \n    int64_t gtid_19658;\n    \n    gtid_19658 = 0;\n    \n    float x_acc_23637;\n    int64_t chunk_sizze_23638;\n    \n    chunk_sizze_23638 = smin64(sdiv_up64(steps_18082,\n                                         sext_i32_i64(sext_i64_i32(segred_group_sizze_19661 *\n                                         num_groups_19662))),\n                               sdiv_up64(steps_18082 -\n                                         sext_i32_i64(phys_tid_19659),\n                                         num_threads_23627));\n    \n    float x_19666;\n    float x_19667;\n    \n    // neutral-initialise the accumulators\n    {\n        x_acc_23637 = 0.0F;\n    }\n    for (int64_t i_23642 = 0; i_23642 < chunk_sizze_23638; i_23642++) {\n        gtid_19658 = sext_i32_i64(phys_tid_19659) + num_threads_23627 * i_23642;\n        // apply map function\n   ",
                   "     {\n            int64_t index_primexp_23127 = add64(1, gtid_19658);\n            float res_19672 = sitofp_i64_f32(index_primexp_23127);\n            float res_19673 = res_19672 / sims_per_year_18188;\n            float res_19674;\n            float redout_23192 = 0.0F;\n            \n            for (int64_t i_23193 = 0; i_23193 < paths_18081; i_23193++) {\n                float x_19678 = ((__global float *) mem_23303)[gtid_19658 *\n                                                               paths_18081 +\n                                                               i_23193];\n                float res_19680;\n                float redout_23194 = 0.0F;\n                \n                for (int64_t i_23195 = 0; i_23195 < n_18078; i_23195++) {\n                    int64_t x_19686 = ((__global\n                                        int64_t *) res_mem_23274)[i_23195];\n                    float x_19687 = ((__global float *) res_mem_23275)[i_23195];\n                    int64_t i64_arg_19688 = sub64(x_19686, 1);\n                    float res_19689 = sitofp_i64_f32(i64_arg_19688);\n                    float y_19690 = x_19687 * res_19689;\n                    bool cond_19691 = y_19690 < res_19673;\n                    float ceil_arg_19692 = res_19673 / x_19687;\n                    float res_19693;\n                    \n                    res_19693 = futrts_ceil32(ceil_arg_19692);\n                    \n                    int64_t res_19694 = fptosi_f32_i64(res_19693);\n                    int64_t remaining_19695 = sub64(x_19686, res_19694);\n                    float res_19696;\n                    \n                    if (cond_19691) {\n                        res_19696 = 0.0F;\n                    } else {\n                        float x_19684 = ((__global\n                                          float *) res_mem_23272)[i_23195];\n                        float x_19685 = ((__global\n                                          float *) res_mem_23273)[i_23195];\n                        float ",
                   "nextpayment_19697 = x_19687 * res_19693;\n                        bool bounds_invalid_upwards_19698 =\n                             slt64(remaining_19695, 1);\n                        bool valid_19699 = !bounds_invalid_upwards_19698;\n                        bool range_valid_c_19700;\n                        \n                        if (!valid_19699) {\n                            {\n                                if (atomic_cmpxchg_i32_global(global_failure,\n                                                              -1, 8) == -1) {\n                                    global_failure_args[0] = 1;\n                                    global_failure_args[1] = 2;\n                                    global_failure_args[2] = remaining_19695;\n                                    ;\n                                }\n                                local_failure = true;\n                                goto error_0;\n                            }\n                        }\n                        \n                        float y_19702 = nextpayment_19697 - res_19673;\n                        float negate_arg_19703 = a_18086 * y_19702;\n                        float exp_arg_19704 = 0.0F - negate_arg_19703;\n                        float res_19705 = fpow32(2.7182817F, exp_arg_19704);\n                        float x_19706 = 1.0F - res_19705;\n                        float B_19707 = x_19706 / a_18086;\n                        float x_19708 = B_19707 - nextpayment_19697;\n                        float x_19709 = res_19673 + x_19708;\n                        float x_19710 = fpow32(a_18086, 2.0F);\n                        float x_19711 = b_18087 * x_19710;\n                        float x_19712 = fpow32(sigma_18088, 2.0F);\n                        float y_19713 = x_19712 / 2.0F;\n                        float y_19714 = x_19711 - y_19713;\n                        float x_19715 = x_19709 * y_19714;\n                        float A1_19716 = x_19715 / x_19710;\n                        float y_19717 = fpow32(B",
                   "_19707, 2.0F);\n                        float x_19718 = x_19712 * y_19717;\n                        float y_19719 = 4.0F * a_18086;\n                        float A2_19720 = x_19718 / y_19719;\n                        float exp_arg_19721 = A1_19716 - A2_19720;\n                        float res_19722 = fpow32(2.7182817F, exp_arg_19721);\n                        float negate_arg_19723 = x_19678 * B_19707;\n                        float exp_arg_19724 = 0.0F - negate_arg_19723;\n                        float res_19725 = fpow32(2.7182817F, exp_arg_19724);\n                        float res_19726 = res_19722 * res_19725;\n                        bool y_19727 = slt64(0, remaining_19695);\n                        bool index_certs_19728;\n                        \n                        if (!y_19727) {\n                            {\n                                if (atomic_cmpxchg_i32_global(global_failure,\n                                                              -1, 9) == -1) {\n                                    global_failure_args[0] = 0;\n                                    global_failure_args[1] = remaining_19695;\n                                    ;\n                                }\n                                local_failure = true;\n                                goto error_0;\n                            }\n                        }\n                        \n                        float binop_y_19729 = sitofp_i64_f32(remaining_19695);\n                        float binop_y_19730 = x_19687 * binop_y_19729;\n                        float index_primexp_19731 = nextpayment_19697 +\n                              binop_y_19730;\n                        float y_19732 = index_primexp_19731 - res_19673;\n                        float negate_arg_19733 = a_18086 * y_19732;\n                        float exp_arg_19734 = 0.0F - negate_arg_19733;\n                        float res_19735 = fpow32(2.7182817F, exp_arg_19734);\n                        float x_19736 = 1.0F - res_19735;\n           ",
                   "             float B_19737 = x_19736 / a_18086;\n                        float x_19738 = B_19737 - index_primexp_19731;\n                        float x_19739 = res_19673 + x_19738;\n                        float x_19740 = y_19714 * x_19739;\n                        float A1_19741 = x_19740 / x_19710;\n                        float y_19742 = fpow32(B_19737, 2.0F);\n                        float x_19743 = x_19712 * y_19742;\n                        float A2_19744 = x_19743 / y_19719;\n                        float exp_arg_19745 = A1_19741 - A2_19744;\n                        float res_19746 = fpow32(2.7182817F, exp_arg_19745);\n                        float negate_arg_19747 = x_19678 * B_19737;\n                        float exp_arg_19748 = 0.0F - negate_arg_19747;\n                        float res_19749 = fpow32(2.7182817F, exp_arg_19748);\n                        float res_19750 = res_19746 * res_19749;\n                        float res_19751;\n                        float redout_23124 = 0.0F;\n                        \n                        for (int64_t i_23125 = 0; i_23125 < remaining_19695;\n                             i_23125++) {\n                            int64_t index_primexp_23159 = add64(1, i_23125);\n                            float res_19756 =\n                                  sitofp_i64_f32(index_primexp_23159);\n                            float res_19757 = x_19687 * res_19756;\n                            float res_19758 = nextpayment_19697 + res_19757;\n                            float y_19759 = res_19758 - res_19673;\n                            float negate_arg_19760 = a_18086 * y_19759;\n                            float exp_arg_19761 = 0.0F - negate_arg_19760;\n                            float res_19762 = fpow32(2.7182817F, exp_arg_19761);\n                            float x_19763 = 1.0F - res_19762;\n                            float B_19764 = x_19763 / a_18086;\n                            float x_19765 = B_19764 - res_19758;\n                            float x",
                   "_19766 = res_19673 + x_19765;\n                            float x_19767 = y_19714 * x_19766;\n                            float A1_19768 = x_19767 / x_19710;\n                            float y_19769 = fpow32(B_19764, 2.0F);\n                            float x_19770 = x_19712 * y_19769;\n                            float A2_19771 = x_19770 / y_19719;\n                            float exp_arg_19772 = A1_19768 - A2_19771;\n                            float res_19773 = fpow32(2.7182817F, exp_arg_19772);\n                            float negate_arg_19774 = x_19678 * B_19764;\n                            float exp_arg_19775 = 0.0F - negate_arg_19774;\n                            float res_19776 = fpow32(2.7182817F, exp_arg_19775);\n                            float res_19777 = res_19773 * res_19776;\n                            float res_19754 = res_19777 + redout_23124;\n                            float redout_tmp_23645 = res_19754;\n                            \n                            redout_23124 = redout_tmp_23645;\n                        }\n                        res_19751 = redout_23124;\n                        \n                        float x_19778 = res_19726 - res_19750;\n                        float x_19779 = x_19684 * x_19687;\n                        float y_19780 = res_19751 * x_19779;\n                        float y_19781 = x_19778 - y_19780;\n                        float res_19782 = x_19685 * y_19781;\n                        \n                        res_19696 = res_19782;\n                    }\n                    \n                    float res_19683 = res_19696 + redout_23194;\n                    float redout_tmp_23644 = res_19683;\n                    \n                    redout_23194 = redout_tmp_23644;\n                }\n                res_19680 = redout_23194;\n                \n                float res_19783 = fmax32(0.0F, res_19680);\n                float res_19677 = res_19783 + redout_23192;\n                float redout_tmp_23643 = res_19677;\n             ",
                   "   \n                redout_23192 = redout_tmp_23643;\n            }\n            res_19674 = redout_23192;\n            \n            float res_19784 = res_19674 / res_18265;\n            float negate_arg_19785 = a_18086 * res_19673;\n            float exp_arg_19786 = 0.0F - negate_arg_19785;\n            float res_19787 = fpow32(2.7182817F, exp_arg_19786);\n            float x_19788 = 1.0F - res_19787;\n            float B_19789 = x_19788 / a_18086;\n            float x_19790 = B_19789 - res_19673;\n            float x_19791 = y_18110 * x_19790;\n            float A1_19792 = x_19791 / x_18106;\n            float y_19793 = fpow32(B_19789, 2.0F);\n            float x_19794 = x_18108 * y_19793;\n            float A2_19795 = x_19794 / y_18111;\n            float exp_arg_19796 = A1_19792 - A2_19795;\n            float res_19797 = fpow32(2.7182817F, exp_arg_19796);\n            float negate_arg_19798 = 5.0e-2F * B_19789;\n            float exp_arg_19799 = 0.0F - negate_arg_19798;\n            float res_19800 = fpow32(2.7182817F, exp_arg_19799);\n            float res_19801 = res_19797 * res_19800;\n            float res_19802 = res_19784 * res_19801;\n            \n            // save map-out results\n            {\n                ((__global float *) mem_23308)[dummy_19657 * steps_18082 +\n                                               gtid_19658] = res_19784;\n            }\n            // load accumulator\n            {\n                x_19666 = x_acc_23637;\n            }\n            // load new values\n            {\n                x_19667 = res_19802;\n            }\n            // apply reduction operator\n            {\n                float res_19668 = x_19666 + x_19667;\n                \n                // store in accumulator\n                {\n                    x_acc_23637 = res_19668;\n                }\n            }\n        }\n    }\n    // to reduce current chunk, first store our result in memory\n    {\n        x_19666 = x_acc_23637;\n        ((__local float *) red_arr_mem_23635)[sext_i32_i64(loc",
                   "al_tid_23629)] =\n            x_19666;\n    }\n    \n  error_0:\n    barrier(CLK_LOCAL_MEM_FENCE);\n    if (local_failure)\n        return;\n    barrier(CLK_LOCAL_MEM_FENCE);\n    \n    int32_t offset_23646;\n    int32_t skip_waves_23647;\n    \n    skip_waves_23647 = 1;\n    \n    float x_23639;\n    float x_23640;\n    \n    offset_23646 = 0;\n    // participating threads read initial accumulator\n    {\n        if (slt32(local_tid_23629, sext_i64_i32(segred_group_sizze_19661))) {\n            x_23639 = ((__local\n                        float *) red_arr_mem_23635)[sext_i32_i64(local_tid_23629 +\n                                                    offset_23646)];\n        }\n    }\n    offset_23646 = 1;\n    while (slt32(offset_23646, wave_sizze_23631)) {\n        if (slt32(local_tid_23629 + offset_23646,\n                  sext_i64_i32(segred_group_sizze_19661)) && ((local_tid_23629 -\n                                                               squot32(local_tid_23629,\n                                                                       wave_sizze_23631) *\n                                                               wave_sizze_23631) &\n                                                              (2 *\n                                                               offset_23646 -\n                                                               1)) == 0) {\n            // read array element\n            {\n                x_23640 = ((volatile __local\n                            float *) red_arr_mem_23635)[sext_i32_i64(local_tid_23629 +\n                                                        offset_23646)];\n            }\n            // apply reduction operation\n            {\n                float res_23641 = x_23639 + x_23640;\n                \n                x_23639 = res_23641;\n            }\n            // write result of operation\n            {\n                ((volatile __local\n                  float *) red_arr_mem_23635)[sext_i32_i64(local_tid_23629)] =\n                    x_23639;\n       ",
                   "     }\n        }\n        offset_23646 *= 2;\n    }\n    while (slt32(skip_waves_23647,\n                 squot32(sext_i64_i32(segred_group_sizze_19661) +\n                         wave_sizze_23631 - 1, wave_sizze_23631))) {\n        barrier(CLK_LOCAL_MEM_FENCE);\n        offset_23646 = skip_waves_23647 * wave_sizze_23631;\n        if (slt32(local_tid_23629 + offset_23646,\n                  sext_i64_i32(segred_group_sizze_19661)) && ((local_tid_23629 -\n                                                               squot32(local_tid_23629,\n                                                                       wave_sizze_23631) *\n                                                               wave_sizze_23631) ==\n                                                              0 &&\n                                                              (squot32(local_tid_23629,\n                                                                       wave_sizze_23631) &\n                                                               (2 *\n                                                                skip_waves_23647 -\n                                                                1)) == 0)) {\n            // read array element\n            {\n                x_23640 = ((__local\n                            float *) red_arr_mem_23635)[sext_i32_i64(local_tid_23629 +\n                                                        offset_23646)];\n            }\n            // apply reduction operation\n            {\n                float res_23641 = x_23639 + x_23640;\n                \n                x_23639 = res_23641;\n            }\n            // write result of operation\n            {\n                ((__local\n                  float *) red_arr_mem_23635)[sext_i32_i64(local_tid_23629)] =\n                    x_23639;\n            }\n        }\n        skip_waves_23647 *= 2;\n    }\n    barrier(CLK_LOCAL_MEM_FENCE);\n    // first thread saves the result in accumulator\n    {\n        if (sext_i32_i64(local_tid_2362",
                   "9) == 0) {\n            x_acc_23637 = x_23639;\n        }\n    }\n    \n    int32_t old_counter_23648;\n    \n    // first thread in group saves group result to global memory\n    {\n        if (local_tid_23629 == 0) {\n            ((__global\n              float *) group_res_arr_mem_23625)[sext_i32_i64(group_tid_23630) *\n                                                segred_group_sizze_19661] =\n                x_acc_23637;\n            mem_fence_global();\n            old_counter_23648 = atomic_add_i32_global(&((volatile __global\n                                                         int *) mainzicounter_mem_23623)[0],\n                                                      (int) 1);\n            ((__local bool *) sync_arr_mem_23633)[0] = old_counter_23648 ==\n                num_groups_19662 - 1;\n        }\n    }\n    barrier(CLK_GLOBAL_MEM_FENCE | CLK_LOCAL_MEM_FENCE);\n    \n    bool is_last_group_23649;\n    \n    is_last_group_23649 = ((__local bool *) sync_arr_mem_23633)[0];\n    if (is_last_group_23649) {\n        if (local_tid_23629 == 0) {\n            old_counter_23648 = atomic_add_i32_global(&((volatile __global\n                                                         int *) mainzicounter_mem_23623)[0],\n                                                      (int) (0 -\n                                                             num_groups_19662));\n        }\n        // read in the per-group-results\n        {\n            int64_t read_per_thread_23650 = sdiv_up64(num_groups_19662,\n                                                      segred_group_sizze_19661);\n            \n            x_19666 = 0.0F;\n            for (int64_t i_23651 = 0; i_23651 < read_per_thread_23650;\n                 i_23651++) {\n                int64_t group_res_id_23652 = sext_i32_i64(local_tid_23629) *\n                        read_per_thread_23650 + i_23651;\n                int64_t index_of_group_res_23653 = group_res_id_23652;\n                \n                if (slt64(group_res_id_23652, num_groups_19662))",
                   " {\n                    x_19667 = ((__global\n                                float *) group_res_arr_mem_23625)[index_of_group_res_23653 *\n                                                                  segred_group_sizze_19661];\n                    \n                    float res_19668;\n                    \n                    res_19668 = x_19666 + x_19667;\n                    x_19666 = res_19668;\n                }\n            }\n        }\n        ((__local float *) red_arr_mem_23635)[sext_i32_i64(local_tid_23629)] =\n            x_19666;\n        barrier(CLK_LOCAL_MEM_FENCE);\n        // reduce the per-group results\n        {\n            int32_t offset_23654;\n            int32_t skip_waves_23655;\n            \n            skip_waves_23655 = 1;\n            \n            float x_23639;\n            float x_23640;\n            \n            offset_23654 = 0;\n            // participating threads read initial accumulator\n            {\n                if (slt32(local_tid_23629,\n                          sext_i64_i32(segred_group_sizze_19661))) {\n                    x_23639 = ((__local\n                                float *) red_arr_mem_23635)[sext_i32_i64(local_tid_23629 +\n                                                            offset_23654)];\n                }\n            }\n            offset_23654 = 1;\n            while (slt32(offset_23654, wave_sizze_23631)) {\n                if (slt32(local_tid_23629 + offset_23654,\n                          sext_i64_i32(segred_group_sizze_19661)) &&\n                    ((local_tid_23629 - squot32(local_tid_23629,\n                                                wave_sizze_23631) *\n                      wave_sizze_23631) & (2 * offset_23654 - 1)) == 0) {\n                    // read array element\n                    {\n                        x_23640 = ((volatile __local\n                                    float *) red_arr_mem_23635)[sext_i32_i64(local_tid_23629 +\n                                                                offset_23654)",
                   "];\n                    }\n                    // apply reduction operation\n                    {\n                        float res_23641 = x_23639 + x_23640;\n                        \n                        x_23639 = res_23641;\n                    }\n                    // write result of operation\n                    {\n                        ((volatile __local\n                          float *) red_arr_mem_23635)[sext_i32_i64(local_tid_23629)] =\n                            x_23639;\n                    }\n                }\n                offset_23654 *= 2;\n            }\n            while (slt32(skip_waves_23655,\n                         squot32(sext_i64_i32(segred_group_sizze_19661) +\n                                 wave_sizze_23631 - 1, wave_sizze_23631))) {\n                barrier(CLK_LOCAL_MEM_FENCE);\n                offset_23654 = skip_waves_23655 * wave_sizze_23631;\n                if (slt32(local_tid_23629 + offset_23654,\n                          sext_i64_i32(segred_group_sizze_19661)) &&\n                    ((local_tid_23629 - squot32(local_tid_23629,\n                                                wave_sizze_23631) *\n                      wave_sizze_23631) == 0 && (squot32(local_tid_23629,\n                                                         wave_sizze_23631) &\n                                                 (2 * skip_waves_23655 - 1)) ==\n                     0)) {\n                    // read array element\n                    {\n                        x_23640 = ((__local\n                                    float *) red_arr_mem_23635)[sext_i32_i64(local_tid_23629 +\n                                                                offset_23654)];\n                    }\n                    // apply reduction operation\n                    {\n                        float res_23641 = x_23639 + x_23640;\n                        \n                        x_23639 = res_23641;\n                    }\n                    // write result of operation\n                    ",
                   "{\n                        ((__local\n                          float *) red_arr_mem_23635)[sext_i32_i64(local_tid_23629)] =\n                            x_23639;\n                    }\n                }\n                skip_waves_23655 *= 2;\n            }\n            // and back to memory with the final result\n            {\n                if (local_tid_23629 == 0) {\n                    ((__global float *) mem_23306)[0] = x_23639;\n                }\n            }\n        }\n    }\n    \n  error_1:\n    return;\n    #undef segred_group_sizze_19661\n}\n__kernel void mainzisegred_nonseg_20557(__global int *global_failure,\n                                        __local volatile\n                                        int64_t *red_arr_mem_23759_backing_aligned_0,\n                                        __local volatile\n                                        int64_t *sync_arr_mem_23757_backing_aligned_1,\n                                        int64_t steps_18082,\n                                        int64_t num_groups_21000, __global\n                                        unsigned char *res_map_acc_mem_23330,\n                                        __global unsigned char *mem_23334,\n                                        __global\n                                        unsigned char *mainzicounter_mem_23747,\n                                        __global\n                                        unsigned char *group_res_arr_mem_23749,\n                                        int64_t num_threads_23751)\n{\n    #define segred_group_sizze_20999 (mainzisegred_group_sizze_20549)\n    \n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    __local volatile char *restrict red_arr_mem_23759_backing_1 =\n                          (__local volatile\n                           char *) red_arr_mem_23759_backing_aligned_0;\n    __local volatile char *restrict sync_arr_mem_23757_backing_0 =\n                          (__local volatile\n                       ",
                   "    char *) sync_arr_mem_23757_backing_aligned_1;\n    \n    if (*global_failure >= 0)\n        return;\n    \n    int32_t global_tid_23752;\n    int32_t local_tid_23753;\n    int64_t group_sizze_23756;\n    int32_t wave_sizze_23755;\n    int32_t group_tid_23754;\n    \n    global_tid_23752 = get_global_id(0);\n    local_tid_23753 = get_local_id(0);\n    group_sizze_23756 = get_local_size(0);\n    wave_sizze_23755 = LOCKSTEP_WIDTH;\n    group_tid_23754 = get_group_id(0);\n    \n    int32_t phys_tid_20557;\n    \n    phys_tid_20557 = global_tid_23752;\n    \n    __local char *sync_arr_mem_23757;\n    \n    sync_arr_mem_23757 = (__local char *) sync_arr_mem_23757_backing_0;\n    \n    __local char *red_arr_mem_23759;\n    \n    red_arr_mem_23759 = (__local char *) red_arr_mem_23759_backing_1;\n    \n    int64_t dummy_20555;\n    \n    dummy_20555 = 0;\n    \n    int64_t gtid_20556;\n    \n    gtid_20556 = 0;\n    \n    float x_acc_23761;\n    int64_t chunk_sizze_23762;\n    \n    chunk_sizze_23762 = smin64(sdiv_up64(steps_18082,\n                                         sext_i32_i64(sext_i64_i32(segred_group_sizze_20999 *\n                                         num_groups_21000))),\n                               sdiv_up64(steps_18082 -\n                                         sext_i32_i64(phys_tid_20557),\n                                         num_threads_23751));\n    \n    float x_21003;\n    float x_21004;\n    \n    // neutral-initialise the accumulators\n    {\n        x_acc_23761 = 0.0F;\n    }\n    for (int64_t i_23766 = 0; i_23766 < chunk_sizze_23762; i_23766++) {\n        gtid_20556 = sext_i32_i64(phys_tid_20557) + num_threads_23751 * i_23766;\n        // apply map function\n        {\n            float x_21006 = ((__global\n                              float *) res_map_acc_mem_23330)[gtid_20556];\n            \n            // save map-out results\n            { }\n            // load accumulator\n            {\n                x_21003 = x_acc_23761;\n            }\n            // load new values\n            {\n      ",
                   "          x_21004 = x_21006;\n            }\n            // apply reduction operator\n            {\n                float res_21005 = x_21003 + x_21004;\n                \n                // store in accumulator\n                {\n                    x_acc_23761 = res_21005;\n                }\n            }\n        }\n    }\n    // to reduce current chunk, first store our result in memory\n    {\n        x_21003 = x_acc_23761;\n        ((__local float *) red_arr_mem_23759)[sext_i32_i64(local_tid_23753)] =\n            x_21003;\n    }\n    barrier(CLK_LOCAL_MEM_FENCE);\n    \n    int32_t offset_23767;\n    int32_t skip_waves_23768;\n    \n    skip_waves_23768 = 1;\n    \n    float x_23763;\n    float x_23764;\n    \n    offset_23767 = 0;\n    // participating threads read initial accumulator\n    {\n        if (slt32(local_tid_23753, sext_i64_i32(segred_group_sizze_20999))) {\n            x_23763 = ((__local\n                        float *) red_arr_mem_23759)[sext_i32_i64(local_tid_23753 +\n                                                    offset_23767)];\n        }\n    }\n    offset_23767 = 1;\n    while (slt32(offset_23767, wave_sizze_23755)) {\n        if (slt32(local_tid_23753 + offset_23767,\n                  sext_i64_i32(segred_group_sizze_20999)) && ((local_tid_23753 -\n                                                               squot32(local_tid_23753,\n                                                                       wave_sizze_23755) *\n                                                               wave_sizze_23755) &\n                                                              (2 *\n                                                               offset_23767 -\n                                                               1)) == 0) {\n            // read array element\n            {\n                x_23764 = ((volatile __local\n                            float *) red_arr_mem_23759)[sext_i32_i64(local_tid_23753 +\n                                                        offset_23767)];\n  ",
                   "          }\n            // apply reduction operation\n            {\n                float res_23765 = x_23763 + x_23764;\n                \n                x_23763 = res_23765;\n            }\n            // write result of operation\n            {\n                ((volatile __local\n                  float *) red_arr_mem_23759)[sext_i32_i64(local_tid_23753)] =\n                    x_23763;\n            }\n        }\n        offset_23767 *= 2;\n    }\n    while (slt32(skip_waves_23768,\n                 squot32(sext_i64_i32(segred_group_sizze_20999) +\n                         wave_sizze_23755 - 1, wave_sizze_23755))) {\n        barrier(CLK_LOCAL_MEM_FENCE);\n        offset_23767 = skip_waves_23768 * wave_sizze_23755;\n        if (slt32(local_tid_23753 + offset_23767,\n                  sext_i64_i32(segred_group_sizze_20999)) && ((local_tid_23753 -\n                                                               squot32(local_tid_23753,\n                                                                       wave_sizze_23755) *\n                                                               wave_sizze_23755) ==\n                                                              0 &&\n                                                              (squot32(local_tid_23753,\n                                                                       wave_sizze_23755) &\n                                                               (2 *\n                                                                skip_waves_23768 -\n                                                                1)) == 0)) {\n            // read array element\n            {\n                x_23764 = ((__local\n                            float *) red_arr_mem_23759)[sext_i32_i64(local_tid_23753 +\n                                                        offset_23767)];\n            }\n            // apply reduction operation\n            {\n                float res_23765 = x_23763 + x_23764;\n                \n                x_23763 = res_23765;\n  ",
                   "          }\n            // write result of operation\n            {\n                ((__local\n                  float *) red_arr_mem_23759)[sext_i32_i64(local_tid_23753)] =\n                    x_23763;\n            }\n        }\n        skip_waves_23768 *= 2;\n    }\n    barrier(CLK_LOCAL_MEM_FENCE);\n    // first thread saves the result in accumulator\n    {\n        if (sext_i32_i64(local_tid_23753) == 0) {\n            x_acc_23761 = x_23763;\n        }\n    }\n    \n    int32_t old_counter_23769;\n    \n    // first thread in group saves group result to global memory\n    {\n        if (local_tid_23753 == 0) {\n            ((__global\n              float *) group_res_arr_mem_23749)[sext_i32_i64(group_tid_23754) *\n                                                segred_group_sizze_20999] =\n                x_acc_23761;\n            mem_fence_global();\n            old_counter_23769 = atomic_add_i32_global(&((volatile __global\n                                                         int *) mainzicounter_mem_23747)[0],\n                                                      (int) 1);\n            ((__local bool *) sync_arr_mem_23757)[0] = old_counter_23769 ==\n                num_groups_21000 - 1;\n        }\n    }\n    barrier(CLK_GLOBAL_MEM_FENCE | CLK_LOCAL_MEM_FENCE);\n    \n    bool is_last_group_23770;\n    \n    is_last_group_23770 = ((__local bool *) sync_arr_mem_23757)[0];\n    if (is_last_group_23770) {\n        if (local_tid_23753 == 0) {\n            old_counter_23769 = atomic_add_i32_global(&((volatile __global\n                                                         int *) mainzicounter_mem_23747)[0],\n                                                      (int) (0 -\n                                                             num_groups_21000));\n        }\n        // read in the per-group-results\n        {\n            int64_t read_per_thread_23771 = sdiv_up64(num_groups_21000,\n                                                      segred_group_sizze_20999);\n            \n            x_21003 = ",
                   "0.0F;\n            for (int64_t i_23772 = 0; i_23772 < read_per_thread_23771;\n                 i_23772++) {\n                int64_t group_res_id_23773 = sext_i32_i64(local_tid_23753) *\n                        read_per_thread_23771 + i_23772;\n                int64_t index_of_group_res_23774 = group_res_id_23773;\n                \n                if (slt64(group_res_id_23773, num_groups_21000)) {\n                    x_21004 = ((__global\n                                float *) group_res_arr_mem_23749)[index_of_group_res_23774 *\n                                                                  segred_group_sizze_20999];\n                    \n                    float res_21005;\n                    \n                    res_21005 = x_21003 + x_21004;\n                    x_21003 = res_21005;\n                }\n            }\n        }\n        ((__local float *) red_arr_mem_23759)[sext_i32_i64(local_tid_23753)] =\n            x_21003;\n        barrier(CLK_LOCAL_MEM_FENCE);\n        // reduce the per-group results\n        {\n            int32_t offset_23775;\n            int32_t skip_waves_23776;\n            \n            skip_waves_23776 = 1;\n            \n            float x_23763;\n            float x_23764;\n            \n            offset_23775 = 0;\n            // participating threads read initial accumulator\n            {\n                if (slt32(local_tid_23753,\n                          sext_i64_i32(segred_group_sizze_20999))) {\n                    x_23763 = ((__local\n                                float *) red_arr_mem_23759)[sext_i32_i64(local_tid_23753 +\n                                                            offset_23775)];\n                }\n            }\n            offset_23775 = 1;\n            while (slt32(offset_23775, wave_sizze_23755)) {\n                if (slt32(local_tid_23753 + offset_23775,\n                          sext_i64_i32(segred_group_sizze_20999)) &&\n                    ((local_tid_23753 - squot32(local_tid_23753,\n                                      ",
                   "          wave_sizze_23755) *\n                      wave_sizze_23755) & (2 * offset_23775 - 1)) == 0) {\n                    // read array element\n                    {\n                        x_23764 = ((volatile __local\n                                    float *) red_arr_mem_23759)[sext_i32_i64(local_tid_23753 +\n                                                                offset_23775)];\n                    }\n                    // apply reduction operation\n                    {\n                        float res_23765 = x_23763 + x_23764;\n                        \n                        x_23763 = res_23765;\n                    }\n                    // write result of operation\n                    {\n                        ((volatile __local\n                          float *) red_arr_mem_23759)[sext_i32_i64(local_tid_23753)] =\n                            x_23763;\n                    }\n                }\n                offset_23775 *= 2;\n            }\n            while (slt32(skip_waves_23776,\n                         squot32(sext_i64_i32(segred_group_sizze_20999) +\n                                 wave_sizze_23755 - 1, wave_sizze_23755))) {\n                barrier(CLK_LOCAL_MEM_FENCE);\n                offset_23775 = skip_waves_23776 * wave_sizze_23755;\n                if (slt32(local_tid_23753 + offset_23775,\n                          sext_i64_i32(segred_group_sizze_20999)) &&\n                    ((local_tid_23753 - squot32(local_tid_23753,\n                                                wave_sizze_23755) *\n                      wave_sizze_23755) == 0 && (squot32(local_tid_23753,\n                                                         wave_sizze_23755) &\n                                                 (2 * skip_waves_23776 - 1)) ==\n                     0)) {\n                    // read array element\n                    {\n                        x_23764 = ((__local\n                                    float *) red_arr_mem_23759)[sext_i32_i64(local_tid_23753 +\n  ",
                   "                                                              offset_23775)];\n                    }\n                    // apply reduction operation\n                    {\n                        float res_23765 = x_23763 + x_23764;\n                        \n                        x_23763 = res_23765;\n                    }\n                    // write result of operation\n                    {\n                        ((__local\n                          float *) red_arr_mem_23759)[sext_i32_i64(local_tid_23753)] =\n                            x_23763;\n                    }\n                }\n                skip_waves_23776 *= 2;\n            }\n            // and back to memory with the final result\n            {\n                if (local_tid_23753 == 0) {\n                    ((__global float *) mem_23334)[0] = x_23763;\n                }\n            }\n        }\n    }\n    \n  error_1:\n    return;\n    #undef segred_group_sizze_20999\n}\n__kernel void mainzisegred_nonseg_23356(__global int *global_failure,\n                                        __local volatile\n                                        int64_t *red_arr_mem_23535_backing_aligned_0,\n                                        __local volatile\n                                        int64_t *sync_arr_mem_23533_backing_aligned_1,\n                                        int64_t n_18078, __global\n                                        unsigned char *payments_mem_23221,\n                                        __global unsigned char *mem_23368,\n                                        __global\n                                        unsigned char *mainzicounter_mem_23523,\n                                        __global\n                                        unsigned char *group_res_arr_mem_23525,\n                                        int64_t num_threads_23527)\n{\n    #define segred_num_groups_23350 (mainzisegred_num_groups_23349)\n    #define segred_group_sizze_23352 (mainzisegred_group_sizze_23351)\n    \n    const int bloc",
                   "k_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    __local volatile char *restrict red_arr_mem_23535_backing_1 =\n                          (__local volatile\n                           char *) red_arr_mem_23535_backing_aligned_0;\n    __local volatile char *restrict sync_arr_mem_23533_backing_0 =\n                          (__local volatile\n                           char *) sync_arr_mem_23533_backing_aligned_1;\n    \n    if (*global_failure >= 0)\n        return;\n    \n    int32_t global_tid_23528;\n    int32_t local_tid_23529;\n    int64_t group_sizze_23532;\n    int32_t wave_sizze_23531;\n    int32_t group_tid_23530;\n    \n    global_tid_23528 = get_global_id(0);\n    local_tid_23529 = get_local_id(0);\n    group_sizze_23532 = get_local_size(0);\n    wave_sizze_23531 = LOCKSTEP_WIDTH;\n    group_tid_23530 = get_group_id(0);\n    \n    int32_t phys_tid_23356;\n    \n    phys_tid_23356 = global_tid_23528;\n    \n    __local char *sync_arr_mem_23533;\n    \n    sync_arr_mem_23533 = (__local char *) sync_arr_mem_23533_backing_0;\n    \n    __local char *red_arr_mem_23535;\n    \n    red_arr_mem_23535 = (__local char *) red_arr_mem_23535_backing_1;\n    \n    int64_t dummy_23354;\n    \n    dummy_23354 = 0;\n    \n    int64_t gtid_23355;\n    \n    gtid_23355 = 0;\n    \n    int64_t x_acc_23537;\n    int64_t chunk_sizze_23538;\n    \n    chunk_sizze_23538 = smin64(sdiv_up64(n_18078,\n                                         sext_i32_i64(sext_i64_i32(segred_group_sizze_23352 *\n                                         segred_num_groups_23350))),\n                               sdiv_up64(n_18078 - sext_i32_i64(phys_tid_23356),\n                                         num_threads_23527));\n    \n    int64_t x_23357;\n    int64_t y_23358;\n    \n    // neutral-initialise the accumulators\n    {\n        x_acc_23537 = 0;\n    }\n    for (int64_t i_23542 = 0; i_23542 < chunk_sizze_23538; i_23542++) {\n        gtid_23355 = sext_i32_i64(phys_tid_23356) + num_threads_23527 * i_23542;\n        // apply map",
                   " function\n        {\n            int64_t res_23361 = ((__global\n                                  int64_t *) payments_mem_23221)[gtid_23355];\n            int64_t bytes_23362 = 4 * res_23361;\n            \n            // save map-out results\n            { }\n            // load accumulator\n            {\n                x_23357 = x_acc_23537;\n            }\n            // load new values\n            {\n                y_23358 = bytes_23362;\n            }\n            // apply reduction operator\n            {\n                int64_t zz_23359 = smax64(x_23357, y_23358);\n                \n                // store in accumulator\n                {\n                    x_acc_23537 = zz_23359;\n                }\n            }\n        }\n    }\n    // to reduce current chunk, first store our result in memory\n    {\n        x_23357 = x_acc_23537;\n        ((__local int64_t *) red_arr_mem_23535)[sext_i32_i64(local_tid_23529)] =\n            x_23357;\n    }\n    barrier(CLK_LOCAL_MEM_FENCE);\n    \n    int32_t offset_23543;\n    int32_t skip_waves_23544;\n    \n    skip_waves_23544 = 1;\n    \n    int64_t x_23539;\n    int64_t y_23540;\n    \n    offset_23543 = 0;\n    // participating threads read initial accumulator\n    {\n        if (slt32(local_tid_23529, sext_i64_i32(segred_group_sizze_23352))) {\n            x_23539 = ((__local\n                        int64_t *) red_arr_mem_23535)[sext_i32_i64(local_tid_23529 +\n                                                      offset_23543)];\n        }\n    }\n    offset_23543 = 1;\n    while (slt32(offset_23543, wave_sizze_23531)) {\n        if (slt32(local_tid_23529 + offset_23543,\n                  sext_i64_i32(segred_group_sizze_23352)) && ((local_tid_23529 -\n                                                               squot32(local_tid_23529,\n                                                                       wave_sizze_23531) *\n                                                               wave_sizze_23531) &\n                                                ",
                   "              (2 *\n                                                               offset_23543 -\n                                                               1)) == 0) {\n            // read array element\n            {\n                y_23540 = ((volatile __local\n                            int64_t *) red_arr_mem_23535)[sext_i32_i64(local_tid_23529 +\n                                                          offset_23543)];\n            }\n            // apply reduction operation\n            {\n                int64_t zz_23541 = smax64(x_23539, y_23540);\n                \n                x_23539 = zz_23541;\n            }\n            // write result of operation\n            {\n                ((volatile __local\n                  int64_t *) red_arr_mem_23535)[sext_i32_i64(local_tid_23529)] =\n                    x_23539;\n            }\n        }\n        offset_23543 *= 2;\n    }\n    while (slt32(skip_waves_23544,\n                 squot32(sext_i64_i32(segred_group_sizze_23352) +\n                         wave_sizze_23531 - 1, wave_sizze_23531))) {\n        barrier(CLK_LOCAL_MEM_FENCE);\n        offset_23543 = skip_waves_23544 * wave_sizze_23531;\n        if (slt32(local_tid_23529 + offset_23543,\n                  sext_i64_i32(segred_group_sizze_23352)) && ((local_tid_23529 -\n                                                               squot32(local_tid_23529,\n                                                                       wave_sizze_23531) *\n                                                               wave_sizze_23531) ==\n                                                              0 &&\n                                                              (squot32(local_tid_23529,\n                                                                       wave_sizze_23531) &\n                                                               (2 *\n                                                                skip_waves_23544 -\n                                                           ",
                   "     1)) == 0)) {\n            // read array element\n            {\n                y_23540 = ((__local\n                            int64_t *) red_arr_mem_23535)[sext_i32_i64(local_tid_23529 +\n                                                          offset_23543)];\n            }\n            // apply reduction operation\n            {\n                int64_t zz_23541 = smax64(x_23539, y_23540);\n                \n                x_23539 = zz_23541;\n            }\n            // write result of operation\n            {\n                ((__local\n                  int64_t *) red_arr_mem_23535)[sext_i32_i64(local_tid_23529)] =\n                    x_23539;\n            }\n        }\n        skip_waves_23544 *= 2;\n    }\n    barrier(CLK_LOCAL_MEM_FENCE);\n    // first thread saves the result in accumulator\n    {\n        if (sext_i32_i64(local_tid_23529) == 0) {\n            x_acc_23537 = x_23539;\n        }\n    }\n    \n    int32_t old_counter_23545;\n    \n    // first thread in group saves group result to global memory\n    {\n        if (local_tid_23529 == 0) {\n            ((__global\n              int64_t *) group_res_arr_mem_23525)[sext_i32_i64(group_tid_23530) *\n                                                  segred_group_sizze_23352] =\n                x_acc_23537;\n            mem_fence_global();\n            old_counter_23545 = atomic_add_i32_global(&((volatile __global\n                                                         int *) mainzicounter_mem_23523)[0],\n                                                      (int) 1);\n            ((__local bool *) sync_arr_mem_23533)[0] = old_counter_23545 ==\n                segred_num_groups_23350 - 1;\n        }\n    }\n    barrier(CLK_GLOBAL_MEM_FENCE | CLK_LOCAL_MEM_FENCE);\n    \n    bool is_last_group_23546;\n    \n    is_last_group_23546 = ((__local bool *) sync_arr_mem_23533)[0];\n    if (is_last_group_23546) {\n        if (local_tid_23529 == 0) {\n            old_counter_23545 = atomic_add_i32_global(&((volatile __global\n                         ",
                   "                                int *) mainzicounter_mem_23523)[0],\n                                                      (int) (0 -\n                                                             segred_num_groups_23350));\n        }\n        // read in the per-group-results\n        {\n            int64_t read_per_thread_23547 = sdiv_up64(segred_num_groups_23350,\n                                                      segred_group_sizze_23352);\n            \n            x_23357 = 0;\n            for (int64_t i_23548 = 0; i_23548 < read_per_thread_23547;\n                 i_23548++) {\n                int64_t group_res_id_23549 = sext_i32_i64(local_tid_23529) *\n                        read_per_thread_23547 + i_23548;\n                int64_t index_of_group_res_23550 = group_res_id_23549;\n                \n                if (slt64(group_res_id_23549, segred_num_groups_23350)) {\n                    y_23358 = ((__global\n                                int64_t *) group_res_arr_mem_23525)[index_of_group_res_23550 *\n                                                                    segred_group_sizze_23352];\n                    \n                    int64_t zz_23359;\n                    \n                    zz_23359 = smax64(x_23357, y_23358);\n                    x_23357 = zz_23359;\n                }\n            }\n        }\n        ((__local int64_t *) red_arr_mem_23535)[sext_i32_i64(local_tid_23529)] =\n            x_23357;\n        barrier(CLK_LOCAL_MEM_FENCE);\n        // reduce the per-group results\n        {\n            int32_t offset_23551;\n            int32_t skip_waves_23552;\n            \n            skip_waves_23552 = 1;\n            \n            int64_t x_23539;\n            int64_t y_23540;\n            \n            offset_23551 = 0;\n            // participating threads read initial accumulator\n            {\n                if (slt32(local_tid_23529,\n                          sext_i64_i32(segred_group_sizze_23352))) {\n                    x_23539 = ((__local\n                      ",
                   "          int64_t *) red_arr_mem_23535)[sext_i32_i64(local_tid_23529 +\n                                                              offset_23551)];\n                }\n            }\n            offset_23551 = 1;\n            while (slt32(offset_23551, wave_sizze_23531)) {\n                if (slt32(local_tid_23529 + offset_23551,\n                          sext_i64_i32(segred_group_sizze_23352)) &&\n                    ((local_tid_23529 - squot32(local_tid_23529,\n                                                wave_sizze_23531) *\n                      wave_sizze_23531) & (2 * offset_23551 - 1)) == 0) {\n                    // read array element\n                    {\n                        y_23540 = ((volatile __local\n                                    int64_t *) red_arr_mem_23535)[sext_i32_i64(local_tid_23529 +\n                                                                  offset_23551)];\n                    }\n                    // apply reduction operation\n                    {\n                        int64_t zz_23541 = smax64(x_23539, y_23540);\n                        \n                        x_23539 = zz_23541;\n                    }\n                    // write result of operation\n                    {\n                        ((volatile __local\n                          int64_t *) red_arr_mem_23535)[sext_i32_i64(local_tid_23529)] =\n                            x_23539;\n                    }\n                }\n                offset_23551 *= 2;\n            }\n            while (slt32(skip_waves_23552,\n                         squot32(sext_i64_i32(segred_group_sizze_23352) +\n                                 wave_sizze_23531 - 1, wave_sizze_23531))) {\n                barrier(CLK_LOCAL_MEM_FENCE);\n                offset_23551 = skip_waves_23552 * wave_sizze_23531;\n                if (slt32(local_tid_23529 + offset_23551,\n                          sext_i64_i32(segred_group_sizze_23352)) &&\n                    ((local_tid_23529 - squot32(local_tid_23529,\n                 ",
                   "                               wave_sizze_23531) *\n                      wave_sizze_23531) == 0 && (squot32(local_tid_23529,\n                                                         wave_sizze_23531) &\n                                                 (2 * skip_waves_23552 - 1)) ==\n                     0)) {\n                    // read array element\n                    {\n                        y_23540 = ((__local\n                                    int64_t *) red_arr_mem_23535)[sext_i32_i64(local_tid_23529 +\n                                                                  offset_23551)];\n                    }\n                    // apply reduction operation\n                    {\n                        int64_t zz_23541 = smax64(x_23539, y_23540);\n                        \n                        x_23539 = zz_23541;\n                    }\n                    // write result of operation\n                    {\n                        ((__local\n                          int64_t *) red_arr_mem_23535)[sext_i32_i64(local_tid_23529)] =\n                            x_23539;\n                    }\n                }\n                skip_waves_23552 *= 2;\n            }\n            // and back to memory with the final result\n            {\n                if (local_tid_23529 == 0) {\n                    ((__global int64_t *) mem_23368)[0] = x_23539;\n                }\n            }\n        }\n    }\n    \n  error_1:\n    return;\n    #undef segred_num_groups_23350\n    #undef segred_group_sizze_23352\n}\n__kernel void mainzisegred_nonseg_23388(__global int *global_failure,\n                                        __local volatile\n                                        int64_t *red_arr_mem_23572_backing_aligned_0,\n                                        __local volatile\n                                        int64_t *sync_arr_mem_23570_backing_aligned_1,\n                                        int64_t n_18078, __global\n                                        unsigned char *payments_mem_23221,",
                   "\n                                        __global unsigned char *mem_23400,\n                                        __global\n                                        unsigned char *mainzicounter_mem_23560,\n                                        __global\n                                        unsigned char *group_res_arr_mem_23562,\n                                        int64_t num_threads_23564)\n{\n    #define segred_num_groups_23382 (mainzisegred_num_groups_23381)\n    #define segred_group_sizze_23384 (mainzisegred_group_sizze_23383)\n    \n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    __local volatile char *restrict red_arr_mem_23572_backing_1 =\n                          (__local volatile\n                           char *) red_arr_mem_23572_backing_aligned_0;\n    __local volatile char *restrict sync_arr_mem_23570_backing_0 =\n                          (__local volatile\n                           char *) sync_arr_mem_23570_backing_aligned_1;\n    \n    if (*global_failure >= 0)\n        return;\n    \n    int32_t global_tid_23565;\n    int32_t local_tid_23566;\n    int64_t group_sizze_23569;\n    int32_t wave_sizze_23568;\n    int32_t group_tid_23567;\n    \n    global_tid_23565 = get_global_id(0);\n    local_tid_23566 = get_local_id(0);\n    group_sizze_23569 = get_local_size(0);\n    wave_sizze_23568 = LOCKSTEP_WIDTH;\n    group_tid_23567 = get_group_id(0);\n    \n    int32_t phys_tid_23388;\n    \n    phys_tid_23388 = global_tid_23565;\n    \n    __local char *sync_arr_mem_23570;\n    \n    sync_arr_mem_23570 = (__local char *) sync_arr_mem_23570_backing_0;\n    \n    __local char *red_arr_mem_23572;\n    \n    red_arr_mem_23572 = (__local char *) red_arr_mem_23572_backing_1;\n    \n    int64_t dummy_23386;\n    \n    dummy_23386 = 0;\n    \n    int64_t gtid_23387;\n    \n    gtid_23387 = 0;\n    \n    int64_t x_acc_23574;\n    int64_t chunk_sizze_23575;\n    \n    chunk_sizze_23575 = smin64(sdiv_up64(n_18078,\n                                         sext_i",
                   "32_i64(sext_i64_i32(segred_group_sizze_23384 *\n                                         segred_num_groups_23382))),\n                               sdiv_up64(n_18078 - sext_i32_i64(phys_tid_23388),\n                                         num_threads_23564));\n    \n    int64_t x_23389;\n    int64_t y_23390;\n    \n    // neutral-initialise the accumulators\n    {\n        x_acc_23574 = 0;\n    }\n    for (int64_t i_23579 = 0; i_23579 < chunk_sizze_23575; i_23579++) {\n        gtid_23387 = sext_i32_i64(phys_tid_23388) + num_threads_23564 * i_23579;\n        // apply map function\n        {\n            int64_t res_23393 = ((__global\n                                  int64_t *) payments_mem_23221)[gtid_23387];\n            int64_t bytes_23394 = 4 * res_23393;\n            \n            // save map-out results\n            { }\n            // load accumulator\n            {\n                x_23389 = x_acc_23574;\n            }\n            // load new values\n            {\n                y_23390 = bytes_23394;\n            }\n            // apply reduction operator\n            {\n                int64_t zz_23391 = smax64(x_23389, y_23390);\n                \n                // store in accumulator\n                {\n                    x_acc_23574 = zz_23391;\n                }\n            }\n        }\n    }\n    // to reduce current chunk, first store our result in memory\n    {\n        x_23389 = x_acc_23574;\n        ((__local int64_t *) red_arr_mem_23572)[sext_i32_i64(local_tid_23566)] =\n            x_23389;\n    }\n    barrier(CLK_LOCAL_MEM_FENCE);\n    \n    int32_t offset_23580;\n    int32_t skip_waves_23581;\n    \n    skip_waves_23581 = 1;\n    \n    int64_t x_23576;\n    int64_t y_23577;\n    \n    offset_23580 = 0;\n    // participating threads read initial accumulator\n    {\n        if (slt32(local_tid_23566, sext_i64_i32(segred_group_sizze_23384))) {\n            x_23576 = ((__local\n                        int64_t *) red_arr_mem_23572)[sext_i32_i64(local_tid_23566 +\n                                     ",
                   "                 offset_23580)];\n        }\n    }\n    offset_23580 = 1;\n    while (slt32(offset_23580, wave_sizze_23568)) {\n        if (slt32(local_tid_23566 + offset_23580,\n                  sext_i64_i32(segred_group_sizze_23384)) && ((local_tid_23566 -\n                                                               squot32(local_tid_23566,\n                                                                       wave_sizze_23568) *\n                                                               wave_sizze_23568) &\n                                                              (2 *\n                                                               offset_23580 -\n                                                               1)) == 0) {\n            // read array element\n            {\n                y_23577 = ((volatile __local\n                            int64_t *) red_arr_mem_23572)[sext_i32_i64(local_tid_23566 +\n                                                          offset_23580)];\n            }\n            // apply reduction operation\n            {\n                int64_t zz_23578 = smax64(x_23576, y_23577);\n                \n                x_23576 = zz_23578;\n            }\n            // write result of operation\n            {\n                ((volatile __local\n                  int64_t *) red_arr_mem_23572)[sext_i32_i64(local_tid_23566)] =\n                    x_23576;\n            }\n        }\n        offset_23580 *= 2;\n    }\n    while (slt32(skip_waves_23581,\n                 squot32(sext_i64_i32(segred_group_sizze_23384) +\n                         wave_sizze_23568 - 1, wave_sizze_23568))) {\n        barrier(CLK_LOCAL_MEM_FENCE);\n        offset_23580 = skip_waves_23581 * wave_sizze_23568;\n        if (slt32(local_tid_23566 + offset_23580,\n                  sext_i64_i32(segred_group_sizze_23384)) && ((local_tid_23566 -\n                                                               squot32(local_tid_23566,\n                                                                   ",
                   "    wave_sizze_23568) *\n                                                               wave_sizze_23568) ==\n                                                              0 &&\n                                                              (squot32(local_tid_23566,\n                                                                       wave_sizze_23568) &\n                                                               (2 *\n                                                                skip_waves_23581 -\n                                                                1)) == 0)) {\n            // read array element\n            {\n                y_23577 = ((__local\n                            int64_t *) red_arr_mem_23572)[sext_i32_i64(local_tid_23566 +\n                                                          offset_23580)];\n            }\n            // apply reduction operation\n            {\n                int64_t zz_23578 = smax64(x_23576, y_23577);\n                \n                x_23576 = zz_23578;\n            }\n            // write result of operation\n            {\n                ((__local\n                  int64_t *) red_arr_mem_23572)[sext_i32_i64(local_tid_23566)] =\n                    x_23576;\n            }\n        }\n        skip_waves_23581 *= 2;\n    }\n    barrier(CLK_LOCAL_MEM_FENCE);\n    // first thread saves the result in accumulator\n    {\n        if (sext_i32_i64(local_tid_23566) == 0) {\n            x_acc_23574 = x_23576;\n        }\n    }\n    \n    int32_t old_counter_23582;\n    \n    // first thread in group saves group result to global memory\n    {\n        if (local_tid_23566 == 0) {\n            ((__global\n              int64_t *) group_res_arr_mem_23562)[sext_i32_i64(group_tid_23567) *\n                                                  segred_group_sizze_23384] =\n                x_acc_23574;\n            mem_fence_global();\n            old_counter_23582 = atomic_add_i32_global(&((volatile __global\n                                                         int *",
                   ") mainzicounter_mem_23560)[0],\n                                                      (int) 1);\n            ((__local bool *) sync_arr_mem_23570)[0] = old_counter_23582 ==\n                segred_num_groups_23382 - 1;\n        }\n    }\n    barrier(CLK_GLOBAL_MEM_FENCE | CLK_LOCAL_MEM_FENCE);\n    \n    bool is_last_group_23583;\n    \n    is_last_group_23583 = ((__local bool *) sync_arr_mem_23570)[0];\n    if (is_last_group_23583) {\n        if (local_tid_23566 == 0) {\n            old_counter_23582 = atomic_add_i32_global(&((volatile __global\n                                                         int *) mainzicounter_mem_23560)[0],\n                                                      (int) (0 -\n                                                             segred_num_groups_23382));\n        }\n        // read in the per-group-results\n        {\n            int64_t read_per_thread_23584 = sdiv_up64(segred_num_groups_23382,\n                                                      segred_group_sizze_23384);\n            \n            x_23389 = 0;\n            for (int64_t i_23585 = 0; i_23585 < read_per_thread_23584;\n                 i_23585++) {\n                int64_t group_res_id_23586 = sext_i32_i64(local_tid_23566) *\n                        read_per_thread_23584 + i_23585;\n                int64_t index_of_group_res_23587 = group_res_id_23586;\n                \n                if (slt64(group_res_id_23586, segred_num_groups_23382)) {\n                    y_23390 = ((__global\n                                int64_t *) group_res_arr_mem_23562)[index_of_group_res_23587 *\n                                                                    segred_group_sizze_23384];\n                    \n                    int64_t zz_23391;\n                    \n                    zz_23391 = smax64(x_23389, y_23390);\n                    x_23389 = zz_23391;\n                }\n            }\n        }\n        ((__local int64_t *) red_arr_mem_23572)[sext_i32_i64(local_tid_23566)] =\n            x_23389;\n       ",
                   " barrier(CLK_LOCAL_MEM_FENCE);\n        // reduce the per-group results\n        {\n            int32_t offset_23588;\n            int32_t skip_waves_23589;\n            \n            skip_waves_23589 = 1;\n            \n            int64_t x_23576;\n            int64_t y_23577;\n            \n            offset_23588 = 0;\n            // participating threads read initial accumulator\n            {\n                if (slt32(local_tid_23566,\n                          sext_i64_i32(segred_group_sizze_23384))) {\n                    x_23576 = ((__local\n                                int64_t *) red_arr_mem_23572)[sext_i32_i64(local_tid_23566 +\n                                                              offset_23588)];\n                }\n            }\n            offset_23588 = 1;\n            while (slt32(offset_23588, wave_sizze_23568)) {\n                if (slt32(local_tid_23566 + offset_23588,\n                          sext_i64_i32(segred_group_sizze_23384)) &&\n                    ((local_tid_23566 - squot32(local_tid_23566,\n                                                wave_sizze_23568) *\n                      wave_sizze_23568) & (2 * offset_23588 - 1)) == 0) {\n                    // read array element\n                    {\n                        y_23577 = ((volatile __local\n                                    int64_t *) red_arr_mem_23572)[sext_i32_i64(local_tid_23566 +\n                                                                  offset_23588)];\n                    }\n                    // apply reduction operation\n                    {\n                        int64_t zz_23578 = smax64(x_23576, y_23577);\n                        \n                        x_23576 = zz_23578;\n                    }\n                    // write result of operation\n                    {\n                        ((volatile __local\n                          int64_t *) red_arr_mem_23572)[sext_i32_i64(local_tid_23566)] =\n                            x_23576;\n                    }\n                }\n  ",
                   "              offset_23588 *= 2;\n            }\n            while (slt32(skip_waves_23589,\n                         squot32(sext_i64_i32(segred_group_sizze_23384) +\n                                 wave_sizze_23568 - 1, wave_sizze_23568))) {\n                barrier(CLK_LOCAL_MEM_FENCE);\n                offset_23588 = skip_waves_23589 * wave_sizze_23568;\n                if (slt32(local_tid_23566 + offset_23588,\n                          sext_i64_i32(segred_group_sizze_23384)) &&\n                    ((local_tid_23566 - squot32(local_tid_23566,\n                                                wave_sizze_23568) *\n                      wave_sizze_23568) == 0 && (squot32(local_tid_23566,\n                                                         wave_sizze_23568) &\n                                                 (2 * skip_waves_23589 - 1)) ==\n                     0)) {\n                    // read array element\n                    {\n                        y_23577 = ((__local\n                                    int64_t *) red_arr_mem_23572)[sext_i32_i64(local_tid_23566 +\n                                                                  offset_23588)];\n                    }\n                    // apply reduction operation\n                    {\n                        int64_t zz_23578 = smax64(x_23576, y_23577);\n                        \n                        x_23576 = zz_23578;\n                    }\n                    // write result of operation\n                    {\n                        ((__local\n                          int64_t *) red_arr_mem_23572)[sext_i32_i64(local_tid_23566)] =\n                            x_23576;\n                    }\n                }\n                skip_waves_23589 *= 2;\n            }\n            // and back to memory with the final result\n            {\n                if (local_tid_23566 == 0) {\n                    ((__global int64_t *) mem_23400)[0] = x_23576;\n                }\n            }\n        }\n    }\n    \n  error_1:\n    return;\n    #u",
                   "ndef segred_num_groups_23382\n    #undef segred_group_sizze_23384\n}\n__kernel void mainzisegred_small_20273(__global int *global_failure,\n                                       int failure_is_an_option, __global\n                                       int64_t *global_failure_args,\n                                       __local volatile\n                                       int64_t *red_arr_mem_23683_backing_aligned_0,\n                                       int64_t n_18078, int64_t paths_18081,\n                                       int64_t steps_18082, float a_18086,\n                                       float b_18087, float sigma_18088,\n                                       float sims_per_year_18188,\n                                       int64_t num_groups_20856, __global\n                                       unsigned char *res_mem_23272, __global\n                                       unsigned char *res_mem_23273, __global\n                                       unsigned char *res_mem_23274, __global\n                                       unsigned char *res_mem_23275, __global\n                                       unsigned char *mem_23303, __global\n                                       unsigned char *mem_23322,\n                                       int64_t segment_sizze_nonzzero_23676)\n{\n    #define segred_group_sizze_20855 (mainzisegred_group_sizze_20267)\n    \n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    __local volatile char *restrict red_arr_mem_23683_backing_0 =\n                          (__local volatile\n                           char *) red_arr_mem_23683_backing_aligned_0;\n    volatile __local bool local_failure;\n    \n    if (failure_is_an_option) {\n        int failed = *global_failure >= 0;\n        \n        if (failed)\n            return;\n    }\n    local_failure = false;\n    barrier(CLK_LOCAL_MEM_FENCE);\n    \n    int32_t global_tid_23678;\n    int32_t local_tid_23679;\n    int64_t group_sizze_23682;\n    in",
                   "t32_t wave_sizze_23681;\n    int32_t group_tid_23680;\n    \n    global_tid_23678 = get_global_id(0);\n    local_tid_23679 = get_local_id(0);\n    group_sizze_23682 = get_local_size(0);\n    wave_sizze_23681 = LOCKSTEP_WIDTH;\n    group_tid_23680 = get_group_id(0);\n    \n    int32_t phys_tid_20273;\n    \n    phys_tid_20273 = global_tid_23678;\n    \n    __local char *red_arr_mem_23683;\n    \n    red_arr_mem_23683 = (__local char *) red_arr_mem_23683_backing_0;\n    \n    int32_t phys_group_id_23685;\n    \n    phys_group_id_23685 = get_group_id(0);\n    for (int32_t i_23686 = 0; i_23686 <\n         sdiv_up32(sext_i64_i32(sdiv_up64(steps_18082,\n                                          squot64(segred_group_sizze_20855,\n                                                  segment_sizze_nonzzero_23676))) -\n                   phys_group_id_23685, sext_i64_i32(num_groups_20856));\n         i_23686++) {\n        int32_t virt_group_id_23687 = phys_group_id_23685 + i_23686 *\n                sext_i64_i32(num_groups_20856);\n        int64_t gtid_20264 = squot64(sext_i32_i64(local_tid_23679),\n                                     segment_sizze_nonzzero_23676) +\n                sext_i32_i64(virt_group_id_23687) *\n                squot64(segred_group_sizze_20855, segment_sizze_nonzzero_23676);\n        int64_t gtid_20272 = srem64(sext_i32_i64(local_tid_23679), paths_18081);\n        \n        // apply map function if in bounds\n        {\n            if (slt64(0, paths_18081) && (slt64(gtid_20264, steps_18082) &&\n                                          slt64(sext_i32_i64(local_tid_23679),\n                                                paths_18081 *\n                                                squot64(segred_group_sizze_20855,\n                                                        segment_sizze_nonzzero_23676)))) {\n                float x_20864 = ((__global float *) mem_23303)[gtid_20264 *\n                                                               paths_18081 +\n                                     ",
                   "                          gtid_20272];\n                int64_t convop_x_23145 = add64(1, gtid_20264);\n                float binop_x_23146 = sitofp_i64_f32(convop_x_23145);\n                float index_primexp_23147 = binop_x_23146 / sims_per_year_18188;\n                float res_20866;\n                float redout_23202 = 0.0F;\n                \n                for (int64_t i_23203 = 0; i_23203 < n_18078; i_23203++) {\n                    int64_t x_20872 = ((__global\n                                        int64_t *) res_mem_23274)[i_23203];\n                    float x_20873 = ((__global float *) res_mem_23275)[i_23203];\n                    int64_t i64_arg_20874 = sub64(x_20872, 1);\n                    float res_20875 = sitofp_i64_f32(i64_arg_20874);\n                    float y_20876 = x_20873 * res_20875;\n                    bool cond_20877 = y_20876 < index_primexp_23147;\n                    float ceil_arg_20878 = index_primexp_23147 / x_20873;\n                    float res_20879;\n                    \n                    res_20879 = futrts_ceil32(ceil_arg_20878);\n                    \n                    int64_t res_20880 = fptosi_f32_i64(res_20879);\n                    int64_t remaining_20881 = sub64(x_20872, res_20880);\n                    float res_20882;\n                    \n                    if (cond_20877) {\n                        res_20882 = 0.0F;\n                    } else {\n                        float x_20870 = ((__global\n                                          float *) res_mem_23272)[i_23203];\n                        float x_20871 = ((__global\n                                          float *) res_mem_23273)[i_23203];\n                        float nextpayment_20883 = x_20873 * res_20879;\n                        bool bounds_invalid_upwards_20884 =\n                             slt64(remaining_20881, 1);\n                        bool valid_20885 = !bounds_invalid_upwards_20884;\n                        bool range_valid_c_20886;\n                        \n   ",
                   "                     if (!valid_20885) {\n                            {\n                                if (atomic_cmpxchg_i32_global(global_failure,\n                                                              -1, 14) == -1) {\n                                    global_failure_args[0] = 1;\n                                    global_failure_args[1] = 2;\n                                    global_failure_args[2] = remaining_20881;\n                                    ;\n                                }\n                                local_failure = true;\n                                goto error_0;\n                            }\n                        }\n                        \n                        float y_20888 = nextpayment_20883 - index_primexp_23147;\n                        float negate_arg_20889 = a_18086 * y_20888;\n                        float exp_arg_20890 = 0.0F - negate_arg_20889;\n                        float res_20891 = fpow32(2.7182817F, exp_arg_20890);\n                        float x_20892 = 1.0F - res_20891;\n                        float B_20893 = x_20892 / a_18086;\n                        float x_20894 = B_20893 - nextpayment_20883;\n                        float x_20895 = x_20894 + index_primexp_23147;\n                        float x_20896 = fpow32(a_18086, 2.0F);\n                        float x_20897 = b_18087 * x_20896;\n                        float x_20898 = fpow32(sigma_18088, 2.0F);\n                        float y_20899 = x_20898 / 2.0F;\n                        float y_20900 = x_20897 - y_20899;\n                        float x_20901 = x_20895 * y_20900;\n                        float A1_20902 = x_20901 / x_20896;\n                        float y_20903 = fpow32(B_20893, 2.0F);\n                        float x_20904 = x_20898 * y_20903;\n                        float y_20905 = 4.0F * a_18086;\n                        float A2_20906 = x_20904 / y_20905;\n                        float exp_arg_20907 = A1_20902 - A2_20906;\n                        float r",
                   "es_20908 = fpow32(2.7182817F, exp_arg_20907);\n                        float negate_arg_20909 = x_20864 * B_20893;\n                        float exp_arg_20910 = 0.0F - negate_arg_20909;\n                        float res_20911 = fpow32(2.7182817F, exp_arg_20910);\n                        float res_20912 = res_20908 * res_20911;\n                        bool y_20913 = slt64(0, remaining_20881);\n                        bool index_certs_20914;\n                        \n                        if (!y_20913) {\n                            {\n                                if (atomic_cmpxchg_i32_global(global_failure,\n                                                              -1, 15) == -1) {\n                                    global_failure_args[0] = 0;\n                                    global_failure_args[1] = remaining_20881;\n                                    ;\n                                }\n                                local_failure = true;\n                                goto error_0;\n                            }\n                        }\n                        \n                        float binop_y_20915 = sitofp_i64_f32(remaining_20881);\n                        float binop_y_20916 = x_20873 * binop_y_20915;\n                        float index_primexp_20917 = nextpayment_20883 +\n                              binop_y_20916;\n                        float y_20918 = index_primexp_20917 -\n                              index_primexp_23147;\n                        float negate_arg_20919 = a_18086 * y_20918;\n                        float exp_arg_20920 = 0.0F - negate_arg_20919;\n                        float res_20921 = fpow32(2.7182817F, exp_arg_20920);\n                        float x_20922 = 1.0F - res_20921;\n                        float B_20923 = x_20922 / a_18086;\n                        float x_20924 = B_20923 - index_primexp_20917;\n                        float x_20925 = x_20924 + index_primexp_23147;\n                        float x_20926 = y_20900 * x_20925",
                   ";\n                        float A1_20927 = x_20926 / x_20896;\n                        float y_20928 = fpow32(B_20923, 2.0F);\n                        float x_20929 = x_20898 * y_20928;\n                        float A2_20930 = x_20929 / y_20905;\n                        float exp_arg_20931 = A1_20927 - A2_20930;\n                        float res_20932 = fpow32(2.7182817F, exp_arg_20931);\n                        float negate_arg_20933 = x_20864 * B_20923;\n                        float exp_arg_20934 = 0.0F - negate_arg_20933;\n                        float res_20935 = fpow32(2.7182817F, exp_arg_20934);\n                        float res_20936 = res_20932 * res_20935;\n                        float res_20937;\n                        float redout_23142 = 0.0F;\n                        \n                        for (int64_t i_23143 = 0; i_23143 < remaining_20881;\n                             i_23143++) {\n                            int64_t index_primexp_23165 = add64(1, i_23143);\n                            float res_20942 =\n                                  sitofp_i64_f32(index_primexp_23165);\n                            float res_20943 = x_20873 * res_20942;\n                            float res_20944 = nextpayment_20883 + res_20943;\n                            float y_20945 = res_20944 - index_primexp_23147;\n                            float negate_arg_20946 = a_18086 * y_20945;\n                            float exp_arg_20947 = 0.0F - negate_arg_20946;\n                            float res_20948 = fpow32(2.7182817F, exp_arg_20947);\n                            float x_20949 = 1.0F - res_20948;\n                            float B_20950 = x_20949 / a_18086;\n                            float x_20951 = B_20950 - res_20944;\n                            float x_20952 = x_20951 + index_primexp_23147;\n                            float x_20953 = y_20900 * x_20952;\n                            float A1_20954 = x_20953 / x_20896;\n                            float y_20955 = fpow32(B_20950, ",
                   "2.0F);\n                            float x_20956 = x_20898 * y_20955;\n                            float A2_20957 = x_20956 / y_20905;\n                            float exp_arg_20958 = A1_20954 - A2_20957;\n                            float res_20959 = fpow32(2.7182817F, exp_arg_20958);\n                            float negate_arg_20960 = x_20864 * B_20950;\n                            float exp_arg_20961 = 0.0F - negate_arg_20960;\n                            float res_20962 = fpow32(2.7182817F, exp_arg_20961);\n                            float res_20963 = res_20959 * res_20962;\n                            float res_20940 = res_20963 + redout_23142;\n                            float redout_tmp_23689 = res_20940;\n                            \n                            redout_23142 = redout_tmp_23689;\n                        }\n                        res_20937 = redout_23142;\n                        \n                        float x_20964 = res_20912 - res_20936;\n                        float x_20965 = x_20870 * x_20873;\n                        float y_20966 = res_20937 * x_20965;\n                        float y_20967 = x_20964 - y_20966;\n                        float res_20968 = x_20871 * y_20967;\n                        \n                        res_20882 = res_20968;\n                    }\n                    \n                    float res_20869 = res_20882 + redout_23202;\n                    float redout_tmp_23688 = res_20869;\n                    \n                    redout_23202 = redout_tmp_23688;\n                }\n                res_20866 = redout_23202;\n                \n                float res_20969 = fmax32(0.0F, res_20866);\n                \n                // save map-out results\n                { }\n                // save results to be reduced\n                {\n                    ((__local\n                      float *) red_arr_mem_23683)[sext_i32_i64(local_tid_23679)] =\n                        res_20969;\n                }\n            } else {\n              ",
                   "  ((__local\n                  float *) red_arr_mem_23683)[sext_i32_i64(local_tid_23679)] =\n                    0.0F;\n            }\n        }\n        \n      error_0:\n        barrier(CLK_LOCAL_MEM_FENCE);\n        if (local_failure)\n            return;\n        barrier(CLK_LOCAL_MEM_FENCE);\n        if (slt64(0, paths_18081)) {\n            // perform segmented scan to imitate reduction\n            {\n                float x_20859;\n                float x_20860;\n                float x_23690;\n                float x_23691;\n                bool ltid_in_bounds_23693;\n                \n                ltid_in_bounds_23693 = slt64(sext_i32_i64(local_tid_23679),\n                                             paths_18081 *\n                                             squot64(segred_group_sizze_20855,\n                                                     segment_sizze_nonzzero_23676));\n                \n                int32_t skip_threads_23694;\n                \n                // read input for in-block scan\n                {\n                    if (ltid_in_bounds_23693) {\n                        x_20860 = ((volatile __local\n                                    float *) red_arr_mem_23683)[sext_i32_i64(local_tid_23679)];\n                        if ((local_tid_23679 - squot32(local_tid_23679, 32) *\n                             32) == 0) {\n                            x_20859 = x_20860;\n                        }\n                    }\n                }\n                // in-block scan (hopefully no barriers needed)\n                {\n                    skip_threads_23694 = 1;\n                    while (slt32(skip_threads_23694, 32)) {\n                        if (sle32(skip_threads_23694, local_tid_23679 -\n                                  squot32(local_tid_23679, 32) * 32) &&\n                            ltid_in_bounds_23693) {\n                            // read operands\n                            {\n                                x_20859 = ((volatile __local\n                            ",
                   "                float *) red_arr_mem_23683)[sext_i32_i64(local_tid_23679) -\n                                                                        sext_i32_i64(skip_threads_23694)];\n                            }\n                            // perform operation\n                            {\n                                bool inactive_23695 =\n                                     slt64(srem64(sext_i32_i64(local_tid_23679),\n                                                  paths_18081),\n                                           sext_i32_i64(local_tid_23679) -\n                                           sext_i32_i64(local_tid_23679 -\n                                           skip_threads_23694));\n                                \n                                if (inactive_23695) {\n                                    x_20859 = x_20860;\n                                }\n                                if (!inactive_23695) {\n                                    float res_20861 = x_20859 + x_20860;\n                                    \n                                    x_20859 = res_20861;\n                                }\n                            }\n                        }\n                        if (sle32(wave_sizze_23681, skip_threads_23694)) {\n                            barrier(CLK_LOCAL_MEM_FENCE);\n                        }\n                        if (sle32(skip_threads_23694, local_tid_23679 -\n                                  squot32(local_tid_23679, 32) * 32) &&\n                            ltid_in_bounds_23693) {\n                            // write result\n                            {\n                                ((volatile __local\n                                  float *) red_arr_mem_23683)[sext_i32_i64(local_tid_23679)] =\n                                    x_20859;\n                                x_20860 = x_20859;\n                            }\n                        }\n                        if (sle32(wave_sizze_23681, skip_threads_23694)) {\n     ",
                   "                       barrier(CLK_LOCAL_MEM_FENCE);\n                        }\n                        skip_threads_23694 *= 2;\n                    }\n                }\n                barrier(CLK_LOCAL_MEM_FENCE);\n                // last thread of block 'i' writes its result to offset 'i'\n                {\n                    if ((local_tid_23679 - squot32(local_tid_23679, 32) * 32) ==\n                        31 && ltid_in_bounds_23693) {\n                        ((volatile __local\n                          float *) red_arr_mem_23683)[sext_i32_i64(squot32(local_tid_23679,\n                                                                           32))] =\n                            x_20859;\n                    }\n                }\n                barrier(CLK_LOCAL_MEM_FENCE);\n                // scan the first block, after which offset 'i' contains carry-in for block 'i+1'\n                {\n                    int32_t skip_threads_23696;\n                    \n                    // read input for in-block scan\n                    {\n                        if (squot32(local_tid_23679, 32) == 0 &&\n                            ltid_in_bounds_23693) {\n                            x_23691 = ((volatile __local\n                                        float *) red_arr_mem_23683)[sext_i32_i64(local_tid_23679)];\n                            if ((local_tid_23679 - squot32(local_tid_23679,\n                                                           32) * 32) == 0) {\n                                x_23690 = x_23691;\n                            }\n                        }\n                    }\n                    // in-block scan (hopefully no barriers needed)\n                    {\n                        skip_threads_23696 = 1;\n                        while (slt32(skip_threads_23696, 32)) {\n                            if (sle32(skip_threads_23696, local_tid_23679 -\n                                      squot32(local_tid_23679, 32) * 32) &&\n                                (squot32(local_",
                   "tid_23679, 32) == 0 &&\n                                 ltid_in_bounds_23693)) {\n                                // read operands\n                                {\n                                    x_23690 = ((volatile __local\n                                                float *) red_arr_mem_23683)[sext_i32_i64(local_tid_23679) -\n                                                                            sext_i32_i64(skip_threads_23696)];\n                                }\n                                // perform operation\n                                {\n                                    bool inactive_23697 =\n                                         slt64(srem64(sext_i32_i64(local_tid_23679 *\n                                                      32 + 32 - 1),\n                                                      paths_18081),\n                                               sext_i32_i64(local_tid_23679 *\n                                               32 + 32 - 1) -\n                                               sext_i32_i64((local_tid_23679 -\n                                                             skip_threads_23696) *\n                                               32 + 32 - 1));\n                                    \n                                    if (inactive_23697) {\n                                        x_23690 = x_23691;\n                                    }\n                                    if (!inactive_23697) {\n                                        float res_23692 = x_23690 + x_23691;\n                                        \n                                        x_23690 = res_23692;\n                                    }\n                                }\n                            }\n                            if (sle32(wave_sizze_23681, skip_threads_23696)) {\n                                barrier(CLK_LOCAL_MEM_FENCE);\n                            }\n                            if (sle32(skip_threads_23696, local_tid_23679 -\n         ",
                   "                             squot32(local_tid_23679, 32) * 32) &&\n                                (squot32(local_tid_23679, 32) == 0 &&\n                                 ltid_in_bounds_23693)) {\n                                // write result\n                                {\n                                    ((volatile __local\n                                      float *) red_arr_mem_23683)[sext_i32_i64(local_tid_23679)] =\n                                        x_23690;\n                                    x_23691 = x_23690;\n                                }\n                            }\n                            if (sle32(wave_sizze_23681, skip_threads_23696)) {\n                                barrier(CLK_LOCAL_MEM_FENCE);\n                            }\n                            skip_threads_23696 *= 2;\n                        }\n                    }\n                }\n                barrier(CLK_LOCAL_MEM_FENCE);\n                // carry-in for every block except the first\n                {\n                    if (!(squot32(local_tid_23679, 32) == 0 ||\n                          !ltid_in_bounds_23693)) {\n                        // read operands\n                        {\n                            x_20860 = x_20859;\n                            x_20859 = ((__local\n                                        float *) red_arr_mem_23683)[sext_i32_i64(squot32(local_tid_23679,\n                                                                                         32)) -\n                                                                    1];\n                        }\n                        // perform operation\n                        {\n                            bool inactive_23698 =\n                                 slt64(srem64(sext_i32_i64(local_tid_23679),\n                                              paths_18081),\n                                       sext_i32_i64(local_tid_23679) -\n                                       sext_i32_i64(squot32(local_tid_23679,\n   ",
                   "                                                         32) * 32 - 1));\n                            \n                            if (inactive_23698) {\n                                x_20859 = x_20860;\n                            }\n                            if (!inactive_23698) {\n                                float res_20861 = x_20859 + x_20860;\n                                \n                                x_20859 = res_20861;\n                            }\n                        }\n                        // write final result\n                        {\n                            ((__local\n                              float *) red_arr_mem_23683)[sext_i32_i64(local_tid_23679)] =\n                                x_20859;\n                        }\n                    }\n                }\n                barrier(CLK_LOCAL_MEM_FENCE);\n                // restore correct values for first block\n                {\n                    if (squot32(local_tid_23679, 32) == 0) {\n                        ((__local\n                          float *) red_arr_mem_23683)[sext_i32_i64(local_tid_23679)] =\n                            x_20860;\n                    }\n                }\n                barrier(CLK_LOCAL_MEM_FENCE);\n            }\n        }\n        barrier(CLK_LOCAL_MEM_FENCE);\n        // save final values of segments\n        {\n            if (slt64(sext_i32_i64(virt_group_id_23687) *\n                      squot64(segred_group_sizze_20855,\n                              segment_sizze_nonzzero_23676) +\n                      sext_i32_i64(local_tid_23679), steps_18082) &&\n                slt64(sext_i32_i64(local_tid_23679),\n                      squot64(segred_group_sizze_20855,\n                              segment_sizze_nonzzero_23676))) {\n                ((__global\n                  float *) mem_23322)[sext_i32_i64(virt_group_id_23687) *\n                                      squot64(segred_group_sizze_20855,\n                                              segment_sizze_nonzze",
                   "ro_23676) +\n                                      sext_i32_i64(local_tid_23679)] = ((__local\n                                                                         float *) red_arr_mem_23683)[(sext_i32_i64(local_tid_23679) +\n                                                                                                      1) *\n                                                                                                     segment_sizze_nonzzero_23676 -\n                                                                                                     1];\n            }\n        }\n        barrier(CLK_LOCAL_MEM_FENCE);\n        barrier(CLK_GLOBAL_MEM_FENCE | CLK_LOCAL_MEM_FENCE);\n    }\n    \n  error_1:\n    return;\n    #undef segred_group_sizze_20855\n}\n__kernel void testzisegmap_21033(__global int *global_failure,\n                                 int failure_is_an_option, __global\n                                 int64_t *global_failure_args, __global\n                                 unsigned char *mem_23223, __global\n                                 unsigned char *mem_23225, __global\n                                 unsigned char *mem_23237, __global\n                                 unsigned char *mem_23251)\n{\n    #define segmap_group_sizze_21111 (testzisegmap_group_sizze_21035)\n    #define num_threads_23415 (testzisegmap_group_sizze_21035 * sdiv_up64(9, testzisegmap_group_sizze_21035))\n    \n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    \n    if (*global_failure >= 0)\n        return;\n    \n    int32_t global_tid_23554;\n    int32_t local_tid_23555;\n    int64_t group_sizze_23558;\n    int32_t wave_sizze_23557;\n    int32_t group_tid_23556;\n    \n    global_tid_23554 = get_global_id(0);\n    local_tid_23555 = get_local_id(0);\n    group_sizze_23558 = get_local_size(0);\n    wave_sizze_23557 = LOCKSTEP_WIDTH;\n    group_tid_23556 = get_group_id(0);\n    \n    int32_t phys_tid_21033;\n    \n    phys_tid_21033 = global_tid_23554;\n   ",
                   " \n    int64_t gtid_21032;\n    \n    gtid_21032 = sext_i32_i64(group_tid_23556) * segmap_group_sizze_21111 +\n        sext_i32_i64(local_tid_23555);\n    if (slt64(gtid_21032, 9)) {\n        float res_21122 = ((__global float *) mem_23225)[gtid_21032];\n        int64_t res_21123 = ((__global int64_t *) mem_23223)[gtid_21032];\n        int64_t range_end_21125 = sub64(res_21123, 1);\n        bool bounds_invalid_upwards_21126 = slt64(range_end_21125, 0);\n        bool valid_21127 = !bounds_invalid_upwards_21126;\n        bool range_valid_c_21128;\n        \n        if (!valid_21127) {\n            {\n                if (atomic_cmpxchg_i32_global(global_failure, -1, 18) == -1) {\n                    global_failure_args[0] = 0;\n                    global_failure_args[1] = 1;\n                    global_failure_args[2] = range_end_21125;\n                    ;\n                }\n                return;\n            }\n        }\n        for (int64_t i_23182 = 0; i_23182 < res_21123; i_23182++) {\n            float res_21132 = sitofp_i64_f32(i_23182);\n            float res_21133 = res_21122 * res_21132;\n            \n            ((__global float *) mem_23237)[phys_tid_21033 + i_23182 *\n                                           num_threads_23415] = res_21133;\n        }\n        \n        bool y_21134 = slt64(0, res_21123);\n        bool index_certs_21135;\n        \n        if (!y_21134) {\n            {\n                if (atomic_cmpxchg_i32_global(global_failure, -1, 19) == -1) {\n                    global_failure_args[0] = 0;\n                    global_failure_args[1] = res_21123;\n                    ;\n                }\n                return;\n            }\n        }\n        \n        float binop_y_21136 = sitofp_i64_f32(range_end_21125);\n        float index_primexp_21137 = res_21122 * binop_y_21136;\n        float negate_arg_21138 = 1.0e-2F * index_primexp_21137;\n        float exp_arg_21139 = 0.0F - negate_arg_21138;\n        float res_21140 = fpow32(2.7182817F, exp_arg_21139);\n        float x_21141 ",
                   "= 1.0F - res_21140;\n        float B_21142 = x_21141 / 1.0e-2F;\n        float x_21143 = B_21142 - index_primexp_21137;\n        float x_21144 = 4.4999997e-6F * x_21143;\n        float A1_21145 = x_21144 / 1.0e-4F;\n        float y_21146 = fpow32(B_21142, 2.0F);\n        float x_21147 = 1.0000001e-6F * y_21146;\n        float A2_21148 = x_21147 / 4.0e-2F;\n        float exp_arg_21149 = A1_21145 - A2_21148;\n        float res_21150 = fpow32(2.7182817F, exp_arg_21149);\n        float negate_arg_21151 = 5.0e-2F * B_21142;\n        float exp_arg_21152 = 0.0F - negate_arg_21151;\n        float res_21153 = fpow32(2.7182817F, exp_arg_21152);\n        float res_21154 = res_21150 * res_21153;\n        bool empty_slice_21155 = range_end_21125 == 0;\n        bool zzero_leq_i_p_m_t_s_21156 = sle64(0, range_end_21125);\n        bool i_p_m_t_s_leq_w_21157 = slt64(range_end_21125, res_21123);\n        bool i_lte_j_21158 = sle64(1, res_21123);\n        bool y_21159 = zzero_leq_i_p_m_t_s_21156 && i_p_m_t_s_leq_w_21157;\n        bool y_21160 = i_lte_j_21158 && y_21159;\n        bool ok_or_empty_21161 = empty_slice_21155 || y_21160;\n        bool index_certs_21162;\n        \n        if (!ok_or_empty_21161) {\n            {\n                if (atomic_cmpxchg_i32_global(global_failure, -1, 20) == -1) {\n                    global_failure_args[0] = 1;\n                    global_failure_args[1] = res_21123;\n                    ;\n                }\n                return;\n            }\n        }\n        \n        float res_21164;\n        float redout_23184 = 0.0F;\n        \n        for (int64_t i_23185 = 0; i_23185 < range_end_21125; i_23185++) {\n            int64_t slice_23206 = 1 + i_23185;\n            float x_21168 = ((__global float *) mem_23237)[phys_tid_21033 +\n                                                           slice_23206 *\n                                                           num_threads_23415];\n            float negate_arg_21169 = 1.0e-2F * x_21168;\n            float exp_arg_21170 = 0.0F - nega",
                   "te_arg_21169;\n            float res_21171 = fpow32(2.7182817F, exp_arg_21170);\n            float x_21172 = 1.0F - res_21171;\n            float B_21173 = x_21172 / 1.0e-2F;\n            float x_21174 = B_21173 - x_21168;\n            float x_21175 = 4.4999997e-6F * x_21174;\n            float A1_21176 = x_21175 / 1.0e-4F;\n            float y_21177 = fpow32(B_21173, 2.0F);\n            float x_21178 = 1.0000001e-6F * y_21177;\n            float A2_21179 = x_21178 / 4.0e-2F;\n            float exp_arg_21180 = A1_21176 - A2_21179;\n            float res_21181 = fpow32(2.7182817F, exp_arg_21180);\n            float negate_arg_21182 = 5.0e-2F * B_21173;\n            float exp_arg_21183 = 0.0F - negate_arg_21182;\n            float res_21184 = fpow32(2.7182817F, exp_arg_21183);\n            float res_21185 = res_21181 * res_21184;\n            float res_21167 = res_21185 + redout_23184;\n            float redout_tmp_23560 = res_21167;\n            \n            redout_23184 = redout_tmp_23560;\n        }\n        res_21164 = redout_23184;\n        \n        float x_21186 = 1.0F - res_21154;\n        float y_21187 = res_21122 * res_21164;\n        float res_21188 = x_21186 / y_21187;\n        \n        ((__global float *) mem_23251)[gtid_21032] = res_21188;\n    }\n    \n  error_0:\n    return;\n    #undef segmap_group_sizze_21111\n    #undef num_threads_23415\n}\n__kernel void testzisegmap_21209(__global int *global_failure,\n                                 int failure_is_an_option, __global\n                                 int64_t *global_failure_args, __global\n                                 unsigned char *mem_23223, __global\n                                 unsigned char *mem_23225, __global\n                                 unsigned char *mem_23260, __global\n                                 unsigned char *mem_23274)\n{\n    #define segmap_group_sizze_21287 (testzisegmap_group_sizze_21211)\n    #define num_threads_23447 (testzisegmap_group_sizze_21211 * sdiv_up64(9, testzisegmap_group_sizze_21211))\n    ",
                   "\n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    \n    if (*global_failure >= 0)\n        return;\n    \n    int32_t global_tid_23591;\n    int32_t local_tid_23592;\n    int64_t group_sizze_23595;\n    int32_t wave_sizze_23594;\n    int32_t group_tid_23593;\n    \n    global_tid_23591 = get_global_id(0);\n    local_tid_23592 = get_local_id(0);\n    group_sizze_23595 = get_local_size(0);\n    wave_sizze_23594 = LOCKSTEP_WIDTH;\n    group_tid_23593 = get_group_id(0);\n    \n    int32_t phys_tid_21209;\n    \n    phys_tid_21209 = global_tid_23591;\n    \n    int64_t gtid_21208;\n    \n    gtid_21208 = sext_i32_i64(group_tid_23593) * segmap_group_sizze_21287 +\n        sext_i32_i64(local_tid_23592);\n    if (slt64(gtid_21208, 9)) {\n        float res_21298 = ((__global float *) mem_23225)[gtid_21208];\n        int64_t res_21299 = ((__global int64_t *) mem_23223)[gtid_21208];\n        int64_t range_end_21301 = sub64(res_21299, 1);\n        bool bounds_invalid_upwards_21302 = slt64(range_end_21301, 0);\n        bool valid_21303 = !bounds_invalid_upwards_21302;\n        bool range_valid_c_21304;\n        \n        if (!valid_21303) {\n            {\n                if (atomic_cmpxchg_i32_global(global_failure, -1, 21) == -1) {\n                    global_failure_args[0] = 0;\n                    global_failure_args[1] = 1;\n                    global_failure_args[2] = range_end_21301;\n                    ;\n                }\n                return;\n            }\n        }\n        for (int64_t i_23188 = 0; i_23188 < res_21299; i_23188++) {\n            float res_21308 = sitofp_i64_f32(i_23188);\n            float res_21309 = res_21298 * res_21308;\n            \n            ((__global float *) mem_23260)[phys_tid_21209 + i_23188 *\n                                           num_threads_23447] = res_21309;\n        }\n        \n        bool y_21310 = slt64(0, res_21299);\n        bool index_certs_21311;\n        \n        if (!y_21310) {\n            {\n                if (atomic",
                   "_cmpxchg_i32_global(global_failure, -1, 22) == -1) {\n                    global_failure_args[0] = 0;\n                    global_failure_args[1] = res_21299;\n                    ;\n                }\n                return;\n            }\n        }\n        \n        float binop_y_21312 = sitofp_i64_f32(range_end_21301);\n        float index_primexp_21313 = res_21298 * binop_y_21312;\n        float negate_arg_21314 = 1.0e-2F * index_primexp_21313;\n        float exp_arg_21315 = 0.0F - negate_arg_21314;\n        float res_21316 = fpow32(2.7182817F, exp_arg_21315);\n        float x_21317 = 1.0F - res_21316;\n        float B_21318 = x_21317 / 1.0e-2F;\n        float x_21319 = B_21318 - index_primexp_21313;\n        float x_21320 = 4.4999997e-6F * x_21319;\n        float A1_21321 = x_21320 / 1.0e-4F;\n        float y_21322 = fpow32(B_21318, 2.0F);\n        float x_21323 = 1.0000001e-6F * y_21322;\n        float A2_21324 = x_21323 / 4.0e-2F;\n        float exp_arg_21325 = A1_21321 - A2_21324;\n        float res_21326 = fpow32(2.7182817F, exp_arg_21325);\n        float negate_arg_21327 = 5.0e-2F * B_21318;\n        float exp_arg_21328 = 0.0F - negate_arg_21327;\n        float res_21329 = fpow32(2.7182817F, exp_arg_21328);\n        float res_21330 = res_21326 * res_21329;\n        bool empty_slice_21331 = range_end_21301 == 0;\n        bool zzero_leq_i_p_m_t_s_21332 = sle64(0, range_end_21301);\n        bool i_p_m_t_s_leq_w_21333 = slt64(range_end_21301, res_21299);\n        bool i_lte_j_21334 = sle64(1, res_21299);\n        bool y_21335 = zzero_leq_i_p_m_t_s_21332 && i_p_m_t_s_leq_w_21333;\n        bool y_21336 = i_lte_j_21334 && y_21335;\n        bool ok_or_empty_21337 = empty_slice_21331 || y_21336;\n        bool index_certs_21338;\n        \n        if (!ok_or_empty_21337) {\n            {\n                if (atomic_cmpxchg_i32_global(global_failure, -1, 23) == -1) {\n                    global_failure_args[0] = 1;\n                    global_failure_args[1] = res_21299;\n                    ;\n            ",
                   "    }\n                return;\n            }\n        }\n        \n        float res_21340;\n        float redout_23190 = 0.0F;\n        \n        for (int64_t i_23191 = 0; i_23191 < range_end_21301; i_23191++) {\n            int64_t slice_23209 = 1 + i_23191;\n            float x_21344 = ((__global float *) mem_23260)[phys_tid_21209 +\n                                                           slice_23209 *\n                                                           num_threads_23447];\n            float negate_arg_21345 = 1.0e-2F * x_21344;\n            float exp_arg_21346 = 0.0F - negate_arg_21345;\n            float res_21347 = fpow32(2.7182817F, exp_arg_21346);\n            float x_21348 = 1.0F - res_21347;\n            float B_21349 = x_21348 / 1.0e-2F;\n            float x_21350 = B_21349 - x_21344;\n            float x_21351 = 4.4999997e-6F * x_21350;\n            float A1_21352 = x_21351 / 1.0e-4F;\n            float y_21353 = fpow32(B_21349, 2.0F);\n            float x_21354 = 1.0000001e-6F * y_21353;\n            float A2_21355 = x_21354 / 4.0e-2F;\n            float exp_arg_21356 = A1_21352 - A2_21355;\n            float res_21357 = fpow32(2.7182817F, exp_arg_21356);\n            float negate_arg_21358 = 5.0e-2F * B_21349;\n            float exp_arg_21359 = 0.0F - negate_arg_21358;\n            float res_21360 = fpow32(2.7182817F, exp_arg_21359);\n            float res_21361 = res_21357 * res_21360;\n            float res_21343 = res_21361 + redout_23190;\n            float redout_tmp_23597 = res_21343;\n            \n            redout_23190 = redout_tmp_23597;\n        }\n        res_21340 = redout_23190;\n        \n        float x_21362 = 1.0F - res_21330;\n        float y_21363 = res_21298 * res_21340;\n        float res_21364 = x_21362 / y_21363;\n        \n        ((__global float *) mem_23274)[gtid_21208] = res_21364;\n    }\n    \n  error_0:\n    return;\n    #undef segmap_group_sizze_21287\n    #undef num_threads_23447\n}\n__kernel void testzisegmap_21542(__global int *global_failure,\n       ",
                   "                          int failure_is_an_option, __global\n                                 int64_t *global_failure_args,\n                                 int64_t paths_18528, int64_t steps_18529,\n                                 float dt_18542, int64_t upper_bound_18634,\n                                 float res_18635, int64_t num_groups_21794,\n                                 __global unsigned char *mem_23288, __global\n                                 unsigned char *mem_23291, __global\n                                 unsigned char *mem_23306)\n{\n    #define segmap_group_sizze_21793 (testzisegmap_group_sizze_21544)\n    \n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    volatile __local bool local_failure;\n    \n    if (failure_is_an_option) {\n        int failed = *global_failure >= 0;\n        \n        if (failed)\n            return;\n    }\n    local_failure = false;\n    barrier(CLK_LOCAL_MEM_FENCE);\n    \n    int32_t global_tid_23610;\n    int32_t local_tid_23611;\n    int64_t group_sizze_23614;\n    int32_t wave_sizze_23613;\n    int32_t group_tid_23612;\n    \n    global_tid_23610 = get_global_id(0);\n    local_tid_23611 = get_local_id(0);\n    group_sizze_23614 = get_local_size(0);\n    wave_sizze_23613 = LOCKSTEP_WIDTH;\n    group_tid_23612 = get_group_id(0);\n    \n    int32_t phys_tid_21542;\n    \n    phys_tid_21542 = global_tid_23610;\n    \n    int32_t phys_group_id_23615;\n    \n    phys_group_id_23615 = get_group_id(0);\n    for (int32_t i_23616 = 0; i_23616 <\n         sdiv_up32(sext_i64_i32(sdiv_up64(paths_18528,\n                                          segmap_group_sizze_21793)) -\n                   phys_group_id_23615, sext_i64_i32(num_groups_21794));\n         i_23616++) {\n        int32_t virt_group_id_23617 = phys_group_id_23615 + i_23616 *\n                sext_i64_i32(num_groups_21794);\n        int64_t gtid_21541 = sext_i32_i64(virt_group_id_23617) *\n                segmap_group_sizze_21793 + sext_i32_i64(local_tid_23611);\n",
                   "        \n        if (slt64(gtid_21541, paths_18528)) {\n            for (int64_t i_23618 = 0; i_23618 < steps_18529; i_23618++) {\n                ((__global float *) mem_23291)[phys_tid_21542 + i_23618 *\n                                               (num_groups_21794 *\n                                                segmap_group_sizze_21793)] =\n                    5.0e-2F;\n            }\n            for (int64_t i_21800 = 0; i_21800 < upper_bound_18634; i_21800++) {\n                bool y_21802 = slt64(i_21800, steps_18529);\n                bool index_certs_21803;\n                \n                if (!y_21802) {\n                    {\n                        if (atomic_cmpxchg_i32_global(global_failure, -1, 24) ==\n                            -1) {\n                            global_failure_args[0] = i_21800;\n                            global_failure_args[1] = steps_18529;\n                            ;\n                        }\n                        local_failure = true;\n                        goto error_0;\n                    }\n                }\n                \n                float shortstep_arg_21804 = ((__global\n                                              float *) mem_23288)[i_21800 *\n                                                                  paths_18528 +\n                                                                  gtid_21541];\n                float shortstep_arg_21805 = ((__global\n                                              float *) mem_23291)[phys_tid_21542 +\n                                                                  i_21800 *\n                                                                  (num_groups_21794 *\n                                                                   segmap_group_sizze_21793)];\n                float y_21806 = 5.0e-2F - shortstep_arg_21805;\n                float x_21807 = 1.0e-2F * y_21806;\n                float x_21808 = dt_18542 * x_21807;\n                float x_21809 = res_18635 * shortstep_arg_21804;\n   ",
                   "             float y_21810 = 1.0e-3F * x_21809;\n                float delta_r_21811 = x_21808 + y_21810;\n                float res_21812 = shortstep_arg_21805 + delta_r_21811;\n                int64_t i_21813 = add64(1, i_21800);\n                bool x_21814 = sle64(0, i_21813);\n                bool y_21815 = slt64(i_21813, steps_18529);\n                bool bounds_check_21816 = x_21814 && y_21815;\n                bool index_certs_21817;\n                \n                if (!bounds_check_21816) {\n                    {\n                        if (atomic_cmpxchg_i32_global(global_failure, -1, 25) ==\n                            -1) {\n                            global_failure_args[0] = i_21813;\n                            global_failure_args[1] = steps_18529;\n                            ;\n                        }\n                        local_failure = true;\n                        goto error_0;\n                    }\n                }\n                ((__global float *) mem_23291)[phys_tid_21542 + i_21813 *\n                                               (num_groups_21794 *\n                                                segmap_group_sizze_21793)] =\n                    res_21812;\n            }\n            for (int64_t i_23620 = 0; i_23620 < steps_18529; i_23620++) {\n                ((__global float *) mem_23306)[i_23620 * paths_18528 +\n                                               gtid_21541] = ((__global\n                                                               float *) mem_23291)[phys_tid_21542 +\n                                                                                   i_23620 *\n                                                                                   (num_groups_21794 *\n                                                                                    segmap_group_sizze_21793)];\n            }\n        }\n        barrier(CLK_GLOBAL_MEM_FENCE | CLK_LOCAL_MEM_FENCE);\n    }\n    \n  error_0:\n    return;\n    #undef segmap_group_sizze_21793\n}\n__kernel ",
                   "void testzisegmap_21640(__global int *global_failure,\n                                 int64_t paths_18528, int64_t steps_18529,\n                                 __global unsigned char *mem_23281, __global\n                                 unsigned char *mem_23285)\n{\n    #define segmap_group_sizze_21748 (testzisegmap_group_sizze_21643)\n    \n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    \n    if (*global_failure >= 0)\n        return;\n    \n    int32_t global_tid_23604;\n    int32_t local_tid_23605;\n    int64_t group_sizze_23608;\n    int32_t wave_sizze_23607;\n    int32_t group_tid_23606;\n    \n    global_tid_23604 = get_global_id(0);\n    local_tid_23605 = get_local_id(0);\n    group_sizze_23608 = get_local_size(0);\n    wave_sizze_23607 = LOCKSTEP_WIDTH;\n    group_tid_23606 = get_group_id(0);\n    \n    int32_t phys_tid_21640;\n    \n    phys_tid_21640 = global_tid_23604;\n    \n    int64_t gtid_21638;\n    \n    gtid_21638 = squot64(sext_i32_i64(group_tid_23606) *\n                         segmap_group_sizze_21748 +\n                         sext_i32_i64(local_tid_23605), steps_18529);\n    \n    int64_t gtid_21639;\n    \n    gtid_21639 = sext_i32_i64(group_tid_23606) * segmap_group_sizze_21748 +\n        sext_i32_i64(local_tid_23605) - squot64(sext_i32_i64(group_tid_23606) *\n                                                segmap_group_sizze_21748 +\n                                                sext_i32_i64(local_tid_23605),\n                                                steps_18529) * steps_18529;\n    if (slt64(gtid_21638, paths_18528) && slt64(gtid_21639, steps_18529)) {\n        int32_t unsign_arg_21751 = ((__global int32_t *) mem_23281)[gtid_21638];\n        int32_t res_21753 = sext_i64_i32(gtid_21639);\n        int32_t x_21754 = lshr32(res_21753, 16);\n        int32_t x_21755 = res_21753 ^ x_21754;\n        int32_t x_21756 = mul32(73244475, x_21755);\n        int32_t x_21757 = lshr32(x_21756, 16);\n        int32_t x_21758 = x_21756 ^ x_217",
                   "57;\n        int32_t x_21759 = mul32(73244475, x_21758);\n        int32_t x_21760 = lshr32(x_21759, 16);\n        int32_t x_21761 = x_21759 ^ x_21760;\n        int32_t unsign_arg_21762 = unsign_arg_21751 ^ x_21761;\n        int32_t unsign_arg_21763 = mul32(48271, unsign_arg_21762);\n        int32_t unsign_arg_21764 = umod32(unsign_arg_21763, 2147483647);\n        int32_t unsign_arg_21765 = mul32(48271, unsign_arg_21764);\n        int32_t unsign_arg_21766 = umod32(unsign_arg_21765, 2147483647);\n        float res_21767 = uitofp_i32_f32(unsign_arg_21764);\n        float res_21768 = res_21767 / 2.1474836e9F;\n        float res_21769 = uitofp_i32_f32(unsign_arg_21766);\n        float res_21770 = res_21769 / 2.1474836e9F;\n        float res_21771;\n        \n        res_21771 = futrts_log32(res_21768);\n        \n        float res_21772 = -2.0F * res_21771;\n        float res_21773;\n        \n        res_21773 = futrts_sqrt32(res_21772);\n        \n        float res_21774 = 6.2831855F * res_21770;\n        float res_21775;\n        \n        res_21775 = futrts_cos32(res_21774);\n        \n        float res_21776 = res_21773 * res_21775;\n        \n        ((__global float *) mem_23285)[gtid_21638 * steps_18529 + gtid_21639] =\n            res_21776;\n    }\n    \n  error_0:\n    return;\n    #undef segmap_group_sizze_21748\n}\n__kernel void testzisegmap_21704(__global int *global_failure,\n                                 int64_t paths_18528, __global\n                                 unsigned char *mem_23281)\n{\n    #define segmap_group_sizze_21723 (testzisegmap_group_sizze_21706)\n    \n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    \n    if (*global_failure >= 0)\n        return;\n    \n    int32_t global_tid_23599;\n    int32_t local_tid_23600;\n    int64_t group_sizze_23603;\n    int32_t wave_sizze_23602;\n    int32_t group_tid_23601;\n    \n    global_tid_23599 = get_global_id(0);\n    local_tid_23600 = get_local_id(0);\n    group_sizze_23603 = get_local_size(0);\n    wav",
                   "e_sizze_23602 = LOCKSTEP_WIDTH;\n    group_tid_23601 = get_group_id(0);\n    \n    int32_t phys_tid_21704;\n    \n    phys_tid_21704 = global_tid_23599;\n    \n    int64_t gtid_21703;\n    \n    gtid_21703 = sext_i32_i64(group_tid_23601) * segmap_group_sizze_21723 +\n        sext_i32_i64(local_tid_23600);\n    if (slt64(gtid_21703, paths_18528)) {\n        int32_t res_21727 = sext_i64_i32(gtid_21703);\n        int32_t x_21728 = lshr32(res_21727, 16);\n        int32_t x_21729 = res_21727 ^ x_21728;\n        int32_t x_21730 = mul32(73244475, x_21729);\n        int32_t x_21731 = lshr32(x_21730, 16);\n        int32_t x_21732 = x_21730 ^ x_21731;\n        int32_t x_21733 = mul32(73244475, x_21732);\n        int32_t x_21734 = lshr32(x_21733, 16);\n        int32_t x_21735 = x_21733 ^ x_21734;\n        int32_t unsign_arg_21736 = 777822902 ^ x_21735;\n        int32_t unsign_arg_21737 = mul32(48271, unsign_arg_21736);\n        int32_t unsign_arg_21738 = umod32(unsign_arg_21737, 2147483647);\n        \n        ((__global int32_t *) mem_23281)[gtid_21703] = unsign_arg_21738;\n    }\n    \n  error_0:\n    return;\n    #undef segmap_group_sizze_21723\n}\n__kernel void testzisegmap_21979(__global int *global_failure,\n                                 int failure_is_an_option, __global\n                                 int64_t *global_failure_args,\n                                 int64_t paths_18528, int64_t steps_18529,\n                                 float sims_per_year_18620, float res_18697,\n                                 __global unsigned char *res_mem_23275, __global\n                                 unsigned char *res_mem_23276, __global\n                                 unsigned char *res_mem_23277, __global\n                                 unsigned char *res_mem_23278, __global\n                                 unsigned char *mem_23306, __global\n                                 unsigned char *mem_23312)\n{\n    #define segmap_group_sizze_22697 (testzisegmap_group_sizze_21981)\n    \n    const int block_dim0 =",
                   " 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    \n    if (*global_failure >= 0)\n        return;\n    \n    int32_t global_tid_23657;\n    int32_t local_tid_23658;\n    int64_t group_sizze_23661;\n    int32_t wave_sizze_23660;\n    int32_t group_tid_23659;\n    \n    global_tid_23657 = get_global_id(0);\n    local_tid_23658 = get_local_id(0);\n    group_sizze_23661 = get_local_size(0);\n    wave_sizze_23660 = LOCKSTEP_WIDTH;\n    group_tid_23659 = get_group_id(0);\n    \n    int32_t phys_tid_21979;\n    \n    phys_tid_21979 = global_tid_23657;\n    \n    int64_t gtid_21978;\n    \n    gtid_21978 = sext_i32_i64(group_tid_23659) * segmap_group_sizze_22697 +\n        sext_i32_i64(local_tid_23658);\n    if (slt64(gtid_21978, steps_18529)) {\n        int64_t index_primexp_23131 = add64(1, gtid_21978);\n        float res_22703 = sitofp_i64_f32(index_primexp_23131);\n        float res_22704 = res_22703 / sims_per_year_18620;\n        float res_22705;\n        float redout_23196 = 0.0F;\n        \n        for (int64_t i_23197 = 0; i_23197 < paths_18528; i_23197++) {\n            float x_22709 = ((__global float *) mem_23306)[gtid_21978 *\n                                                           paths_18528 +\n                                                           i_23197];\n            float res_22711;\n            float redout_23198 = 0.0F;\n            \n            for (int32_t i_23214 = 0; i_23214 < 9; i_23214++) {\n                int64_t i_23199 = sext_i32_i64(i_23214);\n                int64_t x_22717 = ((__global int64_t *) res_mem_23277)[i_23199];\n                float x_22718 = ((__global float *) res_mem_23278)[i_23199];\n                int64_t i64_arg_22719 = sub64(x_22717, 1);\n                float res_22720 = sitofp_i64_f32(i64_arg_22719);\n                float y_22721 = x_22718 * res_22720;\n                bool cond_22722 = y_22721 < res_22704;\n                float ceil_arg_22723 = res_22704 / x_22718;\n                float res_22724;\n                \n                res_",
                   "22724 = futrts_ceil32(ceil_arg_22723);\n                \n                int64_t res_22725 = fptosi_f32_i64(res_22724);\n                int64_t remaining_22726 = sub64(x_22717, res_22725);\n                float res_22727;\n                \n                if (cond_22722) {\n                    res_22727 = 0.0F;\n                } else {\n                    float x_22715 = ((__global float *) res_mem_23275)[i_23199];\n                    float x_22716 = ((__global float *) res_mem_23276)[i_23199];\n                    float nextpayment_22728 = x_22718 * res_22724;\n                    bool bounds_invalid_upwards_22729 = slt64(remaining_22726,\n                                                              1);\n                    bool valid_22730 = !bounds_invalid_upwards_22729;\n                    bool range_valid_c_22731;\n                    \n                    if (!valid_22730) {\n                        {\n                            if (atomic_cmpxchg_i32_global(global_failure, -1,\n                                                          28) == -1) {\n                                global_failure_args[0] = 1;\n                                global_failure_args[1] = 2;\n                                global_failure_args[2] = remaining_22726;\n                                ;\n                            }\n                            return;\n                        }\n                    }\n                    \n                    float y_22733 = nextpayment_22728 - res_22704;\n                    float negate_arg_22734 = 1.0e-2F * y_22733;\n                    float exp_arg_22735 = 0.0F - negate_arg_22734;\n                    float res_22736 = fpow32(2.7182817F, exp_arg_22735);\n                    float x_22737 = 1.0F - res_22736;\n                    float B_22738 = x_22737 / 1.0e-2F;\n                    float x_22739 = B_22738 - nextpayment_22728;\n                    float x_22740 = res_22704 + x_22739;\n                    float x_22741 = 4.4999997e-6F * x_22740;\n             ",
                   "       float A1_22742 = x_22741 / 1.0e-4F;\n                    float y_22743 = fpow32(B_22738, 2.0F);\n                    float x_22744 = 1.0000001e-6F * y_22743;\n                    float A2_22745 = x_22744 / 4.0e-2F;\n                    float exp_arg_22746 = A1_22742 - A2_22745;\n                    float res_22747 = fpow32(2.7182817F, exp_arg_22746);\n                    float negate_arg_22748 = x_22709 * B_22738;\n                    float exp_arg_22749 = 0.0F - negate_arg_22748;\n                    float res_22750 = fpow32(2.7182817F, exp_arg_22749);\n                    float res_22751 = res_22747 * res_22750;\n                    bool y_22752 = slt64(0, remaining_22726);\n                    bool index_certs_22753;\n                    \n                    if (!y_22752) {\n                        {\n                            if (atomic_cmpxchg_i32_global(global_failure, -1,\n                                                          29) == -1) {\n                                global_failure_args[0] = 0;\n                                global_failure_args[1] = remaining_22726;\n                                ;\n                            }\n                            return;\n                        }\n                    }\n                    \n                    float binop_y_22754 = sitofp_i64_f32(remaining_22726);\n                    float binop_y_22755 = x_22718 * binop_y_22754;\n                    float index_primexp_22756 = nextpayment_22728 +\n                          binop_y_22755;\n                    float y_22757 = index_primexp_22756 - res_22704;\n                    float negate_arg_22758 = 1.0e-2F * y_22757;\n                    float exp_arg_22759 = 0.0F - negate_arg_22758;\n                    float res_22760 = fpow32(2.7182817F, exp_arg_22759);\n                    float x_22761 = 1.0F - res_22760;\n                    float B_22762 = x_22761 / 1.0e-2F;\n                    float x_22763 = B_22762 - index_primexp_22756;\n                    float x_22764 = res",
                   "_22704 + x_22763;\n                    float x_22765 = 4.4999997e-6F * x_22764;\n                    float A1_22766 = x_22765 / 1.0e-4F;\n                    float y_22767 = fpow32(B_22762, 2.0F);\n                    float x_22768 = 1.0000001e-6F * y_22767;\n                    float A2_22769 = x_22768 / 4.0e-2F;\n                    float exp_arg_22770 = A1_22766 - A2_22769;\n                    float res_22771 = fpow32(2.7182817F, exp_arg_22770);\n                    float negate_arg_22772 = x_22709 * B_22762;\n                    float exp_arg_22773 = 0.0F - negate_arg_22772;\n                    float res_22774 = fpow32(2.7182817F, exp_arg_22773);\n                    float res_22775 = res_22771 * res_22774;\n                    float res_22776;\n                    float redout_23128 = 0.0F;\n                    \n                    for (int64_t i_23129 = 0; i_23129 < remaining_22726;\n                         i_23129++) {\n                        int64_t index_primexp_23161 = add64(1, i_23129);\n                        float res_22781 = sitofp_i64_f32(index_primexp_23161);\n                        float res_22782 = x_22718 * res_22781;\n                        float res_22783 = nextpayment_22728 + res_22782;\n                        float y_22784 = res_22783 - res_22704;\n                        float negate_arg_22785 = 1.0e-2F * y_22784;\n                        float exp_arg_22786 = 0.0F - negate_arg_22785;\n                        float res_22787 = fpow32(2.7182817F, exp_arg_22786);\n                        float x_22788 = 1.0F - res_22787;\n                        float B_22789 = x_22788 / 1.0e-2F;\n                        float x_22790 = B_22789 - res_22783;\n                        float x_22791 = res_22704 + x_22790;\n                        float x_22792 = 4.4999997e-6F * x_22791;\n                        float A1_22793 = x_22792 / 1.0e-4F;\n                        float y_22794 = fpow32(B_22789, 2.0F);\n                        float x_22795 = 1.0000001e-6F * y_22794;\n             ",
                   "           float A2_22796 = x_22795 / 4.0e-2F;\n                        float exp_arg_22797 = A1_22793 - A2_22796;\n                        float res_22798 = fpow32(2.7182817F, exp_arg_22797);\n                        float negate_arg_22799 = x_22709 * B_22789;\n                        float exp_arg_22800 = 0.0F - negate_arg_22799;\n                        float res_22801 = fpow32(2.7182817F, exp_arg_22800);\n                        float res_22802 = res_22798 * res_22801;\n                        float res_22779 = res_22802 + redout_23128;\n                        float redout_tmp_23664 = res_22779;\n                        \n                        redout_23128 = redout_tmp_23664;\n                    }\n                    res_22776 = redout_23128;\n                    \n                    float x_22803 = res_22751 - res_22775;\n                    float x_22804 = x_22715 * x_22718;\n                    float y_22805 = res_22776 * x_22804;\n                    float y_22806 = x_22803 - y_22805;\n                    float res_22807 = x_22716 * y_22806;\n                    \n                    res_22727 = res_22807;\n                }\n                \n                float res_22714 = res_22727 + redout_23198;\n                float redout_tmp_23663 = res_22714;\n                \n                redout_23198 = redout_tmp_23663;\n            }\n            res_22711 = redout_23198;\n            \n            float res_22808 = fmax32(0.0F, res_22711);\n            float res_22708 = res_22808 + redout_23196;\n            float redout_tmp_23662 = res_22708;\n            \n            redout_23196 = redout_tmp_23662;\n        }\n        res_22705 = redout_23196;\n        \n        float res_22809 = res_22705 / res_18697;\n        float negate_arg_22810 = 1.0e-2F * res_22704;\n        float exp_arg_22811 = 0.0F - negate_arg_22810;\n        float res_22812 = fpow32(2.7182817F, exp_arg_22811);\n        float x_22813 = 1.0F - res_22812;\n        float B_22814 = x_22813 / 1.0e-2F;\n        float x_22815 = B_2281",
                   "4 - res_22704;\n        float x_22816 = 4.4999997e-6F * x_22815;\n        float A1_22817 = x_22816 / 1.0e-4F;\n        float y_22818 = fpow32(B_22814, 2.0F);\n        float x_22819 = 1.0000001e-6F * y_22818;\n        float A2_22820 = x_22819 / 4.0e-2F;\n        float exp_arg_22821 = A1_22817 - A2_22820;\n        float res_22822 = fpow32(2.7182817F, exp_arg_22821);\n        float negate_arg_22823 = 5.0e-2F * B_22814;\n        float exp_arg_22824 = 0.0F - negate_arg_22823;\n        float res_22825 = fpow32(2.7182817F, exp_arg_22824);\n        float res_22826 = res_22822 * res_22825;\n        float res_22827 = res_22809 * res_22826;\n        \n        ((__global float *) mem_23312)[gtid_21978] = res_22827;\n    }\n    \n  error_0:\n    return;\n    #undef segmap_group_sizze_22697\n}\n__kernel void testzisegmap_22381(__global int *global_failure,\n                                 int64_t steps_18529, float sims_per_year_18620,\n                                 float res_18697, __global\n                                 unsigned char *mem_23319, __global\n                                 unsigned char *mem_23322)\n{\n    #define segmap_group_sizze_23077 (testzisegmap_group_sizze_22383)\n    \n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    \n    if (*global_failure >= 0)\n        return;\n    \n    int32_t global_tid_23741;\n    int32_t local_tid_23742;\n    int64_t group_sizze_23745;\n    int32_t wave_sizze_23744;\n    int32_t group_tid_23743;\n    \n    global_tid_23741 = get_global_id(0);\n    local_tid_23742 = get_local_id(0);\n    group_sizze_23745 = get_local_size(0);\n    wave_sizze_23744 = LOCKSTEP_WIDTH;\n    group_tid_23743 = get_group_id(0);\n    \n    int32_t phys_tid_22381;\n    \n    phys_tid_22381 = global_tid_23741;\n    \n    int64_t gtid_22380;\n    \n    gtid_22380 = sext_i32_i64(group_tid_23743) * segmap_group_sizze_23077 +\n        sext_i32_i64(local_tid_23742);\n    if (slt64(gtid_22380, steps_18529)) {\n        int64_t convop_x_23149 = add64(1, gtid_22380)",
                   ";\n        float binop_x_23150 = sitofp_i64_f32(convop_x_23149);\n        float index_primexp_23151 = binop_x_23150 / sims_per_year_18620;\n        float res_23081 = ((__global float *) mem_23319)[gtid_22380];\n        float res_23082 = res_23081 / res_18697;\n        float negate_arg_23083 = 1.0e-2F * index_primexp_23151;\n        float exp_arg_23084 = 0.0F - negate_arg_23083;\n        float res_23085 = fpow32(2.7182817F, exp_arg_23084);\n        float x_23086 = 1.0F - res_23085;\n        float B_23087 = x_23086 / 1.0e-2F;\n        float x_23088 = B_23087 - index_primexp_23151;\n        float x_23089 = 4.4999997e-6F * x_23088;\n        float A1_23090 = x_23089 / 1.0e-4F;\n        float y_23091 = fpow32(B_23087, 2.0F);\n        float x_23092 = 1.0000001e-6F * y_23091;\n        float A2_23093 = x_23092 / 4.0e-2F;\n        float exp_arg_23094 = A1_23090 - A2_23093;\n        float res_23095 = fpow32(2.7182817F, exp_arg_23094);\n        float negate_arg_23096 = 5.0e-2F * B_23087;\n        float exp_arg_23097 = 0.0F - negate_arg_23096;\n        float res_23098 = fpow32(2.7182817F, exp_arg_23097);\n        float res_23099 = res_23095 * res_23098;\n        float res_23100 = res_23082 * res_23099;\n        \n        ((__global float *) mem_23322)[gtid_22380] = res_23100;\n    }\n    \n  error_0:\n    return;\n    #undef segmap_group_sizze_23077\n}\n__kernel void testzisegmap_intragroup_21977(__global int *global_failure,\n                                            int failure_is_an_option, __global\n                                            int64_t *global_failure_args,\n                                            __local volatile\n                                            int64_t *red_arr_mem_23671_backing_aligned_0,\n                                            int64_t paths_18528,\n                                            float sims_per_year_18620,\n                                            float res_18697, __global\n                                            unsigned char *res_mem_23275,\n          ",
                   "                                  __global\n                                            unsigned char *res_mem_23276,\n                                            __global\n                                            unsigned char *res_mem_23277,\n                                            __global\n                                            unsigned char *res_mem_23278,\n                                            __global unsigned char *mem_23306,\n                                            __global unsigned char *mem_23316)\n{\n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    __local volatile char *restrict red_arr_mem_23671_backing_0 =\n                          (__local volatile\n                           char *) red_arr_mem_23671_backing_aligned_0;\n    volatile __local bool local_failure;\n    \n    if (failure_is_an_option) {\n        int failed = *global_failure >= 0;\n        \n        if (failed)\n            return;\n    }\n    local_failure = false;\n    barrier(CLK_LOCAL_MEM_FENCE);\n    \n    int32_t global_tid_23665;\n    int32_t local_tid_23666;\n    int64_t group_sizze_23669;\n    int32_t wave_sizze_23668;\n    int32_t group_tid_23667;\n    \n    global_tid_23665 = get_global_id(0);\n    local_tid_23666 = get_local_id(0);\n    group_sizze_23669 = get_local_size(0);\n    wave_sizze_23668 = LOCKSTEP_WIDTH;\n    group_tid_23667 = get_group_id(0);\n    \n    int32_t phys_tid_21977;\n    \n    phys_tid_21977 = group_tid_23667;\n    \n    int32_t ltid_pre_23670;\n    \n    ltid_pre_23670 = local_tid_23666;\n    \n    int64_t gtid_21972;\n    \n    gtid_21972 = sext_i32_i64(group_tid_23667);\n    \n    int64_t index_primexp_23139;\n    \n    index_primexp_23139 = add64(1, gtid_21972);\n    \n    float res_22833 = sitofp_i64_f32(index_primexp_23139);\n    float res_22834 = res_22833 / sims_per_year_18620;\n    float res_22835;\n    int64_t gtid_21975 = sext_i32_i64(ltid_pre_23670);\n    int32_t phys_tid_21976 = local_tid_23666;\n    __local char *red_arr_mem_2367",
                   "1;\n    \n    red_arr_mem_23671 = (__local char *) red_arr_mem_23671_backing_0;\n    if (slt64(gtid_21975, paths_18528)) {\n        float x_22839 = ((__global float *) mem_23306)[gtid_21972 *\n                                                       paths_18528 +\n                                                       gtid_21975];\n        float res_22841;\n        float redout_23200 = 0.0F;\n        \n        for (int32_t i_23218 = 0; i_23218 < 9; i_23218++) {\n            int64_t i_23201 = sext_i32_i64(i_23218);\n            int64_t x_22847 = ((__global int64_t *) res_mem_23277)[i_23201];\n            float x_22848 = ((__global float *) res_mem_23278)[i_23201];\n            int64_t i64_arg_22849 = sub64(x_22847, 1);\n            float res_22850 = sitofp_i64_f32(i64_arg_22849);\n            float y_22851 = x_22848 * res_22850;\n            bool cond_22852 = y_22851 < res_22834;\n            float ceil_arg_22853 = res_22834 / x_22848;\n            float res_22854;\n            \n            res_22854 = futrts_ceil32(ceil_arg_22853);\n            \n            int64_t res_22855 = fptosi_f32_i64(res_22854);\n            int64_t remaining_22856 = sub64(x_22847, res_22855);\n            float res_22857;\n            \n            if (cond_22852) {\n                res_22857 = 0.0F;\n            } else {\n                float x_22845 = ((__global float *) res_mem_23275)[i_23201];\n                float x_22846 = ((__global float *) res_mem_23276)[i_23201];\n                float nextpayment_22858 = x_22848 * res_22854;\n                bool bounds_invalid_upwards_22859 = slt64(remaining_22856, 1);\n                bool valid_22860 = !bounds_invalid_upwards_22859;\n                bool range_valid_c_22861;\n                \n                if (!valid_22860) {\n                    {\n                        if (atomic_cmpxchg_i32_global(global_failure, -1, 30) ==\n                            -1) {\n                            global_failure_args[0] = 1;\n                            global_failure_args[1] = 2;\n    ",
                   "                        global_failure_args[2] = remaining_22856;\n                            ;\n                        }\n                        local_failure = true;\n                        goto error_0;\n                    }\n                }\n                \n                float y_22863 = nextpayment_22858 - res_22834;\n                float negate_arg_22864 = 1.0e-2F * y_22863;\n                float exp_arg_22865 = 0.0F - negate_arg_22864;\n                float res_22866 = fpow32(2.7182817F, exp_arg_22865);\n                float x_22867 = 1.0F - res_22866;\n                float B_22868 = x_22867 / 1.0e-2F;\n                float x_22869 = B_22868 - nextpayment_22858;\n                float x_22870 = res_22834 + x_22869;\n                float x_22871 = 4.4999997e-6F * x_22870;\n                float A1_22872 = x_22871 / 1.0e-4F;\n                float y_22873 = fpow32(B_22868, 2.0F);\n                float x_22874 = 1.0000001e-6F * y_22873;\n                float A2_22875 = x_22874 / 4.0e-2F;\n                float exp_arg_22876 = A1_22872 - A2_22875;\n                float res_22877 = fpow32(2.7182817F, exp_arg_22876);\n                float negate_arg_22878 = x_22839 * B_22868;\n                float exp_arg_22879 = 0.0F - negate_arg_22878;\n                float res_22880 = fpow32(2.7182817F, exp_arg_22879);\n                float res_22881 = res_22877 * res_22880;\n                bool y_22882 = slt64(0, remaining_22856);\n                bool index_certs_22883;\n                \n                if (!y_22882) {\n                    {\n                        if (atomic_cmpxchg_i32_global(global_failure, -1, 31) ==\n                            -1) {\n                            global_failure_args[0] = 0;\n                            global_failure_args[1] = remaining_22856;\n                            ;\n                        }\n                        local_failure = true;\n                        goto error_0;\n                    }\n                }\n                \n          ",
                   "      float binop_y_22884 = sitofp_i64_f32(remaining_22856);\n                float binop_y_22885 = x_22848 * binop_y_22884;\n                float index_primexp_22886 = nextpayment_22858 + binop_y_22885;\n                float y_22887 = index_primexp_22886 - res_22834;\n                float negate_arg_22888 = 1.0e-2F * y_22887;\n                float exp_arg_22889 = 0.0F - negate_arg_22888;\n                float res_22890 = fpow32(2.7182817F, exp_arg_22889);\n                float x_22891 = 1.0F - res_22890;\n                float B_22892 = x_22891 / 1.0e-2F;\n                float x_22893 = B_22892 - index_primexp_22886;\n                float x_22894 = res_22834 + x_22893;\n                float x_22895 = 4.4999997e-6F * x_22894;\n                float A1_22896 = x_22895 / 1.0e-4F;\n                float y_22897 = fpow32(B_22892, 2.0F);\n                float x_22898 = 1.0000001e-6F * y_22897;\n                float A2_22899 = x_22898 / 4.0e-2F;\n                float exp_arg_22900 = A1_22896 - A2_22899;\n                float res_22901 = fpow32(2.7182817F, exp_arg_22900);\n                float negate_arg_22902 = x_22839 * B_22892;\n                float exp_arg_22903 = 0.0F - negate_arg_22902;\n                float res_22904 = fpow32(2.7182817F, exp_arg_22903);\n                float res_22905 = res_22901 * res_22904;\n                float res_22906;\n                float redout_23132 = 0.0F;\n                \n                for (int64_t i_23133 = 0; i_23133 < remaining_22856;\n                     i_23133++) {\n                    int64_t index_primexp_23163 = add64(1, i_23133);\n                    float res_22911 = sitofp_i64_f32(index_primexp_23163);\n                    float res_22912 = x_22848 * res_22911;\n                    float res_22913 = nextpayment_22858 + res_22912;\n                    float y_22914 = res_22913 - res_22834;\n                    float negate_arg_22915 = 1.0e-2F * y_22914;\n                    float exp_arg_22916 = 0.0F - negate_arg_22915;\n               ",
                   "     float res_22917 = fpow32(2.7182817F, exp_arg_22916);\n                    float x_22918 = 1.0F - res_22917;\n                    float B_22919 = x_22918 / 1.0e-2F;\n                    float x_22920 = B_22919 - res_22913;\n                    float x_22921 = res_22834 + x_22920;\n                    float x_22922 = 4.4999997e-6F * x_22921;\n                    float A1_22923 = x_22922 / 1.0e-4F;\n                    float y_22924 = fpow32(B_22919, 2.0F);\n                    float x_22925 = 1.0000001e-6F * y_22924;\n                    float A2_22926 = x_22925 / 4.0e-2F;\n                    float exp_arg_22927 = A1_22923 - A2_22926;\n                    float res_22928 = fpow32(2.7182817F, exp_arg_22927);\n                    float negate_arg_22929 = x_22839 * B_22919;\n                    float exp_arg_22930 = 0.0F - negate_arg_22929;\n                    float res_22931 = fpow32(2.7182817F, exp_arg_22930);\n                    float res_22932 = res_22928 * res_22931;\n                    float res_22909 = res_22932 + redout_23132;\n                    float redout_tmp_23674 = res_22909;\n                    \n                    redout_23132 = redout_tmp_23674;\n                }\n                res_22906 = redout_23132;\n                \n                float x_22933 = res_22881 - res_22905;\n                float x_22934 = x_22845 * x_22848;\n                float y_22935 = res_22906 * x_22934;\n                float y_22936 = x_22933 - y_22935;\n                float res_22937 = x_22846 * y_22936;\n                \n                res_22857 = res_22937;\n            }\n            \n            float res_22844 = res_22857 + redout_23200;\n            float redout_tmp_23673 = res_22844;\n            \n            redout_23200 = redout_tmp_23673;\n        }\n        res_22841 = redout_23200;\n        \n        float res_22938 = fmax32(0.0F, res_22841);\n        \n        ((__local float *) red_arr_mem_23671)[gtid_21975] = res_22938;\n    }\n    \n  error_0:\n    barrier(CLK_LOCAL_MEM_FENCE);\n    if",
                   " (local_failure)\n        return;\n    barrier(CLK_LOCAL_MEM_FENCE);\n    \n    int32_t offset_23675;\n    int32_t skip_waves_23676;\n    \n    skip_waves_23676 = 1;\n    \n    float x_22836;\n    float x_22837;\n    \n    offset_23675 = 0;\n    // participating threads read initial accumulator\n    {\n        if (slt32(local_tid_23666, sext_i64_i32(paths_18528))) {\n            x_22836 = ((__local\n                        float *) red_arr_mem_23671)[sext_i32_i64(local_tid_23666 +\n                                                    offset_23675)];\n        }\n    }\n    offset_23675 = 1;\n    while (slt32(offset_23675, wave_sizze_23668)) {\n        if (slt32(local_tid_23666 + offset_23675, sext_i64_i32(paths_18528)) &&\n            ((local_tid_23666 - squot32(local_tid_23666, wave_sizze_23668) *\n              wave_sizze_23668) & (2 * offset_23675 - 1)) == 0) {\n            // read array element\n            {\n                x_22837 = ((volatile __local\n                            float *) red_arr_mem_23671)[sext_i32_i64(local_tid_23666 +\n                                                        offset_23675)];\n            }\n            // apply reduction operation\n            {\n                float res_22838 = x_22836 + x_22837;\n                \n                x_22836 = res_22838;\n            }\n            // write result of operation\n            {\n                ((volatile __local\n                  float *) red_arr_mem_23671)[sext_i32_i64(local_tid_23666)] =\n                    x_22836;\n            }\n        }\n        offset_23675 *= 2;\n    }\n    while (slt32(skip_waves_23676, squot32(sext_i64_i32(paths_18528) +\n                                           wave_sizze_23668 - 1,\n                                           wave_sizze_23668))) {\n        barrier(CLK_LOCAL_MEM_FENCE);\n        offset_23675 = skip_waves_23676 * wave_sizze_23668;\n        if (slt32(local_tid_23666 + offset_23675, sext_i64_i32(paths_18528)) &&\n            ((local_tid_23666 - squot32(local_tid_23666, wave_sizze_23668)",
                   " *\n              wave_sizze_23668) == 0 && (squot32(local_tid_23666,\n                                                 wave_sizze_23668) & (2 *\n                                                                      skip_waves_23676 -\n                                                                      1)) ==\n             0)) {\n            // read array element\n            {\n                x_22837 = ((__local\n                            float *) red_arr_mem_23671)[sext_i32_i64(local_tid_23666 +\n                                                        offset_23675)];\n            }\n            // apply reduction operation\n            {\n                float res_22838 = x_22836 + x_22837;\n                \n                x_22836 = res_22838;\n            }\n            // write result of operation\n            {\n                ((__local\n                  float *) red_arr_mem_23671)[sext_i32_i64(local_tid_23666)] =\n                    x_22836;\n            }\n        }\n        skip_waves_23676 *= 2;\n    }\n    barrier(CLK_LOCAL_MEM_FENCE);\n    res_22835 = ((__local float *) red_arr_mem_23671)[0];\n    \n    float res_22939 = res_22835 / res_18697;\n    float negate_arg_22940 = 1.0e-2F * res_22834;\n    float exp_arg_22941 = 0.0F - negate_arg_22940;\n    float res_22942 = fpow32(2.7182817F, exp_arg_22941);\n    float x_22943 = 1.0F - res_22942;\n    float B_22944 = x_22943 / 1.0e-2F;\n    float x_22945 = B_22944 - res_22834;\n    float x_22946 = 4.4999997e-6F * x_22945;\n    float A1_22947 = x_22946 / 1.0e-4F;\n    float y_22948 = fpow32(B_22944, 2.0F);\n    float x_22949 = 1.0000001e-6F * y_22948;\n    float A2_22950 = x_22949 / 4.0e-2F;\n    float exp_arg_22951 = A1_22947 - A2_22950;\n    float res_22952 = fpow32(2.7182817F, exp_arg_22951);\n    float negate_arg_22953 = 5.0e-2F * B_22944;\n    float exp_arg_22954 = 0.0F - negate_arg_22953;\n    float res_22955 = fpow32(2.7182817F, exp_arg_22954);\n    float res_22956 = res_22952 * res_22955;\n    float res_22957 = res_22939 * res_22956;\n    \n   ",
                   " if (local_tid_23666 == 0) {\n        ((__global float *) mem_23316)[gtid_21972] = res_22957;\n    }\n    \n  error_2:\n    return;\n}\n__kernel void testzisegred_large_22416(__global int *global_failure,\n                                       int failure_is_an_option, __global\n                                       int64_t *global_failure_args,\n                                       __local volatile\n                                       int64_t *sync_arr_mem_23716_backing_aligned_0,\n                                       __local volatile\n                                       int64_t *red_arr_mem_23714_backing_aligned_1,\n                                       int64_t paths_18528,\n                                       float sims_per_year_18620,\n                                       int64_t num_groups_22968, __global\n                                       unsigned char *res_mem_23275, __global\n                                       unsigned char *res_mem_23276, __global\n                                       unsigned char *res_mem_23277, __global\n                                       unsigned char *res_mem_23278, __global\n                                       unsigned char *mem_23306, __global\n                                       unsigned char *mem_23319,\n                                       int64_t groups_per_segment_23700,\n                                       int64_t elements_per_thread_23701,\n                                       int64_t virt_num_groups_23702,\n                                       int64_t threads_per_segment_23704,\n                                       __global\n                                       unsigned char *group_res_arr_mem_23705,\n                                       __global\n                                       unsigned char *testzicounter_mem_23707)\n{\n    #define segred_group_sizze_22967 (testzisegred_group_sizze_22410)\n    \n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    __local v",
                   "olatile char *restrict sync_arr_mem_23716_backing_1 =\n                          (__local volatile\n                           char *) sync_arr_mem_23716_backing_aligned_0;\n    __local volatile char *restrict red_arr_mem_23714_backing_0 =\n                          (__local volatile\n                           char *) red_arr_mem_23714_backing_aligned_1;\n    volatile __local bool local_failure;\n    \n    if (failure_is_an_option) {\n        int failed = *global_failure >= 0;\n        \n        if (failed)\n            return;\n    }\n    local_failure = false;\n    barrier(CLK_LOCAL_MEM_FENCE);\n    \n    int32_t global_tid_23709;\n    int32_t local_tid_23710;\n    int64_t group_sizze_23713;\n    int32_t wave_sizze_23712;\n    int32_t group_tid_23711;\n    \n    global_tid_23709 = get_global_id(0);\n    local_tid_23710 = get_local_id(0);\n    group_sizze_23713 = get_local_size(0);\n    wave_sizze_23712 = LOCKSTEP_WIDTH;\n    group_tid_23711 = get_group_id(0);\n    \n    int32_t phys_tid_22416;\n    \n    phys_tid_22416 = global_tid_23709;\n    \n    __local char *red_arr_mem_23714;\n    \n    red_arr_mem_23714 = (__local char *) red_arr_mem_23714_backing_0;\n    \n    __local char *sync_arr_mem_23716;\n    \n    sync_arr_mem_23716 = (__local char *) sync_arr_mem_23716_backing_1;\n    \n    int32_t phys_group_id_23718;\n    \n    phys_group_id_23718 = get_group_id(0);\n    for (int32_t i_23719 = 0; i_23719 <\n         sdiv_up32(sext_i64_i32(virt_num_groups_23702) - phys_group_id_23718,\n                   sext_i64_i32(num_groups_22968)); i_23719++) {\n        int32_t virt_group_id_23720 = phys_group_id_23718 + i_23719 *\n                sext_i64_i32(num_groups_22968);\n        int32_t flat_segment_id_23721 = squot32(virt_group_id_23720,\n                                                sext_i64_i32(groups_per_segment_23700));\n        int64_t global_tid_23722 = srem64(sext_i32_i64(virt_group_id_23720) *\n                                          segred_group_sizze_22967 +\n                                          se",
                   "xt_i32_i64(local_tid_23710),\n                                          segred_group_sizze_22967 *\n                                          groups_per_segment_23700);\n        int64_t gtid_22407 = sext_i32_i64(flat_segment_id_23721);\n        int64_t gtid_22415;\n        float x_acc_23723;\n        int64_t chunk_sizze_23724;\n        \n        chunk_sizze_23724 = smin64(elements_per_thread_23701,\n                                   sdiv_up64(paths_18528 -\n                                             sext_i32_i64(sext_i64_i32(global_tid_23722)),\n                                             threads_per_segment_23704));\n        \n        float x_22971;\n        float x_22972;\n        \n        // neutral-initialise the accumulators\n        {\n            x_acc_23723 = 0.0F;\n        }\n        for (int64_t i_23728 = 0; i_23728 < chunk_sizze_23724; i_23728++) {\n            gtid_22415 = sext_i32_i64(sext_i64_i32(global_tid_23722)) +\n                threads_per_segment_23704 * i_23728;\n            // apply map function\n            {\n                float x_22976 = ((__global float *) mem_23306)[gtid_22407 *\n                                                               paths_18528 +\n                                                               gtid_22415];\n                int64_t convop_x_23145 = add64(1, gtid_22407);\n                float binop_x_23146 = sitofp_i64_f32(convop_x_23145);\n                float index_primexp_23147 = binop_x_23146 / sims_per_year_18620;\n                float res_22978;\n                float redout_23202 = 0.0F;\n                \n                for (int32_t i_23219 = 0; i_23219 < 9; i_23219++) {\n                    int64_t i_23203 = sext_i32_i64(i_23219);\n                    int64_t x_22984 = ((__global\n                                        int64_t *) res_mem_23277)[i_23203];\n                    float x_22985 = ((__global float *) res_mem_23278)[i_23203];\n                    int64_t i64_arg_22986 = sub64(x_22984, 1);\n                    float res_22987 ",
                   "= sitofp_i64_f32(i64_arg_22986);\n                    float y_22988 = x_22985 * res_22987;\n                    bool cond_22989 = y_22988 < index_primexp_23147;\n                    float ceil_arg_22990 = index_primexp_23147 / x_22985;\n                    float res_22991;\n                    \n                    res_22991 = futrts_ceil32(ceil_arg_22990);\n                    \n                    int64_t res_22992 = fptosi_f32_i64(res_22991);\n                    int64_t remaining_22993 = sub64(x_22984, res_22992);\n                    float res_22994;\n                    \n                    if (cond_22989) {\n                        res_22994 = 0.0F;\n                    } else {\n                        float x_22982 = ((__global\n                                          float *) res_mem_23275)[i_23203];\n                        float x_22983 = ((__global\n                                          float *) res_mem_23276)[i_23203];\n                        float nextpayment_22995 = x_22985 * res_22991;\n                        bool bounds_invalid_upwards_22996 =\n                             slt64(remaining_22993, 1);\n                        bool valid_22997 = !bounds_invalid_upwards_22996;\n                        bool range_valid_c_22998;\n                        \n                        if (!valid_22997) {\n                            {\n                                if (atomic_cmpxchg_i32_global(global_failure,\n                                                              -1, 34) == -1) {\n                                    global_failure_args[0] = 1;\n                                    global_failure_args[1] = 2;\n                                    global_failure_args[2] = remaining_22993;\n                                    ;\n                                }\n                                local_failure = true;\n                                goto error_0;\n                            }\n                        }\n                        \n                        float y_23000 ",
                   "= nextpayment_22995 - index_primexp_23147;\n                        float negate_arg_23001 = 1.0e-2F * y_23000;\n                        float exp_arg_23002 = 0.0F - negate_arg_23001;\n                        float res_23003 = fpow32(2.7182817F, exp_arg_23002);\n                        float x_23004 = 1.0F - res_23003;\n                        float B_23005 = x_23004 / 1.0e-2F;\n                        float x_23006 = B_23005 - nextpayment_22995;\n                        float x_23007 = x_23006 + index_primexp_23147;\n                        float x_23008 = 4.4999997e-6F * x_23007;\n                        float A1_23009 = x_23008 / 1.0e-4F;\n                        float y_23010 = fpow32(B_23005, 2.0F);\n                        float x_23011 = 1.0000001e-6F * y_23010;\n                        float A2_23012 = x_23011 / 4.0e-2F;\n                        float exp_arg_23013 = A1_23009 - A2_23012;\n                        float res_23014 = fpow32(2.7182817F, exp_arg_23013);\n                        float negate_arg_23015 = x_22976 * B_23005;\n                        float exp_arg_23016 = 0.0F - negate_arg_23015;\n                        float res_23017 = fpow32(2.7182817F, exp_arg_23016);\n                        float res_23018 = res_23014 * res_23017;\n                        bool y_23019 = slt64(0, remaining_22993);\n                        bool index_certs_23020;\n                        \n                        if (!y_23019) {\n                            {\n                                if (atomic_cmpxchg_i32_global(global_failure,\n                                                              -1, 35) == -1) {\n                                    global_failure_args[0] = 0;\n                                    global_failure_args[1] = remaining_22993;\n                                    ;\n                                }\n                                local_failure = true;\n                                goto error_0;\n                            }\n                        }\n          ",
                   "              \n                        float binop_y_23021 = sitofp_i64_f32(remaining_22993);\n                        float binop_y_23022 = x_22985 * binop_y_23021;\n                        float index_primexp_23023 = nextpayment_22995 +\n                              binop_y_23022;\n                        float y_23024 = index_primexp_23023 -\n                              index_primexp_23147;\n                        float negate_arg_23025 = 1.0e-2F * y_23024;\n                        float exp_arg_23026 = 0.0F - negate_arg_23025;\n                        float res_23027 = fpow32(2.7182817F, exp_arg_23026);\n                        float x_23028 = 1.0F - res_23027;\n                        float B_23029 = x_23028 / 1.0e-2F;\n                        float x_23030 = B_23029 - index_primexp_23023;\n                        float x_23031 = x_23030 + index_primexp_23147;\n                        float x_23032 = 4.4999997e-6F * x_23031;\n                        float A1_23033 = x_23032 / 1.0e-4F;\n                        float y_23034 = fpow32(B_23029, 2.0F);\n                        float x_23035 = 1.0000001e-6F * y_23034;\n                        float A2_23036 = x_23035 / 4.0e-2F;\n                        float exp_arg_23037 = A1_23033 - A2_23036;\n                        float res_23038 = fpow32(2.7182817F, exp_arg_23037);\n                        float negate_arg_23039 = x_22976 * B_23029;\n                        float exp_arg_23040 = 0.0F - negate_arg_23039;\n                        float res_23041 = fpow32(2.7182817F, exp_arg_23040);\n                        float res_23042 = res_23038 * res_23041;\n                        float res_23043;\n                        float redout_23142 = 0.0F;\n                        \n                        for (int64_t i_23143 = 0; i_23143 < remaining_22993;\n                             i_23143++) {\n                            int64_t index_primexp_23165 = add64(1, i_23143);\n                            float res_23048 =\n                                 ",
                   " sitofp_i64_f32(index_primexp_23165);\n                            float res_23049 = x_22985 * res_23048;\n                            float res_23050 = nextpayment_22995 + res_23049;\n                            float y_23051 = res_23050 - index_primexp_23147;\n                            float negate_arg_23052 = 1.0e-2F * y_23051;\n                            float exp_arg_23053 = 0.0F - negate_arg_23052;\n                            float res_23054 = fpow32(2.7182817F, exp_arg_23053);\n                            float x_23055 = 1.0F - res_23054;\n                            float B_23056 = x_23055 / 1.0e-2F;\n                            float x_23057 = B_23056 - res_23050;\n                            float x_23058 = x_23057 + index_primexp_23147;\n                            float x_23059 = 4.4999997e-6F * x_23058;\n                            float A1_23060 = x_23059 / 1.0e-4F;\n                            float y_23061 = fpow32(B_23056, 2.0F);\n                            float x_23062 = 1.0000001e-6F * y_23061;\n                            float A2_23063 = x_23062 / 4.0e-2F;\n                            float exp_arg_23064 = A1_23060 - A2_23063;\n                            float res_23065 = fpow32(2.7182817F, exp_arg_23064);\n                            float negate_arg_23066 = x_22976 * B_23056;\n                            float exp_arg_23067 = 0.0F - negate_arg_23066;\n                            float res_23068 = fpow32(2.7182817F, exp_arg_23067);\n                            float res_23069 = res_23065 * res_23068;\n                            float res_23046 = res_23069 + redout_23142;\n                            float redout_tmp_23730 = res_23046;\n                            \n                            redout_23142 = redout_tmp_23730;\n                        }\n                        res_23043 = redout_23142;\n                        \n                        float x_23070 = res_23018 - res_23042;\n                        float x_23071 = x_22982 * x_22985;\n                 ",
                   "       float y_23072 = res_23043 * x_23071;\n                        float y_23073 = x_23070 - y_23072;\n                        float res_23074 = x_22983 * y_23073;\n                        \n                        res_22994 = res_23074;\n                    }\n                    \n                    float res_22981 = res_22994 + redout_23202;\n                    float redout_tmp_23729 = res_22981;\n                    \n                    redout_23202 = redout_tmp_23729;\n                }\n                res_22978 = redout_23202;\n                \n                float res_23075 = fmax32(0.0F, res_22978);\n                \n                // save map-out results\n                { }\n                // load accumulator\n                {\n                    x_22971 = x_acc_23723;\n                }\n                // load new values\n                {\n                    x_22972 = res_23075;\n                }\n                // apply reduction operator\n                {\n                    float res_22973 = x_22971 + x_22972;\n                    \n                    // store in accumulator\n                    {\n                        x_acc_23723 = res_22973;\n                    }\n                }\n            }\n        }\n        // to reduce current chunk, first store our result in memory\n        {\n            x_22971 = x_acc_23723;\n            ((__local\n              float *) red_arr_mem_23714)[sext_i32_i64(local_tid_23710)] =\n                x_22971;\n        }\n        \n      error_0:\n        barrier(CLK_LOCAL_MEM_FENCE);\n        if (local_failure)\n            return;\n        barrier(CLK_LOCAL_MEM_FENCE);\n        \n        int32_t offset_23731;\n        int32_t skip_waves_23732;\n        \n        skip_waves_23732 = 1;\n        \n        float x_23725;\n        float x_23726;\n        \n        offset_23731 = 0;\n        // participating threads read initial accumulator\n        {\n            if (slt32(local_tid_23710,\n                      sext_i64_i32(segred_group_sizze_22967))) {\n ",
                   "               x_23725 = ((__local\n                            float *) red_arr_mem_23714)[sext_i32_i64(local_tid_23710 +\n                                                        offset_23731)];\n            }\n        }\n        offset_23731 = 1;\n        while (slt32(offset_23731, wave_sizze_23712)) {\n            if (slt32(local_tid_23710 + offset_23731,\n                      sext_i64_i32(segred_group_sizze_22967)) &&\n                ((local_tid_23710 - squot32(local_tid_23710, wave_sizze_23712) *\n                  wave_sizze_23712) & (2 * offset_23731 - 1)) == 0) {\n                // read array element\n                {\n                    x_23726 = ((volatile __local\n                                float *) red_arr_mem_23714)[sext_i32_i64(local_tid_23710 +\n                                                            offset_23731)];\n                }\n                // apply reduction operation\n                {\n                    float res_23727 = x_23725 + x_23726;\n                    \n                    x_23725 = res_23727;\n                }\n                // write result of operation\n                {\n                    ((volatile __local\n                      float *) red_arr_mem_23714)[sext_i32_i64(local_tid_23710)] =\n                        x_23725;\n                }\n            }\n            offset_23731 *= 2;\n        }\n        while (slt32(skip_waves_23732,\n                     squot32(sext_i64_i32(segred_group_sizze_22967) +\n                             wave_sizze_23712 - 1, wave_sizze_23712))) {\n            barrier(CLK_LOCAL_MEM_FENCE);\n            offset_23731 = skip_waves_23732 * wave_sizze_23712;\n            if (slt32(local_tid_23710 + offset_23731,\n                      sext_i64_i32(segred_group_sizze_22967)) &&\n                ((local_tid_23710 - squot32(local_tid_23710, wave_sizze_23712) *\n                  wave_sizze_23712) == 0 && (squot32(local_tid_23710,\n                                                     wave_sizze_23712) & (2 *\n             ",
                   "                                                             skip_waves_23732 -\n                                                                          1)) ==\n                 0)) {\n                // read array element\n                {\n                    x_23726 = ((__local\n                                float *) red_arr_mem_23714)[sext_i32_i64(local_tid_23710 +\n                                                            offset_23731)];\n                }\n                // apply reduction operation\n                {\n                    float res_23727 = x_23725 + x_23726;\n                    \n                    x_23725 = res_23727;\n                }\n                // write result of operation\n                {\n                    ((__local\n                      float *) red_arr_mem_23714)[sext_i32_i64(local_tid_23710)] =\n                        x_23725;\n                }\n            }\n            skip_waves_23732 *= 2;\n        }\n        barrier(CLK_LOCAL_MEM_FENCE);\n        // first thread saves the result in accumulator\n        {\n            if (sext_i32_i64(local_tid_23710) == 0) {\n                x_acc_23723 = x_23725;\n            }\n        }\n        if (groups_per_segment_23700 == 1) {\n            // first thread in group saves final result to memory\n            {\n                if (local_tid_23710 == 0) {\n                    ((__global float *) mem_23319)[gtid_22407] = x_acc_23723;\n                }\n            }\n        } else {\n            int32_t old_counter_23733;\n            \n            // first thread in group saves group result to global memory\n            {\n                if (local_tid_23710 == 0) {\n                    ((__global\n                      float *) group_res_arr_mem_23705)[sext_i32_i64(virt_group_id_23720) *\n                                                        segred_group_sizze_22967] =\n                        x_acc_23723;\n                    mem_fence_global();\n                    old_counter_23733 =\n                        a",
                   "tomic_add_i32_global(&((volatile __global\n                                                 int *) testzicounter_mem_23707)[sext_i32_i64(srem32(flat_segment_id_23721,\n                                                                                                     10240))],\n                                              (int) 1);\n                    ((__local bool *) sync_arr_mem_23716)[0] =\n                        old_counter_23733 == groups_per_segment_23700 - 1;\n                }\n            }\n            barrier(CLK_GLOBAL_MEM_FENCE | CLK_LOCAL_MEM_FENCE);\n            \n            bool is_last_group_23734;\n            \n            is_last_group_23734 = ((__local bool *) sync_arr_mem_23716)[0];\n            if (is_last_group_23734) {\n                if (local_tid_23710 == 0) {\n                    old_counter_23733 =\n                        atomic_add_i32_global(&((volatile __global\n                                                 int *) testzicounter_mem_23707)[sext_i32_i64(srem32(flat_segment_id_23721,\n                                                                                                     10240))],\n                                              (int) (0 -\n                                                     groups_per_segment_23700));\n                }\n                // read in the per-group-results\n                {\n                    int64_t read_per_thread_23735 =\n                            sdiv_up64(groups_per_segment_23700,\n                                      segred_group_sizze_22967);\n                    \n                    x_22971 = 0.0F;\n                    for (int64_t i_23736 = 0; i_23736 < read_per_thread_23735;\n                         i_23736++) {\n                        int64_t group_res_id_23737 =\n                                sext_i32_i64(local_tid_23710) *\n                                read_per_thread_23735 + i_23736;\n                        int64_t index_of_group_res_23738 =\n                                sext_i32_i64(fla",
                   "t_segment_id_23721) *\n                                groups_per_segment_23700 + group_res_id_23737;\n                        \n                        if (slt64(group_res_id_23737,\n                                  groups_per_segment_23700)) {\n                            x_22972 = ((__global\n                                        float *) group_res_arr_mem_23705)[index_of_group_res_23738 *\n                                                                          segred_group_sizze_22967];\n                            \n                            float res_22973;\n                            \n                            res_22973 = x_22971 + x_22972;\n                            x_22971 = res_22973;\n                        }\n                    }\n                }\n                ((__local\n                  float *) red_arr_mem_23714)[sext_i32_i64(local_tid_23710)] =\n                    x_22971;\n                barrier(CLK_LOCAL_MEM_FENCE);\n                // reduce the per-group results\n                {\n                    int32_t offset_23739;\n                    int32_t skip_waves_23740;\n                    \n                    skip_waves_23740 = 1;\n                    \n                    float x_23725;\n                    float x_23726;\n                    \n                    offset_23739 = 0;\n                    // participating threads read initial accumulator\n                    {\n                        if (slt32(local_tid_23710,\n                                  sext_i64_i32(segred_group_sizze_22967))) {\n                            x_23725 = ((__local\n                                        float *) red_arr_mem_23714)[sext_i32_i64(local_tid_23710 +\n                                                                    offset_23739)];\n                        }\n                    }\n                    offset_23739 = 1;\n                    while (slt32(offset_23739, wave_sizze_23712)) {\n                        if (slt32(local_tid_23710 + offset_23739,\n           ",
                   "                       sext_i64_i32(segred_group_sizze_22967)) &&\n                            ((local_tid_23710 - squot32(local_tid_23710,\n                                                        wave_sizze_23712) *\n                              wave_sizze_23712) & (2 * offset_23739 - 1)) ==\n                            0) {\n                            // read array element\n                            {\n                                x_23726 = ((volatile __local\n                                            float *) red_arr_mem_23714)[sext_i32_i64(local_tid_23710 +\n                                                                        offset_23739)];\n                            }\n                            // apply reduction operation\n                            {\n                                float res_23727 = x_23725 + x_23726;\n                                \n                                x_23725 = res_23727;\n                            }\n                            // write result of operation\n                            {\n                                ((volatile __local\n                                  float *) red_arr_mem_23714)[sext_i32_i64(local_tid_23710)] =\n                                    x_23725;\n                            }\n                        }\n                        offset_23739 *= 2;\n                    }\n                    while (slt32(skip_waves_23740,\n                                 squot32(sext_i64_i32(segred_group_sizze_22967) +\n                                         wave_sizze_23712 - 1,\n                                         wave_sizze_23712))) {\n                        barrier(CLK_LOCAL_MEM_FENCE);\n                        offset_23739 = skip_waves_23740 * wave_sizze_23712;\n                        if (slt32(local_tid_23710 + offset_23739,\n                                  sext_i64_i32(segred_group_sizze_22967)) &&\n                            ((local_tid_23710 - squot32(local_tid_23710,\n                                     ",
                   "                   wave_sizze_23712) *\n                              wave_sizze_23712) == 0 &&\n                             (squot32(local_tid_23710, wave_sizze_23712) & (2 *\n                                                                            skip_waves_23740 -\n                                                                            1)) ==\n                             0)) {\n                            // read array element\n                            {\n                                x_23726 = ((__local\n                                            float *) red_arr_mem_23714)[sext_i32_i64(local_tid_23710 +\n                                                                        offset_23739)];\n                            }\n                            // apply reduction operation\n                            {\n                                float res_23727 = x_23725 + x_23726;\n                                \n                                x_23725 = res_23727;\n                            }\n                            // write result of operation\n                            {\n                                ((__local\n                                  float *) red_arr_mem_23714)[sext_i32_i64(local_tid_23710)] =\n                                    x_23725;\n                            }\n                        }\n                        skip_waves_23740 *= 2;\n                    }\n                    // and back to memory with the final result\n                    {\n                        if (local_tid_23710 == 0) {\n                            ((__global float *) mem_23319)[gtid_22407] =\n                                x_23725;\n                        }\n                    }\n                }\n            }\n        }\n        barrier(CLK_GLOBAL_MEM_FENCE | CLK_LOCAL_MEM_FENCE);\n    }\n    \n  error_1:\n    return;\n    #undef segred_group_sizze_22967\n}\n__kernel void testzisegred_nonseg_21019(__global int *global_failure,\n                                        __local ",
                   "volatile\n                                        int64_t *red_arr_mem_23506_backing_aligned_0,\n                                        __local volatile\n                                        int64_t *sync_arr_mem_23504_backing_aligned_1,\n                                        int64_t num_groups_21014, __global\n                                        unsigned char *mem_23223, __global\n                                        unsigned char *mem_23225, __global\n                                        unsigned char *mem_23228, __global\n                                        unsigned char *testzicounter_mem_23494,\n                                        __global\n                                        unsigned char *group_res_arr_mem_23496,\n                                        int64_t num_threads_23498)\n{\n    #define segred_group_sizze_21012 (testzisegred_group_sizze_21011)\n    \n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    __local volatile char *restrict red_arr_mem_23506_backing_1 =\n                          (__local volatile\n                           char *) red_arr_mem_23506_backing_aligned_0;\n    __local volatile char *restrict sync_arr_mem_23504_backing_0 =\n                          (__local volatile\n                           char *) sync_arr_mem_23504_backing_aligned_1;\n    \n    if (*global_failure >= 0)\n        return;\n    \n    int32_t global_tid_23499;\n    int32_t local_tid_23500;\n    int64_t group_sizze_23503;\n    int32_t wave_sizze_23502;\n    int32_t group_tid_23501;\n    \n    global_tid_23499 = get_global_id(0);\n    local_tid_23500 = get_local_id(0);\n    group_sizze_23503 = get_local_size(0);\n    wave_sizze_23502 = LOCKSTEP_WIDTH;\n    group_tid_23501 = get_group_id(0);\n    \n    int32_t phys_tid_21019;\n    \n    phys_tid_21019 = global_tid_23499;\n    \n    __local char *sync_arr_mem_23504;\n    \n    sync_arr_mem_23504 = (__local char *) sync_arr_mem_23504_backing_0;\n    \n    __local char *red_arr_mem_23506;\n  ",
                   "  \n    red_arr_mem_23506 = (__local char *) red_arr_mem_23506_backing_1;\n    \n    int64_t dummy_21017;\n    \n    dummy_21017 = 0;\n    \n    int64_t gtid_21018;\n    \n    gtid_21018 = 0;\n    \n    float x_acc_23508;\n    int64_t chunk_sizze_23509;\n    \n    chunk_sizze_23509 = smin64(sdiv_up64(9,\n                                         sext_i32_i64(sext_i64_i32(segred_group_sizze_21012 *\n                                         num_groups_21014))), sdiv_up64(9 -\n                                                                        sext_i32_i64(phys_tid_21019),\n                                                                        num_threads_23498));\n    \n    float x_18534;\n    float x_18535;\n    \n    // neutral-initialise the accumulators\n    {\n        x_acc_23508 = -INFINITY;\n    }\n    for (int64_t i_23513 = 0; i_23513 < chunk_sizze_23509; i_23513++) {\n        gtid_21018 = sext_i32_i64(phys_tid_21019) + num_threads_23498 * i_23513;\n        // apply map function\n        {\n            float x_18537 = ((__global float *) mem_23225)[gtid_21018];\n            int64_t x_18538 = ((__global int64_t *) mem_23223)[gtid_21018];\n            float res_18539 = sitofp_i64_f32(x_18538);\n            float res_18540 = x_18537 * res_18539;\n            \n            // save map-out results\n            { }\n            // load accumulator\n            {\n                x_18534 = x_acc_23508;\n            }\n            // load new values\n            {\n                x_18535 = res_18540;\n            }\n            // apply reduction operator\n            {\n                float res_18536 = fmax32(x_18534, x_18535);\n                \n                // store in accumulator\n                {\n                    x_acc_23508 = res_18536;\n                }\n            }\n        }\n    }\n    // to reduce current chunk, first store our result in memory\n    {\n        x_18534 = x_acc_23508;\n        ((__local float *) red_arr_mem_23506)[sext_i32_i64(local_tid_23500)] =\n            x_18534;\n    }\n    barrier",
                   "(CLK_LOCAL_MEM_FENCE);\n    \n    int32_t offset_23514;\n    int32_t skip_waves_23515;\n    \n    skip_waves_23515 = 1;\n    \n    float x_23510;\n    float x_23511;\n    \n    offset_23514 = 0;\n    // participating threads read initial accumulator\n    {\n        if (slt32(local_tid_23500, sext_i64_i32(segred_group_sizze_21012))) {\n            x_23510 = ((__local\n                        float *) red_arr_mem_23506)[sext_i32_i64(local_tid_23500 +\n                                                    offset_23514)];\n        }\n    }\n    offset_23514 = 1;\n    while (slt32(offset_23514, wave_sizze_23502)) {\n        if (slt32(local_tid_23500 + offset_23514,\n                  sext_i64_i32(segred_group_sizze_21012)) && ((local_tid_23500 -\n                                                               squot32(local_tid_23500,\n                                                                       wave_sizze_23502) *\n                                                               wave_sizze_23502) &\n                                                              (2 *\n                                                               offset_23514 -\n                                                               1)) == 0) {\n            // read array element\n            {\n                x_23511 = ((volatile __local\n                            float *) red_arr_mem_23506)[sext_i32_i64(local_tid_23500 +\n                                                        offset_23514)];\n            }\n            // apply reduction operation\n            {\n                float res_23512 = fmax32(x_23510, x_23511);\n                \n                x_23510 = res_23512;\n            }\n            // write result of operation\n            {\n                ((volatile __local\n                  float *) red_arr_mem_23506)[sext_i32_i64(local_tid_23500)] =\n                    x_23510;\n            }\n        }\n        offset_23514 *= 2;\n    }\n    while (slt32(skip_waves_23515,\n                 squot32(sext_i64_i32(segred_group_s",
                   "izze_21012) +\n                         wave_sizze_23502 - 1, wave_sizze_23502))) {\n        barrier(CLK_LOCAL_MEM_FENCE);\n        offset_23514 = skip_waves_23515 * wave_sizze_23502;\n        if (slt32(local_tid_23500 + offset_23514,\n                  sext_i64_i32(segred_group_sizze_21012)) && ((local_tid_23500 -\n                                                               squot32(local_tid_23500,\n                                                                       wave_sizze_23502) *\n                                                               wave_sizze_23502) ==\n                                                              0 &&\n                                                              (squot32(local_tid_23500,\n                                                                       wave_sizze_23502) &\n                                                               (2 *\n                                                                skip_waves_23515 -\n                                                                1)) == 0)) {\n            // read array element\n            {\n                x_23511 = ((__local\n                            float *) red_arr_mem_23506)[sext_i32_i64(local_tid_23500 +\n                                                        offset_23514)];\n            }\n            // apply reduction operation\n            {\n                float res_23512 = fmax32(x_23510, x_23511);\n                \n                x_23510 = res_23512;\n            }\n            // write result of operation\n            {\n                ((__local\n                  float *) red_arr_mem_23506)[sext_i32_i64(local_tid_23500)] =\n                    x_23510;\n            }\n        }\n        skip_waves_23515 *= 2;\n    }\n    barrier(CLK_LOCAL_MEM_FENCE);\n    // first thread saves the result in accumulator\n    {\n        if (sext_i32_i64(local_tid_23500) == 0) {\n            x_acc_23508 = x_23510;\n        }\n    }\n    \n    int32_t old_counter_23516;\n    \n    // first thread in grou",
                   "p saves group result to global memory\n    {\n        if (local_tid_23500 == 0) {\n            ((__global\n              float *) group_res_arr_mem_23496)[sext_i32_i64(group_tid_23501) *\n                                                segred_group_sizze_21012] =\n                x_acc_23508;\n            mem_fence_global();\n            old_counter_23516 = atomic_add_i32_global(&((volatile __global\n                                                         int *) testzicounter_mem_23494)[0],\n                                                      (int) 1);\n            ((__local bool *) sync_arr_mem_23504)[0] = old_counter_23516 ==\n                num_groups_21014 - 1;\n        }\n    }\n    barrier(CLK_GLOBAL_MEM_FENCE | CLK_LOCAL_MEM_FENCE);\n    \n    bool is_last_group_23517;\n    \n    is_last_group_23517 = ((__local bool *) sync_arr_mem_23504)[0];\n    if (is_last_group_23517) {\n        if (local_tid_23500 == 0) {\n            old_counter_23516 = atomic_add_i32_global(&((volatile __global\n                                                         int *) testzicounter_mem_23494)[0],\n                                                      (int) (0 -\n                                                             num_groups_21014));\n        }\n        // read in the per-group-results\n        {\n            int64_t read_per_thread_23518 = sdiv_up64(num_groups_21014,\n                                                      segred_group_sizze_21012);\n            \n            x_18534 = -INFINITY;\n            for (int64_t i_23519 = 0; i_23519 < read_per_thread_23518;\n                 i_23519++) {\n                int64_t group_res_id_23520 = sext_i32_i64(local_tid_23500) *\n                        read_per_thread_23518 + i_23519;\n                int64_t index_of_group_res_23521 = group_res_id_23520;\n                \n                if (slt64(group_res_id_23520, num_groups_21014)) {\n                    x_18535 = ((__global\n                                float *) group_res_arr_mem_23496)[index_of_group_",
                   "res_23521 *\n                                                                  segred_group_sizze_21012];\n                    \n                    float res_18536;\n                    \n                    res_18536 = fmax32(x_18534, x_18535);\n                    x_18534 = res_18536;\n                }\n            }\n        }\n        ((__local float *) red_arr_mem_23506)[sext_i32_i64(local_tid_23500)] =\n            x_18534;\n        barrier(CLK_LOCAL_MEM_FENCE);\n        // reduce the per-group results\n        {\n            int32_t offset_23522;\n            int32_t skip_waves_23523;\n            \n            skip_waves_23523 = 1;\n            \n            float x_23510;\n            float x_23511;\n            \n            offset_23522 = 0;\n            // participating threads read initial accumulator\n            {\n                if (slt32(local_tid_23500,\n                          sext_i64_i32(segred_group_sizze_21012))) {\n                    x_23510 = ((__local\n                                float *) red_arr_mem_23506)[sext_i32_i64(local_tid_23500 +\n                                                            offset_23522)];\n                }\n            }\n            offset_23522 = 1;\n            while (slt32(offset_23522, wave_sizze_23502)) {\n                if (slt32(local_tid_23500 + offset_23522,\n                          sext_i64_i32(segred_group_sizze_21012)) &&\n                    ((local_tid_23500 - squot32(local_tid_23500,\n                                                wave_sizze_23502) *\n                      wave_sizze_23502) & (2 * offset_23522 - 1)) == 0) {\n                    // read array element\n                    {\n                        x_23511 = ((volatile __local\n                                    float *) red_arr_mem_23506)[sext_i32_i64(local_tid_23500 +\n                                                                offset_23522)];\n                    }\n                    // apply reduction operation\n                    {\n                      ",
                   "  float res_23512 = fmax32(x_23510, x_23511);\n                        \n                        x_23510 = res_23512;\n                    }\n                    // write result of operation\n                    {\n                        ((volatile __local\n                          float *) red_arr_mem_23506)[sext_i32_i64(local_tid_23500)] =\n                            x_23510;\n                    }\n                }\n                offset_23522 *= 2;\n            }\n            while (slt32(skip_waves_23523,\n                         squot32(sext_i64_i32(segred_group_sizze_21012) +\n                                 wave_sizze_23502 - 1, wave_sizze_23502))) {\n                barrier(CLK_LOCAL_MEM_FENCE);\n                offset_23522 = skip_waves_23523 * wave_sizze_23502;\n                if (slt32(local_tid_23500 + offset_23522,\n                          sext_i64_i32(segred_group_sizze_21012)) &&\n                    ((local_tid_23500 - squot32(local_tid_23500,\n                                                wave_sizze_23502) *\n                      wave_sizze_23502) == 0 && (squot32(local_tid_23500,\n                                                         wave_sizze_23502) &\n                                                 (2 * skip_waves_23523 - 1)) ==\n                     0)) {\n                    // read array element\n                    {\n                        x_23511 = ((__local\n                                    float *) red_arr_mem_23506)[sext_i32_i64(local_tid_23500 +\n                                                                offset_23522)];\n                    }\n                    // apply reduction operation\n                    {\n                        float res_23512 = fmax32(x_23510, x_23511);\n                        \n                        x_23510 = res_23512;\n                    }\n                    // write result of operation\n                    {\n                        ((__local\n                          float *) red_arr_mem_23506)[sext_i32_i64(l",
                   "ocal_tid_23500)] =\n                            x_23510;\n                    }\n                }\n                skip_waves_23523 *= 2;\n            }\n            // and back to memory with the final result\n            {\n                if (local_tid_23500 == 0) {\n                    ((__global float *) mem_23228)[0] = x_23510;\n                }\n            }\n        }\n    }\n    \n  error_1:\n    return;\n    #undef segred_group_sizze_21012\n}\n__kernel void testzisegred_nonseg_21830(__global int *global_failure,\n                                        int failure_is_an_option, __global\n                                        int64_t *global_failure_args,\n                                        __local volatile\n                                        int64_t *red_arr_mem_23636_backing_aligned_0,\n                                        __local volatile\n                                        int64_t *sync_arr_mem_23634_backing_aligned_1,\n                                        int64_t paths_18528,\n                                        int64_t steps_18529,\n                                        float sims_per_year_18620,\n                                        float res_18697,\n                                        int64_t num_groups_21833, __global\n                                        unsigned char *res_mem_23275, __global\n                                        unsigned char *res_mem_23276, __global\n                                        unsigned char *res_mem_23277, __global\n                                        unsigned char *res_mem_23278, __global\n                                        unsigned char *mem_23306, __global\n                                        unsigned char *mem_23309, __global\n                                        unsigned char *testzicounter_mem_23624,\n                                        __global\n                                        unsigned char *group_res_arr_mem_23626,\n                                        int64_t num_threads_",
                   "23628)\n{\n    #define segred_group_sizze_21832 (testzisegred_group_sizze_21822)\n    \n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    __local volatile char *restrict red_arr_mem_23636_backing_1 =\n                          (__local volatile\n                           char *) red_arr_mem_23636_backing_aligned_0;\n    __local volatile char *restrict sync_arr_mem_23634_backing_0 =\n                          (__local volatile\n                           char *) sync_arr_mem_23634_backing_aligned_1;\n    volatile __local bool local_failure;\n    \n    if (failure_is_an_option) {\n        int failed = *global_failure >= 0;\n        \n        if (failed)\n            return;\n    }\n    local_failure = false;\n    barrier(CLK_LOCAL_MEM_FENCE);\n    \n    int32_t global_tid_23629;\n    int32_t local_tid_23630;\n    int64_t group_sizze_23633;\n    int32_t wave_sizze_23632;\n    int32_t group_tid_23631;\n    \n    global_tid_23629 = get_global_id(0);\n    local_tid_23630 = get_local_id(0);\n    group_sizze_23633 = get_local_size(0);\n    wave_sizze_23632 = LOCKSTEP_WIDTH;\n    group_tid_23631 = get_group_id(0);\n    \n    int32_t phys_tid_21830;\n    \n    phys_tid_21830 = global_tid_23629;\n    \n    __local char *sync_arr_mem_23634;\n    \n    sync_arr_mem_23634 = (__local char *) sync_arr_mem_23634_backing_0;\n    \n    __local char *red_arr_mem_23636;\n    \n    red_arr_mem_23636 = (__local char *) red_arr_mem_23636_backing_1;\n    \n    int64_t dummy_21828;\n    \n    dummy_21828 = 0;\n    \n    int64_t gtid_21829;\n    \n    gtid_21829 = 0;\n    \n    float x_acc_23638;\n    int64_t chunk_sizze_23639;\n    \n    chunk_sizze_23639 = smin64(sdiv_up64(steps_18529,\n                                         sext_i32_i64(sext_i64_i32(segred_group_sizze_21832 *\n                                         num_groups_21833))),\n                               sdiv_up64(steps_18529 -\n                                         sext_i32_i64(phys_tid_21830),\n                                       ",
                   "  num_threads_23628));\n    \n    float x_21836;\n    float x_21837;\n    \n    // neutral-initialise the accumulators\n    {\n        x_acc_23638 = 0.0F;\n    }\n    for (int64_t i_23643 = 0; i_23643 < chunk_sizze_23639; i_23643++) {\n        gtid_21829 = sext_i32_i64(phys_tid_21830) + num_threads_23628 * i_23643;\n        // apply map function\n        {\n            int64_t index_primexp_23127 = add64(1, gtid_21829);\n            float res_21842 = sitofp_i64_f32(index_primexp_23127);\n            float res_21843 = res_21842 / sims_per_year_18620;\n            float res_21844;\n            float redout_23192 = 0.0F;\n            \n            for (int64_t i_23193 = 0; i_23193 < paths_18528; i_23193++) {\n                float x_21848 = ((__global float *) mem_23306)[gtid_21829 *\n                                                               paths_18528 +\n                                                               i_23193];\n                float res_21850;\n                float redout_23194 = 0.0F;\n                \n                for (int32_t i_23210 = 0; i_23210 < 9; i_23210++) {\n                    int64_t i_23195 = sext_i32_i64(i_23210);\n                    int64_t x_21856 = ((__global\n                                        int64_t *) res_mem_23277)[i_23195];\n                    float x_21857 = ((__global float *) res_mem_23278)[i_23195];\n                    int64_t i64_arg_21858 = sub64(x_21856, 1);\n                    float res_21859 = sitofp_i64_f32(i64_arg_21858);\n                    float y_21860 = x_21857 * res_21859;\n                    bool cond_21861 = y_21860 < res_21843;\n                    float ceil_arg_21862 = res_21843 / x_21857;\n                    float res_21863;\n                    \n                    res_21863 = futrts_ceil32(ceil_arg_21862);\n                    \n                    int64_t res_21864 = fptosi_f32_i64(res_21863);\n                    int64_t remaining_21865 = sub64(x_21856, res_21864);\n                    float res_21866;\n                   ",
                   " \n                    if (cond_21861) {\n                        res_21866 = 0.0F;\n                    } else {\n                        float x_21854 = ((__global\n                                          float *) res_mem_23275)[i_23195];\n                        float x_21855 = ((__global\n                                          float *) res_mem_23276)[i_23195];\n                        float nextpayment_21867 = x_21857 * res_21863;\n                        bool bounds_invalid_upwards_21868 =\n                             slt64(remaining_21865, 1);\n                        bool valid_21869 = !bounds_invalid_upwards_21868;\n                        bool range_valid_c_21870;\n                        \n                        if (!valid_21869) {\n                            {\n                                if (atomic_cmpxchg_i32_global(global_failure,\n                                                              -1, 26) == -1) {\n                                    global_failure_args[0] = 1;\n                                    global_failure_args[1] = 2;\n                                    global_failure_args[2] = remaining_21865;\n                                    ;\n                                }\n                                local_failure = true;\n                                goto error_0;\n                            }\n                        }\n                        \n                        float y_21872 = nextpayment_21867 - res_21843;\n                        float negate_arg_21873 = 1.0e-2F * y_21872;\n                        float exp_arg_21874 = 0.0F - negate_arg_21873;\n                        float res_21875 = fpow32(2.7182817F, exp_arg_21874);\n                        float x_21876 = 1.0F - res_21875;\n                        float B_21877 = x_21876 / 1.0e-2F;\n                        float x_21878 = B_21877 - nextpayment_21867;\n                        float x_21879 = res_21843 + x_21878;\n                        float x_21880 = 4.4999997e-6F * x_21879;\n          ",
                   "              float A1_21881 = x_21880 / 1.0e-4F;\n                        float y_21882 = fpow32(B_21877, 2.0F);\n                        float x_21883 = 1.0000001e-6F * y_21882;\n                        float A2_21884 = x_21883 / 4.0e-2F;\n                        float exp_arg_21885 = A1_21881 - A2_21884;\n                        float res_21886 = fpow32(2.7182817F, exp_arg_21885);\n                        float negate_arg_21887 = x_21848 * B_21877;\n                        float exp_arg_21888 = 0.0F - negate_arg_21887;\n                        float res_21889 = fpow32(2.7182817F, exp_arg_21888);\n                        float res_21890 = res_21886 * res_21889;\n                        bool y_21891 = slt64(0, remaining_21865);\n                        bool index_certs_21892;\n                        \n                        if (!y_21891) {\n                            {\n                                if (atomic_cmpxchg_i32_global(global_failure,\n                                                              -1, 27) == -1) {\n                                    global_failure_args[0] = 0;\n                                    global_failure_args[1] = remaining_21865;\n                                    ;\n                                }\n                                local_failure = true;\n                                goto error_0;\n                            }\n                        }\n                        \n                        float binop_y_21893 = sitofp_i64_f32(remaining_21865);\n                        float binop_y_21894 = x_21857 * binop_y_21893;\n                        float index_primexp_21895 = nextpayment_21867 +\n                              binop_y_21894;\n                        float y_21896 = index_primexp_21895 - res_21843;\n                        float negate_arg_21897 = 1.0e-2F * y_21896;\n                        float exp_arg_21898 = 0.0F - negate_arg_21897;\n                        float res_21899 = fpow32(2.7182817F, exp_arg_21898);\n                    ",
                   "    float x_21900 = 1.0F - res_21899;\n                        float B_21901 = x_21900 / 1.0e-2F;\n                        float x_21902 = B_21901 - index_primexp_21895;\n                        float x_21903 = res_21843 + x_21902;\n                        float x_21904 = 4.4999997e-6F * x_21903;\n                        float A1_21905 = x_21904 / 1.0e-4F;\n                        float y_21906 = fpow32(B_21901, 2.0F);\n                        float x_21907 = 1.0000001e-6F * y_21906;\n                        float A2_21908 = x_21907 / 4.0e-2F;\n                        float exp_arg_21909 = A1_21905 - A2_21908;\n                        float res_21910 = fpow32(2.7182817F, exp_arg_21909);\n                        float negate_arg_21911 = x_21848 * B_21901;\n                        float exp_arg_21912 = 0.0F - negate_arg_21911;\n                        float res_21913 = fpow32(2.7182817F, exp_arg_21912);\n                        float res_21914 = res_21910 * res_21913;\n                        float res_21915;\n                        float redout_23124 = 0.0F;\n                        \n                        for (int64_t i_23125 = 0; i_23125 < remaining_21865;\n                             i_23125++) {\n                            int64_t index_primexp_23159 = add64(1, i_23125);\n                            float res_21920 =\n                                  sitofp_i64_f32(index_primexp_23159);\n                            float res_21921 = x_21857 * res_21920;\n                            float res_21922 = nextpayment_21867 + res_21921;\n                            float y_21923 = res_21922 - res_21843;\n                            float negate_arg_21924 = 1.0e-2F * y_21923;\n                            float exp_arg_21925 = 0.0F - negate_arg_21924;\n                            float res_21926 = fpow32(2.7182817F, exp_arg_21925);\n                            float x_21927 = 1.0F - res_21926;\n                            float B_21928 = x_21927 / 1.0e-2F;\n                            float x_219",
                   "29 = B_21928 - res_21922;\n                            float x_21930 = res_21843 + x_21929;\n                            float x_21931 = 4.4999997e-6F * x_21930;\n                            float A1_21932 = x_21931 / 1.0e-4F;\n                            float y_21933 = fpow32(B_21928, 2.0F);\n                            float x_21934 = 1.0000001e-6F * y_21933;\n                            float A2_21935 = x_21934 / 4.0e-2F;\n                            float exp_arg_21936 = A1_21932 - A2_21935;\n                            float res_21937 = fpow32(2.7182817F, exp_arg_21936);\n                            float negate_arg_21938 = x_21848 * B_21928;\n                            float exp_arg_21939 = 0.0F - negate_arg_21938;\n                            float res_21940 = fpow32(2.7182817F, exp_arg_21939);\n                            float res_21941 = res_21937 * res_21940;\n                            float res_21918 = res_21941 + redout_23124;\n                            float redout_tmp_23646 = res_21918;\n                            \n                            redout_23124 = redout_tmp_23646;\n                        }\n                        res_21915 = redout_23124;\n                        \n                        float x_21942 = res_21890 - res_21914;\n                        float x_21943 = x_21854 * x_21857;\n                        float y_21944 = res_21915 * x_21943;\n                        float y_21945 = x_21942 - y_21944;\n                        float res_21946 = x_21855 * y_21945;\n                        \n                        res_21866 = res_21946;\n                    }\n                    \n                    float res_21853 = res_21866 + redout_23194;\n                    float redout_tmp_23645 = res_21853;\n                    \n                    redout_23194 = redout_tmp_23645;\n                }\n                res_21850 = redout_23194;\n                \n                float res_21947 = fmax32(0.0F, res_21850);\n                float res_21847 = res_21947 + redout",
                   "_23192;\n                float redout_tmp_23644 = res_21847;\n                \n                redout_23192 = redout_tmp_23644;\n            }\n            res_21844 = redout_23192;\n            \n            float res_21948 = res_21844 / res_18697;\n            float negate_arg_21949 = 1.0e-2F * res_21843;\n            float exp_arg_21950 = 0.0F - negate_arg_21949;\n            float res_21951 = fpow32(2.7182817F, exp_arg_21950);\n            float x_21952 = 1.0F - res_21951;\n            float B_21953 = x_21952 / 1.0e-2F;\n            float x_21954 = B_21953 - res_21843;\n            float x_21955 = 4.4999997e-6F * x_21954;\n            float A1_21956 = x_21955 / 1.0e-4F;\n            float y_21957 = fpow32(B_21953, 2.0F);\n            float x_21958 = 1.0000001e-6F * y_21957;\n            float A2_21959 = x_21958 / 4.0e-2F;\n            float exp_arg_21960 = A1_21956 - A2_21959;\n            float res_21961 = fpow32(2.7182817F, exp_arg_21960);\n            float negate_arg_21962 = 5.0e-2F * B_21953;\n            float exp_arg_21963 = 0.0F - negate_arg_21962;\n            float res_21964 = fpow32(2.7182817F, exp_arg_21963);\n            float res_21965 = res_21961 * res_21964;\n            float res_21966 = res_21948 * res_21965;\n            \n            // save map-out results\n            { }\n            // load accumulator\n            {\n                x_21836 = x_acc_23638;\n            }\n            // load new values\n            {\n                x_21837 = res_21966;\n            }\n            // apply reduction operator\n            {\n                float res_21838 = x_21836 + x_21837;\n                \n                // store in accumulator\n                {\n                    x_acc_23638 = res_21838;\n                }\n            }\n        }\n    }\n    // to reduce current chunk, first store our result in memory\n    {\n        x_21836 = x_acc_23638;\n        ((__local float *) red_arr_mem_23636)[sext_i32_i64(local_tid_23630)] =\n            x_21836;\n    }\n    \n  error_0:\n    barrier(CL",
                   "K_LOCAL_MEM_FENCE);\n    if (local_failure)\n        return;\n    barrier(CLK_LOCAL_MEM_FENCE);\n    \n    int32_t offset_23647;\n    int32_t skip_waves_23648;\n    \n    skip_waves_23648 = 1;\n    \n    float x_23640;\n    float x_23641;\n    \n    offset_23647 = 0;\n    // participating threads read initial accumulator\n    {\n        if (slt32(local_tid_23630, sext_i64_i32(segred_group_sizze_21832))) {\n            x_23640 = ((__local\n                        float *) red_arr_mem_23636)[sext_i32_i64(local_tid_23630 +\n                                                    offset_23647)];\n        }\n    }\n    offset_23647 = 1;\n    while (slt32(offset_23647, wave_sizze_23632)) {\n        if (slt32(local_tid_23630 + offset_23647,\n                  sext_i64_i32(segred_group_sizze_21832)) && ((local_tid_23630 -\n                                                               squot32(local_tid_23630,\n                                                                       wave_sizze_23632) *\n                                                               wave_sizze_23632) &\n                                                              (2 *\n                                                               offset_23647 -\n                                                               1)) == 0) {\n            // read array element\n            {\n                x_23641 = ((volatile __local\n                            float *) red_arr_mem_23636)[sext_i32_i64(local_tid_23630 +\n                                                        offset_23647)];\n            }\n            // apply reduction operation\n            {\n                float res_23642 = x_23640 + x_23641;\n                \n                x_23640 = res_23642;\n            }\n            // write result of operation\n            {\n                ((volatile __local\n                  float *) red_arr_mem_23636)[sext_i32_i64(local_tid_23630)] =\n                    x_23640;\n            }\n        }\n        offset_23647 *= 2;\n    }\n    while (slt32(skip_wa",
                   "ves_23648,\n                 squot32(sext_i64_i32(segred_group_sizze_21832) +\n                         wave_sizze_23632 - 1, wave_sizze_23632))) {\n        barrier(CLK_LOCAL_MEM_FENCE);\n        offset_23647 = skip_waves_23648 * wave_sizze_23632;\n        if (slt32(local_tid_23630 + offset_23647,\n                  sext_i64_i32(segred_group_sizze_21832)) && ((local_tid_23630 -\n                                                               squot32(local_tid_23630,\n                                                                       wave_sizze_23632) *\n                                                               wave_sizze_23632) ==\n                                                              0 &&\n                                                              (squot32(local_tid_23630,\n                                                                       wave_sizze_23632) &\n                                                               (2 *\n                                                                skip_waves_23648 -\n                                                                1)) == 0)) {\n            // read array element\n            {\n                x_23641 = ((__local\n                            float *) red_arr_mem_23636)[sext_i32_i64(local_tid_23630 +\n                                                        offset_23647)];\n            }\n            // apply reduction operation\n            {\n                float res_23642 = x_23640 + x_23641;\n                \n                x_23640 = res_23642;\n            }\n            // write result of operation\n            {\n                ((__local\n                  float *) red_arr_mem_23636)[sext_i32_i64(local_tid_23630)] =\n                    x_23640;\n            }\n        }\n        skip_waves_23648 *= 2;\n    }\n    barrier(CLK_LOCAL_MEM_FENCE);\n    // first thread saves the result in accumulator\n    {\n        if (sext_i32_i64(local_tid_23630) == 0) {\n            x_acc_23638 = x_23640;\n        }\n    }\n    \n    int",
                   "32_t old_counter_23649;\n    \n    // first thread in group saves group result to global memory\n    {\n        if (local_tid_23630 == 0) {\n            ((__global\n              float *) group_res_arr_mem_23626)[sext_i32_i64(group_tid_23631) *\n                                                segred_group_sizze_21832] =\n                x_acc_23638;\n            mem_fence_global();\n            old_counter_23649 = atomic_add_i32_global(&((volatile __global\n                                                         int *) testzicounter_mem_23624)[0],\n                                                      (int) 1);\n            ((__local bool *) sync_arr_mem_23634)[0] = old_counter_23649 ==\n                num_groups_21833 - 1;\n        }\n    }\n    barrier(CLK_GLOBAL_MEM_FENCE | CLK_LOCAL_MEM_FENCE);\n    \n    bool is_last_group_23650;\n    \n    is_last_group_23650 = ((__local bool *) sync_arr_mem_23634)[0];\n    if (is_last_group_23650) {\n        if (local_tid_23630 == 0) {\n            old_counter_23649 = atomic_add_i32_global(&((volatile __global\n                                                         int *) testzicounter_mem_23624)[0],\n                                                      (int) (0 -\n                                                             num_groups_21833));\n        }\n        // read in the per-group-results\n        {\n            int64_t read_per_thread_23651 = sdiv_up64(num_groups_21833,\n                                                      segred_group_sizze_21832);\n            \n            x_21836 = 0.0F;\n            for (int64_t i_23652 = 0; i_23652 < read_per_thread_23651;\n                 i_23652++) {\n                int64_t group_res_id_23653 = sext_i32_i64(local_tid_23630) *\n                        read_per_thread_23651 + i_23652;\n                int64_t index_of_group_res_23654 = group_res_id_23653;\n                \n                if (slt64(group_res_id_23653, num_groups_21833)) {\n                    x_21837 = ((__global\n                              ",
                   "  float *) group_res_arr_mem_23626)[index_of_group_res_23654 *\n                                                                  segred_group_sizze_21832];\n                    \n                    float res_21838;\n                    \n                    res_21838 = x_21836 + x_21837;\n                    x_21836 = res_21838;\n                }\n            }\n        }\n        ((__local float *) red_arr_mem_23636)[sext_i32_i64(local_tid_23630)] =\n            x_21836;\n        barrier(CLK_LOCAL_MEM_FENCE);\n        // reduce the per-group results\n        {\n            int32_t offset_23655;\n            int32_t skip_waves_23656;\n            \n            skip_waves_23656 = 1;\n            \n            float x_23640;\n            float x_23641;\n            \n            offset_23655 = 0;\n            // participating threads read initial accumulator\n            {\n                if (slt32(local_tid_23630,\n                          sext_i64_i32(segred_group_sizze_21832))) {\n                    x_23640 = ((__local\n                                float *) red_arr_mem_23636)[sext_i32_i64(local_tid_23630 +\n                                                            offset_23655)];\n                }\n            }\n            offset_23655 = 1;\n            while (slt32(offset_23655, wave_sizze_23632)) {\n                if (slt32(local_tid_23630 + offset_23655,\n                          sext_i64_i32(segred_group_sizze_21832)) &&\n                    ((local_tid_23630 - squot32(local_tid_23630,\n                                                wave_sizze_23632) *\n                      wave_sizze_23632) & (2 * offset_23655 - 1)) == 0) {\n                    // read array element\n                    {\n                        x_23641 = ((volatile __local\n                                    float *) red_arr_mem_23636)[sext_i32_i64(local_tid_23630 +\n                                                                offset_23655)];\n                    }\n                    // apply reduction operation\n",
                   "                    {\n                        float res_23642 = x_23640 + x_23641;\n                        \n                        x_23640 = res_23642;\n                    }\n                    // write result of operation\n                    {\n                        ((volatile __local\n                          float *) red_arr_mem_23636)[sext_i32_i64(local_tid_23630)] =\n                            x_23640;\n                    }\n                }\n                offset_23655 *= 2;\n            }\n            while (slt32(skip_waves_23656,\n                         squot32(sext_i64_i32(segred_group_sizze_21832) +\n                                 wave_sizze_23632 - 1, wave_sizze_23632))) {\n                barrier(CLK_LOCAL_MEM_FENCE);\n                offset_23655 = skip_waves_23656 * wave_sizze_23632;\n                if (slt32(local_tid_23630 + offset_23655,\n                          sext_i64_i32(segred_group_sizze_21832)) &&\n                    ((local_tid_23630 - squot32(local_tid_23630,\n                                                wave_sizze_23632) *\n                      wave_sizze_23632) == 0 && (squot32(local_tid_23630,\n                                                         wave_sizze_23632) &\n                                                 (2 * skip_waves_23656 - 1)) ==\n                     0)) {\n                    // read array element\n                    {\n                        x_23641 = ((__local\n                                    float *) red_arr_mem_23636)[sext_i32_i64(local_tid_23630 +\n                                                                offset_23655)];\n                    }\n                    // apply reduction operation\n                    {\n                        float res_23642 = x_23640 + x_23641;\n                        \n                        x_23640 = res_23642;\n                    }\n                    // write result of operation\n                    {\n                        ((__local\n                          float *) red",
                   "_arr_mem_23636)[sext_i32_i64(local_tid_23630)] =\n                            x_23640;\n                    }\n                }\n                skip_waves_23656 *= 2;\n            }\n            // and back to memory with the final result\n            {\n                if (local_tid_23630 == 0) {\n                    ((__global float *) mem_23309)[0] = x_23640;\n                }\n            }\n        }\n    }\n    \n  error_1:\n    return;\n    #undef segred_group_sizze_21832\n}\n__kernel void testzisegred_nonseg_22685(__global int *global_failure,\n                                        __local volatile\n                                        int64_t *red_arr_mem_23760_backing_aligned_0,\n                                        __local volatile\n                                        int64_t *sync_arr_mem_23758_backing_aligned_1,\n                                        int64_t steps_18529,\n                                        int64_t num_groups_23104, __global\n                                        unsigned char *res_map_acc_mem_23324,\n                                        __global unsigned char *mem_23327,\n                                        __global\n                                        unsigned char *testzicounter_mem_23748,\n                                        __global\n                                        unsigned char *group_res_arr_mem_23750,\n                                        int64_t num_threads_23752)\n{\n    #define segred_group_sizze_23103 (testzisegred_group_sizze_22677)\n    \n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    __local volatile char *restrict red_arr_mem_23760_backing_1 =\n                          (__local volatile\n                           char *) red_arr_mem_23760_backing_aligned_0;\n    __local volatile char *restrict sync_arr_mem_23758_backing_0 =\n                          (__local volatile\n                           char *) sync_arr_mem_23758_backing_aligned_1;\n    \n    if (*global_fai",
                   "lure >= 0)\n        return;\n    \n    int32_t global_tid_23753;\n    int32_t local_tid_23754;\n    int64_t group_sizze_23757;\n    int32_t wave_sizze_23756;\n    int32_t group_tid_23755;\n    \n    global_tid_23753 = get_global_id(0);\n    local_tid_23754 = get_local_id(0);\n    group_sizze_23757 = get_local_size(0);\n    wave_sizze_23756 = LOCKSTEP_WIDTH;\n    group_tid_23755 = get_group_id(0);\n    \n    int32_t phys_tid_22685;\n    \n    phys_tid_22685 = global_tid_23753;\n    \n    __local char *sync_arr_mem_23758;\n    \n    sync_arr_mem_23758 = (__local char *) sync_arr_mem_23758_backing_0;\n    \n    __local char *red_arr_mem_23760;\n    \n    red_arr_mem_23760 = (__local char *) red_arr_mem_23760_backing_1;\n    \n    int64_t dummy_22683;\n    \n    dummy_22683 = 0;\n    \n    int64_t gtid_22684;\n    \n    gtid_22684 = 0;\n    \n    float x_acc_23762;\n    int64_t chunk_sizze_23763;\n    \n    chunk_sizze_23763 = smin64(sdiv_up64(steps_18529,\n                                         sext_i32_i64(sext_i64_i32(segred_group_sizze_23103 *\n                                         num_groups_23104))),\n                               sdiv_up64(steps_18529 -\n                                         sext_i32_i64(phys_tid_22685),\n                                         num_threads_23752));\n    \n    float x_23107;\n    float x_23108;\n    \n    // neutral-initialise the accumulators\n    {\n        x_acc_23762 = 0.0F;\n    }\n    for (int64_t i_23767 = 0; i_23767 < chunk_sizze_23763; i_23767++) {\n        gtid_22684 = sext_i32_i64(phys_tid_22685) + num_threads_23752 * i_23767;\n        // apply map function\n        {\n            float x_23110 = ((__global\n                              float *) res_map_acc_mem_23324)[gtid_22684];\n            \n            // save map-out results\n            { }\n            // load accumulator\n            {\n                x_23107 = x_acc_23762;\n            }\n            // load new values\n            {\n                x_23108 = x_23110;\n            }\n            // apply reduction ",
                   "operator\n            {\n                float res_23109 = x_23107 + x_23108;\n                \n                // store in accumulator\n                {\n                    x_acc_23762 = res_23109;\n                }\n            }\n        }\n    }\n    // to reduce current chunk, first store our result in memory\n    {\n        x_23107 = x_acc_23762;\n        ((__local float *) red_arr_mem_23760)[sext_i32_i64(local_tid_23754)] =\n            x_23107;\n    }\n    barrier(CLK_LOCAL_MEM_FENCE);\n    \n    int32_t offset_23768;\n    int32_t skip_waves_23769;\n    \n    skip_waves_23769 = 1;\n    \n    float x_23764;\n    float x_23765;\n    \n    offset_23768 = 0;\n    // participating threads read initial accumulator\n    {\n        if (slt32(local_tid_23754, sext_i64_i32(segred_group_sizze_23103))) {\n            x_23764 = ((__local\n                        float *) red_arr_mem_23760)[sext_i32_i64(local_tid_23754 +\n                                                    offset_23768)];\n        }\n    }\n    offset_23768 = 1;\n    while (slt32(offset_23768, wave_sizze_23756)) {\n        if (slt32(local_tid_23754 + offset_23768,\n                  sext_i64_i32(segred_group_sizze_23103)) && ((local_tid_23754 -\n                                                               squot32(local_tid_23754,\n                                                                       wave_sizze_23756) *\n                                                               wave_sizze_23756) &\n                                                              (2 *\n                                                               offset_23768 -\n                                                               1)) == 0) {\n            // read array element\n            {\n                x_23765 = ((volatile __local\n                            float *) red_arr_mem_23760)[sext_i32_i64(local_tid_23754 +\n                                                        offset_23768)];\n            }\n            // apply reduction operation\n            {\n       ",
                   "         float res_23766 = x_23764 + x_23765;\n                \n                x_23764 = res_23766;\n            }\n            // write result of operation\n            {\n                ((volatile __local\n                  float *) red_arr_mem_23760)[sext_i32_i64(local_tid_23754)] =\n                    x_23764;\n            }\n        }\n        offset_23768 *= 2;\n    }\n    while (slt32(skip_waves_23769,\n                 squot32(sext_i64_i32(segred_group_sizze_23103) +\n                         wave_sizze_23756 - 1, wave_sizze_23756))) {\n        barrier(CLK_LOCAL_MEM_FENCE);\n        offset_23768 = skip_waves_23769 * wave_sizze_23756;\n        if (slt32(local_tid_23754 + offset_23768,\n                  sext_i64_i32(segred_group_sizze_23103)) && ((local_tid_23754 -\n                                                               squot32(local_tid_23754,\n                                                                       wave_sizze_23756) *\n                                                               wave_sizze_23756) ==\n                                                              0 &&\n                                                              (squot32(local_tid_23754,\n                                                                       wave_sizze_23756) &\n                                                               (2 *\n                                                                skip_waves_23769 -\n                                                                1)) == 0)) {\n            // read array element\n            {\n                x_23765 = ((__local\n                            float *) red_arr_mem_23760)[sext_i32_i64(local_tid_23754 +\n                                                        offset_23768)];\n            }\n            // apply reduction operation\n            {\n                float res_23766 = x_23764 + x_23765;\n                \n                x_23764 = res_23766;\n            }\n            // write result of operation\n            {\n       ",
                   "         ((__local\n                  float *) red_arr_mem_23760)[sext_i32_i64(local_tid_23754)] =\n                    x_23764;\n            }\n        }\n        skip_waves_23769 *= 2;\n    }\n    barrier(CLK_LOCAL_MEM_FENCE);\n    // first thread saves the result in accumulator\n    {\n        if (sext_i32_i64(local_tid_23754) == 0) {\n            x_acc_23762 = x_23764;\n        }\n    }\n    \n    int32_t old_counter_23770;\n    \n    // first thread in group saves group result to global memory\n    {\n        if (local_tid_23754 == 0) {\n            ((__global\n              float *) group_res_arr_mem_23750)[sext_i32_i64(group_tid_23755) *\n                                                segred_group_sizze_23103] =\n                x_acc_23762;\n            mem_fence_global();\n            old_counter_23770 = atomic_add_i32_global(&((volatile __global\n                                                         int *) testzicounter_mem_23748)[0],\n                                                      (int) 1);\n            ((__local bool *) sync_arr_mem_23758)[0] = old_counter_23770 ==\n                num_groups_23104 - 1;\n        }\n    }\n    barrier(CLK_GLOBAL_MEM_FENCE | CLK_LOCAL_MEM_FENCE);\n    \n    bool is_last_group_23771;\n    \n    is_last_group_23771 = ((__local bool *) sync_arr_mem_23758)[0];\n    if (is_last_group_23771) {\n        if (local_tid_23754 == 0) {\n            old_counter_23770 = atomic_add_i32_global(&((volatile __global\n                                                         int *) testzicounter_mem_23748)[0],\n                                                      (int) (0 -\n                                                             num_groups_23104));\n        }\n        // read in the per-group-results\n        {\n            int64_t read_per_thread_23772 = sdiv_up64(num_groups_23104,\n                                                      segred_group_sizze_23103);\n            \n            x_23107 = 0.0F;\n            for (int64_t i_23773 = 0; i_23773 < read_per_thread_2377",
                   "2;\n                 i_23773++) {\n                int64_t group_res_id_23774 = sext_i32_i64(local_tid_23754) *\n                        read_per_thread_23772 + i_23773;\n                int64_t index_of_group_res_23775 = group_res_id_23774;\n                \n                if (slt64(group_res_id_23774, num_groups_23104)) {\n                    x_23108 = ((__global\n                                float *) group_res_arr_mem_23750)[index_of_group_res_23775 *\n                                                                  segred_group_sizze_23103];\n                    \n                    float res_23109;\n                    \n                    res_23109 = x_23107 + x_23108;\n                    x_23107 = res_23109;\n                }\n            }\n        }\n        ((__local float *) red_arr_mem_23760)[sext_i32_i64(local_tid_23754)] =\n            x_23107;\n        barrier(CLK_LOCAL_MEM_FENCE);\n        // reduce the per-group results\n        {\n            int32_t offset_23776;\n            int32_t skip_waves_23777;\n            \n            skip_waves_23777 = 1;\n            \n            float x_23764;\n            float x_23765;\n            \n            offset_23776 = 0;\n            // participating threads read initial accumulator\n            {\n                if (slt32(local_tid_23754,\n                          sext_i64_i32(segred_group_sizze_23103))) {\n                    x_23764 = ((__local\n                                float *) red_arr_mem_23760)[sext_i32_i64(local_tid_23754 +\n                                                            offset_23776)];\n                }\n            }\n            offset_23776 = 1;\n            while (slt32(offset_23776, wave_sizze_23756)) {\n                if (slt32(local_tid_23754 + offset_23776,\n                          sext_i64_i32(segred_group_sizze_23103)) &&\n                    ((local_tid_23754 - squot32(local_tid_23754,\n                                                wave_sizze_23756) *\n                      wave_sizze_23756) & (2",
                   " * offset_23776 - 1)) == 0) {\n                    // read array element\n                    {\n                        x_23765 = ((volatile __local\n                                    float *) red_arr_mem_23760)[sext_i32_i64(local_tid_23754 +\n                                                                offset_23776)];\n                    }\n                    // apply reduction operation\n                    {\n                        float res_23766 = x_23764 + x_23765;\n                        \n                        x_23764 = res_23766;\n                    }\n                    // write result of operation\n                    {\n                        ((volatile __local\n                          float *) red_arr_mem_23760)[sext_i32_i64(local_tid_23754)] =\n                            x_23764;\n                    }\n                }\n                offset_23776 *= 2;\n            }\n            while (slt32(skip_waves_23777,\n                         squot32(sext_i64_i32(segred_group_sizze_23103) +\n                                 wave_sizze_23756 - 1, wave_sizze_23756))) {\n                barrier(CLK_LOCAL_MEM_FENCE);\n                offset_23776 = skip_waves_23777 * wave_sizze_23756;\n                if (slt32(local_tid_23754 + offset_23776,\n                          sext_i64_i32(segred_group_sizze_23103)) &&\n                    ((local_tid_23754 - squot32(local_tid_23754,\n                                                wave_sizze_23756) *\n                      wave_sizze_23756) == 0 && (squot32(local_tid_23754,\n                                                         wave_sizze_23756) &\n                                                 (2 * skip_waves_23777 - 1)) ==\n                     0)) {\n                    // read array element\n                    {\n                        x_23765 = ((__local\n                                    float *) red_arr_mem_23760)[sext_i32_i64(local_tid_23754 +\n                                                                offset_23776",
                   ")];\n                    }\n                    // apply reduction operation\n                    {\n                        float res_23766 = x_23764 + x_23765;\n                        \n                        x_23764 = res_23766;\n                    }\n                    // write result of operation\n                    {\n                        ((__local\n                          float *) red_arr_mem_23760)[sext_i32_i64(local_tid_23754)] =\n                            x_23764;\n                    }\n                }\n                skip_waves_23777 *= 2;\n            }\n            // and back to memory with the final result\n            {\n                if (local_tid_23754 == 0) {\n                    ((__global float *) mem_23327)[0] = x_23764;\n                }\n            }\n        }\n    }\n    \n  error_1:\n    return;\n    #undef segred_group_sizze_23103\n}\n__kernel void testzisegred_nonseg_23431(__global int *global_failure,\n                                        __local volatile\n                                        int64_t *red_arr_mem_23536_backing_aligned_0,\n                                        __local volatile\n                                        int64_t *sync_arr_mem_23534_backing_aligned_1,\n                                        __global unsigned char *mem_23223,\n                                        __global unsigned char *mem_23443,\n                                        __global\n                                        unsigned char *testzicounter_mem_23524,\n                                        __global\n                                        unsigned char *group_res_arr_mem_23526,\n                                        int64_t num_threads_23528)\n{\n    #define segred_num_groups_23425 (testzisegred_num_groups_23424)\n    #define segred_group_sizze_23427 (testzisegred_group_sizze_23426)\n    \n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    __local volatile char *restrict red_arr_mem_23536_backing_1 =\n  ",
                   "                        (__local volatile\n                           char *) red_arr_mem_23536_backing_aligned_0;\n    __local volatile char *restrict sync_arr_mem_23534_backing_0 =\n                          (__local volatile\n                           char *) sync_arr_mem_23534_backing_aligned_1;\n    \n    if (*global_failure >= 0)\n        return;\n    \n    int32_t global_tid_23529;\n    int32_t local_tid_23530;\n    int64_t group_sizze_23533;\n    int32_t wave_sizze_23532;\n    int32_t group_tid_23531;\n    \n    global_tid_23529 = get_global_id(0);\n    local_tid_23530 = get_local_id(0);\n    group_sizze_23533 = get_local_size(0);\n    wave_sizze_23532 = LOCKSTEP_WIDTH;\n    group_tid_23531 = get_group_id(0);\n    \n    int32_t phys_tid_23431;\n    \n    phys_tid_23431 = global_tid_23529;\n    \n    __local char *sync_arr_mem_23534;\n    \n    sync_arr_mem_23534 = (__local char *) sync_arr_mem_23534_backing_0;\n    \n    __local char *red_arr_mem_23536;\n    \n    red_arr_mem_23536 = (__local char *) red_arr_mem_23536_backing_1;\n    \n    int64_t dummy_23429;\n    \n    dummy_23429 = 0;\n    \n    int64_t gtid_23430;\n    \n    gtid_23430 = 0;\n    \n    int64_t x_acc_23538;\n    int64_t chunk_sizze_23539;\n    \n    chunk_sizze_23539 = smin64(sdiv_up64(9,\n                                         sext_i32_i64(sext_i64_i32(segred_group_sizze_23427 *\n                                         segred_num_groups_23425))),\n                               sdiv_up64(9 - sext_i32_i64(phys_tid_23431),\n                                         num_threads_23528));\n    \n    int64_t x_23432;\n    int64_t y_23433;\n    \n    // neutral-initialise the accumulators\n    {\n        x_acc_23538 = 0;\n    }\n    for (int64_t i_23543 = 0; i_23543 < chunk_sizze_23539; i_23543++) {\n        gtid_23430 = sext_i32_i64(phys_tid_23431) + num_threads_23528 * i_23543;\n        // apply map function\n        {\n            int64_t res_23436 = ((__global int64_t *) mem_23223)[gtid_23430];\n            int64_t bytes_23437 = 4 * res_23436;\n     ",
                   "       \n            // save map-out results\n            { }\n            // load accumulator\n            {\n                x_23432 = x_acc_23538;\n            }\n            // load new values\n            {\n                y_23433 = bytes_23437;\n            }\n            // apply reduction operator\n            {\n                int64_t zz_23434 = smax64(x_23432, y_23433);\n                \n                // store in accumulator\n                {\n                    x_acc_23538 = zz_23434;\n                }\n            }\n        }\n    }\n    // to reduce current chunk, first store our result in memory\n    {\n        x_23432 = x_acc_23538;\n        ((__local int64_t *) red_arr_mem_23536)[sext_i32_i64(local_tid_23530)] =\n            x_23432;\n    }\n    barrier(CLK_LOCAL_MEM_FENCE);\n    \n    int32_t offset_23544;\n    int32_t skip_waves_23545;\n    \n    skip_waves_23545 = 1;\n    \n    int64_t x_23540;\n    int64_t y_23541;\n    \n    offset_23544 = 0;\n    // participating threads read initial accumulator\n    {\n        if (slt32(local_tid_23530, sext_i64_i32(segred_group_sizze_23427))) {\n            x_23540 = ((__local\n                        int64_t *) red_arr_mem_23536)[sext_i32_i64(local_tid_23530 +\n                                                      offset_23544)];\n        }\n    }\n    offset_23544 = 1;\n    while (slt32(offset_23544, wave_sizze_23532)) {\n        if (slt32(local_tid_23530 + offset_23544,\n                  sext_i64_i32(segred_group_sizze_23427)) && ((local_tid_23530 -\n                                                               squot32(local_tid_23530,\n                                                                       wave_sizze_23532) *\n                                                               wave_sizze_23532) &\n                                                              (2 *\n                                                               offset_23544 -\n                                                               1)) == 0) {\n            // read arr",
                   "ay element\n            {\n                y_23541 = ((volatile __local\n                            int64_t *) red_arr_mem_23536)[sext_i32_i64(local_tid_23530 +\n                                                          offset_23544)];\n            }\n            // apply reduction operation\n            {\n                int64_t zz_23542 = smax64(x_23540, y_23541);\n                \n                x_23540 = zz_23542;\n            }\n            // write result of operation\n            {\n                ((volatile __local\n                  int64_t *) red_arr_mem_23536)[sext_i32_i64(local_tid_23530)] =\n                    x_23540;\n            }\n        }\n        offset_23544 *= 2;\n    }\n    while (slt32(skip_waves_23545,\n                 squot32(sext_i64_i32(segred_group_sizze_23427) +\n                         wave_sizze_23532 - 1, wave_sizze_23532))) {\n        barrier(CLK_LOCAL_MEM_FENCE);\n        offset_23544 = skip_waves_23545 * wave_sizze_23532;\n        if (slt32(local_tid_23530 + offset_23544,\n                  sext_i64_i32(segred_group_sizze_23427)) && ((local_tid_23530 -\n                                                               squot32(local_tid_23530,\n                                                                       wave_sizze_23532) *\n                                                               wave_sizze_23532) ==\n                                                              0 &&\n                                                              (squot32(local_tid_23530,\n                                                                       wave_sizze_23532) &\n                                                               (2 *\n                                                                skip_waves_23545 -\n                                                                1)) == 0)) {\n            // read array element\n            {\n                y_23541 = ((__local\n                            int64_t *) red_arr_mem_23536)[sext_i32_i64(local_tid_23530 +\n    ",
                   "                                                      offset_23544)];\n            }\n            // apply reduction operation\n            {\n                int64_t zz_23542 = smax64(x_23540, y_23541);\n                \n                x_23540 = zz_23542;\n            }\n            // write result of operation\n            {\n                ((__local\n                  int64_t *) red_arr_mem_23536)[sext_i32_i64(local_tid_23530)] =\n                    x_23540;\n            }\n        }\n        skip_waves_23545 *= 2;\n    }\n    barrier(CLK_LOCAL_MEM_FENCE);\n    // first thread saves the result in accumulator\n    {\n        if (sext_i32_i64(local_tid_23530) == 0) {\n            x_acc_23538 = x_23540;\n        }\n    }\n    \n    int32_t old_counter_23546;\n    \n    // first thread in group saves group result to global memory\n    {\n        if (local_tid_23530 == 0) {\n            ((__global\n              int64_t *) group_res_arr_mem_23526)[sext_i32_i64(group_tid_23531) *\n                                                  segred_group_sizze_23427] =\n                x_acc_23538;\n            mem_fence_global();\n            old_counter_23546 = atomic_add_i32_global(&((volatile __global\n                                                         int *) testzicounter_mem_23524)[0],\n                                                      (int) 1);\n            ((__local bool *) sync_arr_mem_23534)[0] = old_counter_23546 ==\n                segred_num_groups_23425 - 1;\n        }\n    }\n    barrier(CLK_GLOBAL_MEM_FENCE | CLK_LOCAL_MEM_FENCE);\n    \n    bool is_last_group_23547;\n    \n    is_last_group_23547 = ((__local bool *) sync_arr_mem_23534)[0];\n    if (is_last_group_23547) {\n        if (local_tid_23530 == 0) {\n            old_counter_23546 = atomic_add_i32_global(&((volatile __global\n                                                         int *) testzicounter_mem_23524)[0],\n                                                      (int) (0 -\n                                                             s",
                   "egred_num_groups_23425));\n        }\n        // read in the per-group-results\n        {\n            int64_t read_per_thread_23548 = sdiv_up64(segred_num_groups_23425,\n                                                      segred_group_sizze_23427);\n            \n            x_23432 = 0;\n            for (int64_t i_23549 = 0; i_23549 < read_per_thread_23548;\n                 i_23549++) {\n                int64_t group_res_id_23550 = sext_i32_i64(local_tid_23530) *\n                        read_per_thread_23548 + i_23549;\n                int64_t index_of_group_res_23551 = group_res_id_23550;\n                \n                if (slt64(group_res_id_23550, segred_num_groups_23425)) {\n                    y_23433 = ((__global\n                                int64_t *) group_res_arr_mem_23526)[index_of_group_res_23551 *\n                                                                    segred_group_sizze_23427];\n                    \n                    int64_t zz_23434;\n                    \n                    zz_23434 = smax64(x_23432, y_23433);\n                    x_23432 = zz_23434;\n                }\n            }\n        }\n        ((__local int64_t *) red_arr_mem_23536)[sext_i32_i64(local_tid_23530)] =\n            x_23432;\n        barrier(CLK_LOCAL_MEM_FENCE);\n        // reduce the per-group results\n        {\n            int32_t offset_23552;\n            int32_t skip_waves_23553;\n            \n            skip_waves_23553 = 1;\n            \n            int64_t x_23540;\n            int64_t y_23541;\n            \n            offset_23552 = 0;\n            // participating threads read initial accumulator\n            {\n                if (slt32(local_tid_23530,\n                          sext_i64_i32(segred_group_sizze_23427))) {\n                    x_23540 = ((__local\n                                int64_t *) red_arr_mem_23536)[sext_i32_i64(local_tid_23530 +\n                                                              offset_23552)];\n                }\n            }\n            of",
                   "fset_23552 = 1;\n            while (slt32(offset_23552, wave_sizze_23532)) {\n                if (slt32(local_tid_23530 + offset_23552,\n                          sext_i64_i32(segred_group_sizze_23427)) &&\n                    ((local_tid_23530 - squot32(local_tid_23530,\n                                                wave_sizze_23532) *\n                      wave_sizze_23532) & (2 * offset_23552 - 1)) == 0) {\n                    // read array element\n                    {\n                        y_23541 = ((volatile __local\n                                    int64_t *) red_arr_mem_23536)[sext_i32_i64(local_tid_23530 +\n                                                                  offset_23552)];\n                    }\n                    // apply reduction operation\n                    {\n                        int64_t zz_23542 = smax64(x_23540, y_23541);\n                        \n                        x_23540 = zz_23542;\n                    }\n                    // write result of operation\n                    {\n                        ((volatile __local\n                          int64_t *) red_arr_mem_23536)[sext_i32_i64(local_tid_23530)] =\n                            x_23540;\n                    }\n                }\n                offset_23552 *= 2;\n            }\n            while (slt32(skip_waves_23553,\n                         squot32(sext_i64_i32(segred_group_sizze_23427) +\n                                 wave_sizze_23532 - 1, wave_sizze_23532))) {\n                barrier(CLK_LOCAL_MEM_FENCE);\n                offset_23552 = skip_waves_23553 * wave_sizze_23532;\n                if (slt32(local_tid_23530 + offset_23552,\n                          sext_i64_i32(segred_group_sizze_23427)) &&\n                    ((local_tid_23530 - squot32(local_tid_23530,\n                                                wave_sizze_23532) *\n                      wave_sizze_23532) == 0 && (squot32(local_tid_23530,\n                                                         wave_sizze_23",
                   "532) &\n                                                 (2 * skip_waves_23553 - 1)) ==\n                     0)) {\n                    // read array element\n                    {\n                        y_23541 = ((__local\n                                    int64_t *) red_arr_mem_23536)[sext_i32_i64(local_tid_23530 +\n                                                                  offset_23552)];\n                    }\n                    // apply reduction operation\n                    {\n                        int64_t zz_23542 = smax64(x_23540, y_23541);\n                        \n                        x_23540 = zz_23542;\n                    }\n                    // write result of operation\n                    {\n                        ((__local\n                          int64_t *) red_arr_mem_23536)[sext_i32_i64(local_tid_23530)] =\n                            x_23540;\n                    }\n                }\n                skip_waves_23553 *= 2;\n            }\n            // and back to memory with the final result\n            {\n                if (local_tid_23530 == 0) {\n                    ((__global int64_t *) mem_23443)[0] = x_23540;\n                }\n            }\n        }\n    }\n    \n  error_1:\n    return;\n    #undef segred_num_groups_23425\n    #undef segred_group_sizze_23427\n}\n__kernel void testzisegred_nonseg_23463(__global int *global_failure,\n                                        __local volatile\n                                        int64_t *red_arr_mem_23573_backing_aligned_0,\n                                        __local volatile\n                                        int64_t *sync_arr_mem_23571_backing_aligned_1,\n                                        __global unsigned char *mem_23223,\n                                        __global unsigned char *mem_23475,\n                                        __global\n                                        unsigned char *testzicounter_mem_23561,\n                                        __global\n       ",
                   "                                 unsigned char *group_res_arr_mem_23563,\n                                        int64_t num_threads_23565)\n{\n    #define segred_num_groups_23457 (testzisegred_num_groups_23456)\n    #define segred_group_sizze_23459 (testzisegred_group_sizze_23458)\n    \n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    __local volatile char *restrict red_arr_mem_23573_backing_1 =\n                          (__local volatile\n                           char *) red_arr_mem_23573_backing_aligned_0;\n    __local volatile char *restrict sync_arr_mem_23571_backing_0 =\n                          (__local volatile\n                           char *) sync_arr_mem_23571_backing_aligned_1;\n    \n    if (*global_failure >= 0)\n        return;\n    \n    int32_t global_tid_23566;\n    int32_t local_tid_23567;\n    int64_t group_sizze_23570;\n    int32_t wave_sizze_23569;\n    int32_t group_tid_23568;\n    \n    global_tid_23566 = get_global_id(0);\n    local_tid_23567 = get_local_id(0);\n    group_sizze_23570 = get_local_size(0);\n    wave_sizze_23569 = LOCKSTEP_WIDTH;\n    group_tid_23568 = get_group_id(0);\n    \n    int32_t phys_tid_23463;\n    \n    phys_tid_23463 = global_tid_23566;\n    \n    __local char *sync_arr_mem_23571;\n    \n    sync_arr_mem_23571 = (__local char *) sync_arr_mem_23571_backing_0;\n    \n    __local char *red_arr_mem_23573;\n    \n    red_arr_mem_23573 = (__local char *) red_arr_mem_23573_backing_1;\n    \n    int64_t dummy_23461;\n    \n    dummy_23461 = 0;\n    \n    int64_t gtid_23462;\n    \n    gtid_23462 = 0;\n    \n    int64_t x_acc_23575;\n    int64_t chunk_sizze_23576;\n    \n    chunk_sizze_23576 = smin64(sdiv_up64(9,\n                                         sext_i32_i64(sext_i64_i32(segred_group_sizze_23459 *\n                                         segred_num_groups_23457))),\n                               sdiv_up64(9 - sext_i32_i64(phys_tid_23463),\n                                         num_threads_23565));\n    \n    int64",
                   "_t x_23464;\n    int64_t y_23465;\n    \n    // neutral-initialise the accumulators\n    {\n        x_acc_23575 = 0;\n    }\n    for (int64_t i_23580 = 0; i_23580 < chunk_sizze_23576; i_23580++) {\n        gtid_23462 = sext_i32_i64(phys_tid_23463) + num_threads_23565 * i_23580;\n        // apply map function\n        {\n            int64_t res_23468 = ((__global int64_t *) mem_23223)[gtid_23462];\n            int64_t bytes_23469 = 4 * res_23468;\n            \n            // save map-out results\n            { }\n            // load accumulator\n            {\n                x_23464 = x_acc_23575;\n            }\n            // load new values\n            {\n                y_23465 = bytes_23469;\n            }\n            // apply reduction operator\n            {\n                int64_t zz_23466 = smax64(x_23464, y_23465);\n                \n                // store in accumulator\n                {\n                    x_acc_23575 = zz_23466;\n                }\n            }\n        }\n    }\n    // to reduce current chunk, first store our result in memory\n    {\n        x_23464 = x_acc_23575;\n        ((__local int64_t *) red_arr_mem_23573)[sext_i32_i64(local_tid_23567)] =\n            x_23464;\n    }\n    barrier(CLK_LOCAL_MEM_FENCE);\n    \n    int32_t offset_23581;\n    int32_t skip_waves_23582;\n    \n    skip_waves_23582 = 1;\n    \n    int64_t x_23577;\n    int64_t y_23578;\n    \n    offset_23581 = 0;\n    // participating threads read initial accumulator\n    {\n        if (slt32(local_tid_23567, sext_i64_i32(segred_group_sizze_23459))) {\n            x_23577 = ((__local\n                        int64_t *) red_arr_mem_23573)[sext_i32_i64(local_tid_23567 +\n                                                      offset_23581)];\n        }\n    }\n    offset_23581 = 1;\n    while (slt32(offset_23581, wave_sizze_23569)) {\n        if (slt32(local_tid_23567 + offset_23581,\n                  sext_i64_i32(segred_group_sizze_23459)) && ((local_tid_23567 -\n                                                              ",
                   " squot32(local_tid_23567,\n                                                                       wave_sizze_23569) *\n                                                               wave_sizze_23569) &\n                                                              (2 *\n                                                               offset_23581 -\n                                                               1)) == 0) {\n            // read array element\n            {\n                y_23578 = ((volatile __local\n                            int64_t *) red_arr_mem_23573)[sext_i32_i64(local_tid_23567 +\n                                                          offset_23581)];\n            }\n            // apply reduction operation\n            {\n                int64_t zz_23579 = smax64(x_23577, y_23578);\n                \n                x_23577 = zz_23579;\n            }\n            // write result of operation\n            {\n                ((volatile __local\n                  int64_t *) red_arr_mem_23573)[sext_i32_i64(local_tid_23567)] =\n                    x_23577;\n            }\n        }\n        offset_23581 *= 2;\n    }\n    while (slt32(skip_waves_23582,\n                 squot32(sext_i64_i32(segred_group_sizze_23459) +\n                         wave_sizze_23569 - 1, wave_sizze_23569))) {\n        barrier(CLK_LOCAL_MEM_FENCE);\n        offset_23581 = skip_waves_23582 * wave_sizze_23569;\n        if (slt32(local_tid_23567 + offset_23581,\n                  sext_i64_i32(segred_group_sizze_23459)) && ((local_tid_23567 -\n                                                               squot32(local_tid_23567,\n                                                                       wave_sizze_23569) *\n                                                               wave_sizze_23569) ==\n                                                              0 &&\n                                                              (squot32(local_tid_23567,\n                                                     ",
                   "                  wave_sizze_23569) &\n                                                               (2 *\n                                                                skip_waves_23582 -\n                                                                1)) == 0)) {\n            // read array element\n            {\n                y_23578 = ((__local\n                            int64_t *) red_arr_mem_23573)[sext_i32_i64(local_tid_23567 +\n                                                          offset_23581)];\n            }\n            // apply reduction operation\n            {\n                int64_t zz_23579 = smax64(x_23577, y_23578);\n                \n                x_23577 = zz_23579;\n            }\n            // write result of operation\n            {\n                ((__local\n                  int64_t *) red_arr_mem_23573)[sext_i32_i64(local_tid_23567)] =\n                    x_23577;\n            }\n        }\n        skip_waves_23582 *= 2;\n    }\n    barrier(CLK_LOCAL_MEM_FENCE);\n    // first thread saves the result in accumulator\n    {\n        if (sext_i32_i64(local_tid_23567) == 0) {\n            x_acc_23575 = x_23577;\n        }\n    }\n    \n    int32_t old_counter_23583;\n    \n    // first thread in group saves group result to global memory\n    {\n        if (local_tid_23567 == 0) {\n            ((__global\n              int64_t *) group_res_arr_mem_23563)[sext_i32_i64(group_tid_23568) *\n                                                  segred_group_sizze_23459] =\n                x_acc_23575;\n            mem_fence_global();\n            old_counter_23583 = atomic_add_i32_global(&((volatile __global\n                                                         int *) testzicounter_mem_23561)[0],\n                                                      (int) 1);\n            ((__local bool *) sync_arr_mem_23571)[0] = old_counter_23583 ==\n                segred_num_groups_23457 - 1;\n        }\n    }\n    barrier(CLK_GLOBAL_MEM_FENCE | CLK_LOCAL_MEM_FENCE);\n    \n    bool is_last_group",
                   "_23584;\n    \n    is_last_group_23584 = ((__local bool *) sync_arr_mem_23571)[0];\n    if (is_last_group_23584) {\n        if (local_tid_23567 == 0) {\n            old_counter_23583 = atomic_add_i32_global(&((volatile __global\n                                                         int *) testzicounter_mem_23561)[0],\n                                                      (int) (0 -\n                                                             segred_num_groups_23457));\n        }\n        // read in the per-group-results\n        {\n            int64_t read_per_thread_23585 = sdiv_up64(segred_num_groups_23457,\n                                                      segred_group_sizze_23459);\n            \n            x_23464 = 0;\n            for (int64_t i_23586 = 0; i_23586 < read_per_thread_23585;\n                 i_23586++) {\n                int64_t group_res_id_23587 = sext_i32_i64(local_tid_23567) *\n                        read_per_thread_23585 + i_23586;\n                int64_t index_of_group_res_23588 = group_res_id_23587;\n                \n                if (slt64(group_res_id_23587, segred_num_groups_23457)) {\n                    y_23465 = ((__global\n                                int64_t *) group_res_arr_mem_23563)[index_of_group_res_23588 *\n                                                                    segred_group_sizze_23459];\n                    \n                    int64_t zz_23466;\n                    \n                    zz_23466 = smax64(x_23464, y_23465);\n                    x_23464 = zz_23466;\n                }\n            }\n        }\n        ((__local int64_t *) red_arr_mem_23573)[sext_i32_i64(local_tid_23567)] =\n            x_23464;\n        barrier(CLK_LOCAL_MEM_FENCE);\n        // reduce the per-group results\n        {\n            int32_t offset_23589;\n            int32_t skip_waves_23590;\n            \n            skip_waves_23590 = 1;\n            \n            int64_t x_23577;\n            int64_t y_23578;\n            \n            offset_23589 = 0;\n  ",
                   "          // participating threads read initial accumulator\n            {\n                if (slt32(local_tid_23567,\n                          sext_i64_i32(segred_group_sizze_23459))) {\n                    x_23577 = ((__local\n                                int64_t *) red_arr_mem_23573)[sext_i32_i64(local_tid_23567 +\n                                                              offset_23589)];\n                }\n            }\n            offset_23589 = 1;\n            while (slt32(offset_23589, wave_sizze_23569)) {\n                if (slt32(local_tid_23567 + offset_23589,\n                          sext_i64_i32(segred_group_sizze_23459)) &&\n                    ((local_tid_23567 - squot32(local_tid_23567,\n                                                wave_sizze_23569) *\n                      wave_sizze_23569) & (2 * offset_23589 - 1)) == 0) {\n                    // read array element\n                    {\n                        y_23578 = ((volatile __local\n                                    int64_t *) red_arr_mem_23573)[sext_i32_i64(local_tid_23567 +\n                                                                  offset_23589)];\n                    }\n                    // apply reduction operation\n                    {\n                        int64_t zz_23579 = smax64(x_23577, y_23578);\n                        \n                        x_23577 = zz_23579;\n                    }\n                    // write result of operation\n                    {\n                        ((volatile __local\n                          int64_t *) red_arr_mem_23573)[sext_i32_i64(local_tid_23567)] =\n                            x_23577;\n                    }\n                }\n                offset_23589 *= 2;\n            }\n            while (slt32(skip_waves_23590,\n                         squot32(sext_i64_i32(segred_group_sizze_23459) +\n                                 wave_sizze_23569 - 1, wave_sizze_23569))) {\n                barrier(CLK_LOCAL_MEM_FENCE);\n                offset_23589 ",
                   "= skip_waves_23590 * wave_sizze_23569;\n                if (slt32(local_tid_23567 + offset_23589,\n                          sext_i64_i32(segred_group_sizze_23459)) &&\n                    ((local_tid_23567 - squot32(local_tid_23567,\n                                                wave_sizze_23569) *\n                      wave_sizze_23569) == 0 && (squot32(local_tid_23567,\n                                                         wave_sizze_23569) &\n                                                 (2 * skip_waves_23590 - 1)) ==\n                     0)) {\n                    // read array element\n                    {\n                        y_23578 = ((__local\n                                    int64_t *) red_arr_mem_23573)[sext_i32_i64(local_tid_23567 +\n                                                                  offset_23589)];\n                    }\n                    // apply reduction operation\n                    {\n                        int64_t zz_23579 = smax64(x_23577, y_23578);\n                        \n                        x_23577 = zz_23579;\n                    }\n                    // write result of operation\n                    {\n                        ((__local\n                          int64_t *) red_arr_mem_23573)[sext_i32_i64(local_tid_23567)] =\n                            x_23577;\n                    }\n                }\n                skip_waves_23590 *= 2;\n            }\n            // and back to memory with the final result\n            {\n                if (local_tid_23567 == 0) {\n                    ((__global int64_t *) mem_23475)[0] = x_23577;\n                }\n            }\n        }\n    }\n    \n  error_1:\n    return;\n    #undef segred_num_groups_23457\n    #undef segred_group_sizze_23459\n}\n__kernel void testzisegred_small_22416(__global int *global_failure,\n                                       int failure_is_an_option, __global\n                                       int64_t *global_failure_args,\n                                     ",
                   "  __local volatile\n                                       int64_t *red_arr_mem_23684_backing_aligned_0,\n                                       int64_t paths_18528, int64_t steps_18529,\n                                       float sims_per_year_18620,\n                                       int64_t num_groups_22968, __global\n                                       unsigned char *res_mem_23275, __global\n                                       unsigned char *res_mem_23276, __global\n                                       unsigned char *res_mem_23277, __global\n                                       unsigned char *res_mem_23278, __global\n                                       unsigned char *mem_23306, __global\n                                       unsigned char *mem_23319,\n                                       int64_t segment_sizze_nonzzero_23677)\n{\n    #define segred_group_sizze_22967 (testzisegred_group_sizze_22410)\n    \n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    __local volatile char *restrict red_arr_mem_23684_backing_0 =\n                          (__local volatile\n                           char *) red_arr_mem_23684_backing_aligned_0;\n    volatile __local bool local_failure;\n    \n    if (failure_is_an_option) {\n        int failed = *global_failure >= 0;\n        \n        if (failed)\n            return;\n    }\n    local_failure = false;\n    barrier(CLK_LOCAL_MEM_FENCE);\n    \n    int32_t global_tid_23679;\n    int32_t local_tid_23680;\n    int64_t group_sizze_23683;\n    int32_t wave_sizze_23682;\n    int32_t group_tid_23681;\n    \n    global_tid_23679 = get_global_id(0);\n    local_tid_23680 = get_local_id(0);\n    group_sizze_23683 = get_local_size(0);\n    wave_sizze_23682 = LOCKSTEP_WIDTH;\n    group_tid_23681 = get_group_id(0);\n    \n    int32_t phys_tid_22416;\n    \n    phys_tid_22416 = global_tid_23679;\n    \n    __local char *red_arr_mem_23684;\n    \n    red_arr_mem_23684 = (__local char *) red_arr_mem_23684_backing_0;\n    \n  ",
                   "  int32_t phys_group_id_23686;\n    \n    phys_group_id_23686 = get_group_id(0);\n    for (int32_t i_23687 = 0; i_23687 <\n         sdiv_up32(sext_i64_i32(sdiv_up64(steps_18529,\n                                          squot64(segred_group_sizze_22967,\n                                                  segment_sizze_nonzzero_23677))) -\n                   phys_group_id_23686, sext_i64_i32(num_groups_22968));\n         i_23687++) {\n        int32_t virt_group_id_23688 = phys_group_id_23686 + i_23687 *\n                sext_i64_i32(num_groups_22968);\n        int64_t gtid_22407 = squot64(sext_i32_i64(local_tid_23680),\n                                     segment_sizze_nonzzero_23677) +\n                sext_i32_i64(virt_group_id_23688) *\n                squot64(segred_group_sizze_22967, segment_sizze_nonzzero_23677);\n        int64_t gtid_22415 = srem64(sext_i32_i64(local_tid_23680), paths_18528);\n        \n        // apply map function if in bounds\n        {\n            if (slt64(0, paths_18528) && (slt64(gtid_22407, steps_18529) &&\n                                          slt64(sext_i32_i64(local_tid_23680),\n                                                paths_18528 *\n                                                squot64(segred_group_sizze_22967,\n                                                        segment_sizze_nonzzero_23677)))) {\n                float x_22976 = ((__global float *) mem_23306)[gtid_22407 *\n                                                               paths_18528 +\n                                                               gtid_22415];\n                int64_t convop_x_23145 = add64(1, gtid_22407);\n                float binop_x_23146 = sitofp_i64_f32(convop_x_23145);\n                float index_primexp_23147 = binop_x_23146 / sims_per_year_18620;\n                float res_22978;\n                float redout_23202 = 0.0F;\n                \n                for (int32_t i_23219 = 0; i_23219 < 9; i_23219++) {\n                    int64_t i_23203 = sext_i32",
                   "_i64(i_23219);\n                    int64_t x_22984 = ((__global\n                                        int64_t *) res_mem_23277)[i_23203];\n                    float x_22985 = ((__global float *) res_mem_23278)[i_23203];\n                    int64_t i64_arg_22986 = sub64(x_22984, 1);\n                    float res_22987 = sitofp_i64_f32(i64_arg_22986);\n                    float y_22988 = x_22985 * res_22987;\n                    bool cond_22989 = y_22988 < index_primexp_23147;\n                    float ceil_arg_22990 = index_primexp_23147 / x_22985;\n                    float res_22991;\n                    \n                    res_22991 = futrts_ceil32(ceil_arg_22990);\n                    \n                    int64_t res_22992 = fptosi_f32_i64(res_22991);\n                    int64_t remaining_22993 = sub64(x_22984, res_22992);\n                    float res_22994;\n                    \n                    if (cond_22989) {\n                        res_22994 = 0.0F;\n                    } else {\n                        float x_22982 = ((__global\n                                          float *) res_mem_23275)[i_23203];\n                        float x_22983 = ((__global\n                                          float *) res_mem_23276)[i_23203];\n                        float nextpayment_22995 = x_22985 * res_22991;\n                        bool bounds_invalid_upwards_22996 =\n                             slt64(remaining_22993, 1);\n                        bool valid_22997 = !bounds_invalid_upwards_22996;\n                        bool range_valid_c_22998;\n                        \n                        if (!valid_22997) {\n                            {\n                                if (atomic_cmpxchg_i32_global(global_failure,\n                                                              -1, 32) == -1) {\n                                    global_failure_args[0] = 1;\n                                    global_failure_args[1] = 2;\n                                    global_failur",
                   "e_args[2] = remaining_22993;\n                                    ;\n                                }\n                                local_failure = true;\n                                goto error_0;\n                            }\n                        }\n                        \n                        float y_23000 = nextpayment_22995 - index_primexp_23147;\n                        float negate_arg_23001 = 1.0e-2F * y_23000;\n                        float exp_arg_23002 = 0.0F - negate_arg_23001;\n                        float res_23003 = fpow32(2.7182817F, exp_arg_23002);\n                        float x_23004 = 1.0F - res_23003;\n                        float B_23005 = x_23004 / 1.0e-2F;\n                        float x_23006 = B_23005 - nextpayment_22995;\n                        float x_23007 = x_23006 + index_primexp_23147;\n                        float x_23008 = 4.4999997e-6F * x_23007;\n                        float A1_23009 = x_23008 / 1.0e-4F;\n                        float y_23010 = fpow32(B_23005, 2.0F);\n                        float x_23011 = 1.0000001e-6F * y_23010;\n                        float A2_23012 = x_23011 / 4.0e-2F;\n                        float exp_arg_23013 = A1_23009 - A2_23012;\n                        float res_23014 = fpow32(2.7182817F, exp_arg_23013);\n                        float negate_arg_23015 = x_22976 * B_23005;\n                        float exp_arg_23016 = 0.0F - negate_arg_23015;\n                        float res_23017 = fpow32(2.7182817F, exp_arg_23016);\n                        float res_23018 = res_23014 * res_23017;\n                        bool y_23019 = slt64(0, remaining_22993);\n                        bool index_certs_23020;\n                        \n                        if (!y_23019) {\n                            {\n                                if (atomic_cmpxchg_i32_global(global_failure,\n                                                              -1, 33) == -1) {\n                                    global_failure_args[0] =",
                   " 0;\n                                    global_failure_args[1] = remaining_22993;\n                                    ;\n                                }\n                                local_failure = true;\n                                goto error_0;\n                            }\n                        }\n                        \n                        float binop_y_23021 = sitofp_i64_f32(remaining_22993);\n                        float binop_y_23022 = x_22985 * binop_y_23021;\n                        float index_primexp_23023 = nextpayment_22995 +\n                              binop_y_23022;\n                        float y_23024 = index_primexp_23023 -\n                              index_primexp_23147;\n                        float negate_arg_23025 = 1.0e-2F * y_23024;\n                        float exp_arg_23026 = 0.0F - negate_arg_23025;\n                        float res_23027 = fpow32(2.7182817F, exp_arg_23026);\n                        float x_23028 = 1.0F - res_23027;\n                        float B_23029 = x_23028 / 1.0e-2F;\n                        float x_23030 = B_23029 - index_primexp_23023;\n                        float x_23031 = x_23030 + index_primexp_23147;\n                        float x_23032 = 4.4999997e-6F * x_23031;\n                        float A1_23033 = x_23032 / 1.0e-4F;\n                        float y_23034 = fpow32(B_23029, 2.0F);\n                        float x_23035 = 1.0000001e-6F * y_23034;\n                        float A2_23036 = x_23035 / 4.0e-2F;\n                        float exp_arg_23037 = A1_23033 - A2_23036;\n                        float res_23038 = fpow32(2.7182817F, exp_arg_23037);\n                        float negate_arg_23039 = x_22976 * B_23029;\n                        float exp_arg_23040 = 0.0F - negate_arg_23039;\n                        float res_23041 = fpow32(2.7182817F, exp_arg_23040);\n                        float res_23042 = res_23038 * res_23041;\n                        float res_23043;\n                        float r",
                   "edout_23142 = 0.0F;\n                        \n                        for (int64_t i_23143 = 0; i_23143 < remaining_22993;\n                             i_23143++) {\n                            int64_t index_primexp_23165 = add64(1, i_23143);\n                            float res_23048 =\n                                  sitofp_i64_f32(index_primexp_23165);\n                            float res_23049 = x_22985 * res_23048;\n                            float res_23050 = nextpayment_22995 + res_23049;\n                            float y_23051 = res_23050 - index_primexp_23147;\n                            float negate_arg_23052 = 1.0e-2F * y_23051;\n                            float exp_arg_23053 = 0.0F - negate_arg_23052;\n                            float res_23054 = fpow32(2.7182817F, exp_arg_23053);\n                            float x_23055 = 1.0F - res_23054;\n                            float B_23056 = x_23055 / 1.0e-2F;\n                            float x_23057 = B_23056 - res_23050;\n                            float x_23058 = x_23057 + index_primexp_23147;\n                            float x_23059 = 4.4999997e-6F * x_23058;\n                            float A1_23060 = x_23059 / 1.0e-4F;\n                            float y_23061 = fpow32(B_23056, 2.0F);\n                            float x_23062 = 1.0000001e-6F * y_23061;\n                            float A2_23063 = x_23062 / 4.0e-2F;\n                            float exp_arg_23064 = A1_23060 - A2_23063;\n                            float res_23065 = fpow32(2.7182817F, exp_arg_23064);\n                            float negate_arg_23066 = x_22976 * B_23056;\n                            float exp_arg_23067 = 0.0F - negate_arg_23066;\n                            float res_23068 = fpow32(2.7182817F, exp_arg_23067);\n                            float res_23069 = res_23065 * res_23068;\n                            float res_23046 = res_23069 + redout_23142;\n                            float redout_tmp_23690 = res_23046;\n          ",
                   "                  \n                            redout_23142 = redout_tmp_23690;\n                        }\n                        res_23043 = redout_23142;\n                        \n                        float x_23070 = res_23018 - res_23042;\n                        float x_23071 = x_22982 * x_22985;\n                        float y_23072 = res_23043 * x_23071;\n                        float y_23073 = x_23070 - y_23072;\n                        float res_23074 = x_22983 * y_23073;\n                        \n                        res_22994 = res_23074;\n                    }\n                    \n                    float res_22981 = res_22994 + redout_23202;\n                    float redout_tmp_23689 = res_22981;\n                    \n                    redout_23202 = redout_tmp_23689;\n                }\n                res_22978 = redout_23202;\n                \n                float res_23075 = fmax32(0.0F, res_22978);\n                \n                // save map-out results\n                { }\n                // save results to be reduced\n                {\n                    ((__local\n                      float *) red_arr_mem_23684)[sext_i32_i64(local_tid_23680)] =\n                        res_23075;\n                }\n            } else {\n                ((__local\n                  float *) red_arr_mem_23684)[sext_i32_i64(local_tid_23680)] =\n                    0.0F;\n            }\n        }\n        \n      error_0:\n        barrier(CLK_LOCAL_MEM_FENCE);\n        if (local_failure)\n            return;\n        barrier(CLK_LOCAL_MEM_FENCE);\n        if (slt64(0, paths_18528)) {\n            // perform segmented scan to imitate reduction\n            {\n                float x_22971;\n                float x_22972;\n                float x_23691;\n                float x_23692;\n                bool ltid_in_bounds_23694;\n                \n                ltid_in_bounds_23694 = slt64(sext_i32_i64(local_tid_23680),\n                                             paths_18528 *\n            ",
                   "                                 squot64(segred_group_sizze_22967,\n                                                     segment_sizze_nonzzero_23677));\n                \n                int32_t skip_threads_23695;\n                \n                // read input for in-block scan\n                {\n                    if (ltid_in_bounds_23694) {\n                        x_22972 = ((volatile __local\n                                    float *) red_arr_mem_23684)[sext_i32_i64(local_tid_23680)];\n                        if ((local_tid_23680 - squot32(local_tid_23680, 32) *\n                             32) == 0) {\n                            x_22971 = x_22972;\n                        }\n                    }\n                }\n                // in-block scan (hopefully no barriers needed)\n                {\n                    skip_threads_23695 = 1;\n                    while (slt32(skip_threads_23695, 32)) {\n                        if (sle32(skip_threads_23695, local_tid_23680 -\n                                  squot32(local_tid_23680, 32) * 32) &&\n                            ltid_in_bounds_23694) {\n                            // read operands\n                            {\n                                x_22971 = ((volatile __local\n                                            float *) red_arr_mem_23684)[sext_i32_i64(local_tid_23680) -\n                                                                        sext_i32_i64(skip_threads_23695)];\n                            }\n                            // perform operation\n                            {\n                                bool inactive_23696 =\n                                     slt64(srem64(sext_i32_i64(local_tid_23680),\n                                                  paths_18528),\n                                           sext_i32_i64(local_tid_23680) -\n                                           sext_i32_i64(local_tid_23680 -\n                                           skip_threads_23695));\n                        ",
                   "        \n                                if (inactive_23696) {\n                                    x_22971 = x_22972;\n                                }\n                                if (!inactive_23696) {\n                                    float res_22973 = x_22971 + x_22972;\n                                    \n                                    x_22971 = res_22973;\n                                }\n                            }\n                        }\n                        if (sle32(wave_sizze_23682, skip_threads_23695)) {\n                            barrier(CLK_LOCAL_MEM_FENCE);\n                        }\n                        if (sle32(skip_threads_23695, local_tid_23680 -\n                                  squot32(local_tid_23680, 32) * 32) &&\n                            ltid_in_bounds_23694) {\n                            // write result\n                            {\n                                ((volatile __local\n                                  float *) red_arr_mem_23684)[sext_i32_i64(local_tid_23680)] =\n                                    x_22971;\n                                x_22972 = x_22971;\n                            }\n                        }\n                        if (sle32(wave_sizze_23682, skip_threads_23695)) {\n                            barrier(CLK_LOCAL_MEM_FENCE);\n                        }\n                        skip_threads_23695 *= 2;\n                    }\n                }\n                barrier(CLK_LOCAL_MEM_FENCE);\n                // last thread of block 'i' writes its result to offset 'i'\n                {\n                    if ((local_tid_23680 - squot32(local_tid_23680, 32) * 32) ==\n                        31 && ltid_in_bounds_23694) {\n                        ((volatile __local\n                          float *) red_arr_mem_23684)[sext_i32_i64(squot32(local_tid_23680,\n                                                                           32))] =\n                            x_22971;\n                    }\n         ",
                   "       }\n                barrier(CLK_LOCAL_MEM_FENCE);\n                // scan the first block, after which offset 'i' contains carry-in for block 'i+1'\n                {\n                    int32_t skip_threads_23697;\n                    \n                    // read input for in-block scan\n                    {\n                        if (squot32(local_tid_23680, 32) == 0 &&\n                            ltid_in_bounds_23694) {\n                            x_23692 = ((volatile __local\n                                        float *) red_arr_mem_23684)[sext_i32_i64(local_tid_23680)];\n                            if ((local_tid_23680 - squot32(local_tid_23680,\n                                                           32) * 32) == 0) {\n                                x_23691 = x_23692;\n                            }\n                        }\n                    }\n                    // in-block scan (hopefully no barriers needed)\n                    {\n                        skip_threads_23697 = 1;\n                        while (slt32(skip_threads_23697, 32)) {\n                            if (sle32(skip_threads_23697, local_tid_23680 -\n                                      squot32(local_tid_23680, 32) * 32) &&\n                                (squot32(local_tid_23680, 32) == 0 &&\n                                 ltid_in_bounds_23694)) {\n                                // read operands\n                                {\n                                    x_23691 = ((volatile __local\n                                                float *) red_arr_mem_23684)[sext_i32_i64(local_tid_23680) -\n                                                                            sext_i32_i64(skip_threads_23697)];\n                                }\n                                // perform operation\n                                {\n                                    bool inactive_23698 =\n                                         slt64(srem64(sext_i32_i64(local_tid_23680 *\n                 ",
                   "                                     32 + 32 - 1),\n                                                      paths_18528),\n                                               sext_i32_i64(local_tid_23680 *\n                                               32 + 32 - 1) -\n                                               sext_i32_i64((local_tid_23680 -\n                                                             skip_threads_23697) *\n                                               32 + 32 - 1));\n                                    \n                                    if (inactive_23698) {\n                                        x_23691 = x_23692;\n                                    }\n                                    if (!inactive_23698) {\n                                        float res_23693 = x_23691 + x_23692;\n                                        \n                                        x_23691 = res_23693;\n                                    }\n                                }\n                            }\n                            if (sle32(wave_sizze_23682, skip_threads_23697)) {\n                                barrier(CLK_LOCAL_MEM_FENCE);\n                            }\n                            if (sle32(skip_threads_23697, local_tid_23680 -\n                                      squot32(local_tid_23680, 32) * 32) &&\n                                (squot32(local_tid_23680, 32) == 0 &&\n                                 ltid_in_bounds_23694)) {\n                                // write result\n                                {\n                                    ((volatile __local\n                                      float *) red_arr_mem_23684)[sext_i32_i64(local_tid_23680)] =\n                                        x_23691;\n                                    x_23692 = x_23691;\n                                }\n                            }\n                            if (sle32(wave_sizze_23682, skip_threads_23697)) {\n                                barrier(CLK_LOCAL_M",
                   "EM_FENCE);\n                            }\n                            skip_threads_23697 *= 2;\n                        }\n                    }\n                }\n                barrier(CLK_LOCAL_MEM_FENCE);\n                // carry-in for every block except the first\n                {\n                    if (!(squot32(local_tid_23680, 32) == 0 ||\n                          !ltid_in_bounds_23694)) {\n                        // read operands\n                        {\n                            x_22972 = x_22971;\n                            x_22971 = ((__local\n                                        float *) red_arr_mem_23684)[sext_i32_i64(squot32(local_tid_23680,\n                                                                                         32)) -\n                                                                    1];\n                        }\n                        // perform operation\n                        {\n                            bool inactive_23699 =\n                                 slt64(srem64(sext_i32_i64(local_tid_23680),\n                                              paths_18528),\n                                       sext_i32_i64(local_tid_23680) -\n                                       sext_i32_i64(squot32(local_tid_23680,\n                                                            32) * 32 - 1));\n                            \n                            if (inactive_23699) {\n                                x_22971 = x_22972;\n                            }\n                            if (!inactive_23699) {\n                                float res_22973 = x_22971 + x_22972;\n                                \n                                x_22971 = res_22973;\n                            }\n                        }\n                        // write final result\n                        {\n                            ((__local\n                              float *) red_arr_mem_23684)[sext_i32_i64(local_tid_23680)] =\n                                x",
                   "_22971;\n                        }\n                    }\n                }\n                barrier(CLK_LOCAL_MEM_FENCE);\n                // restore correct values for first block\n                {\n                    if (squot32(local_tid_23680, 32) == 0) {\n                        ((__local\n                          float *) red_arr_mem_23684)[sext_i32_i64(local_tid_23680)] =\n                            x_22972;\n                    }\n                }\n                barrier(CLK_LOCAL_MEM_FENCE);\n            }\n        }\n        barrier(CLK_LOCAL_MEM_FENCE);\n        // save final values of segments\n        {\n            if (slt64(sext_i32_i64(virt_group_id_23688) *\n                      squot64(segred_group_sizze_22967,\n                              segment_sizze_nonzzero_23677) +\n                      sext_i32_i64(local_tid_23680), steps_18529) &&\n                slt64(sext_i32_i64(local_tid_23680),\n                      squot64(segred_group_sizze_22967,\n                              segment_sizze_nonzzero_23677))) {\n                ((__global\n                  float *) mem_23319)[sext_i32_i64(virt_group_id_23688) *\n                                      squot64(segred_group_sizze_22967,\n                                              segment_sizze_nonzzero_23677) +\n                                      sext_i32_i64(local_tid_23680)] = ((__local\n                                                                         float *) red_arr_mem_23684)[(sext_i32_i64(local_tid_23680) +\n                                                                                                      1) *\n                                                                                                     segment_sizze_nonzzero_23677 -\n                                                                                                     1];\n            }\n        }\n        barrier(CLK_LOCAL_MEM_FENCE);\n        barrier(CLK_GLOBAL_MEM_FENCE | CLK_LOCAL_MEM_FENCE);\n    }\n    \n  error_1:\n    return;\n ",
                   "   #undef segred_group_sizze_22967\n}\n", NULL};
static const char *size_names[] = {"main.segmap_group_size_18863",
                                   "main.segmap_group_size_19039",
                                   "main.segmap_group_size_19372",
                                   "main.segmap_group_size_19471",
                                   "main.segmap_group_size_19534",
                                   "main.segmap_group_size_19818",
                                   "main.segmap_group_size_20240",
                                   "main.segmap_num_groups_19374",
                                   "main.segred_group_size_18839",
                                   "main.segred_group_size_19650",
                                   "main.segred_group_size_20267",
                                   "main.segred_group_size_20549",
                                   "main.segred_group_size_23351",
                                   "main.segred_group_size_23383",
                                   "main.segred_num_groups_18841",
                                   "main.segred_num_groups_19652",
                                   "main.segred_num_groups_20269",
                                   "main.segred_num_groups_20551",
                                   "main.segred_num_groups_23349",
                                   "main.segred_num_groups_23381",
                                   "main.suff_intra_par_7",
                                   "main.suff_outer_par_0",
                                   "main.suff_outer_par_6",
                                   "main.suff_outer_redomap_5",
                                   "test.segmap_group_size_21035",
                                   "test.segmap_group_size_21211",
                                   "test.segmap_group_size_21544",
                                   "test.segmap_group_size_21643",
                                   "test.segmap_group_size_21706",
                                   "test.segmap_group_size_21981",
                                   "test.segmap_group_size_22383",
                                   "test.segmap_num_groups_21546",
                                   "test.segred_group_size_21011",
                                   "test.segred_group_size_21822",
                                   "test.segred_group_size_22410",
                                   "test.segred_group_size_22677",
                                   "test.segred_group_size_23426",
                                   "test.segred_group_size_23458",
                                   "test.segred_num_groups_21013",
                                   "test.segred_num_groups_21824",
                                   "test.segred_num_groups_22412",
                                   "test.segred_num_groups_22679",
                                   "test.segred_num_groups_23424",
                                   "test.segred_num_groups_23456",
                                   "test.suff_intra_par_7",
                                   "test.suff_outer_par_0",
                                   "test.suff_outer_par_6",
                                   "test.suff_outer_redomap_5"};
static const char *size_vars[] = {"mainzisegmap_group_sizze_18863",
                                  "mainzisegmap_group_sizze_19039",
                                  "mainzisegmap_group_sizze_19372",
                                  "mainzisegmap_group_sizze_19471",
                                  "mainzisegmap_group_sizze_19534",
                                  "mainzisegmap_group_sizze_19818",
                                  "mainzisegmap_group_sizze_20240",
                                  "mainzisegmap_num_groups_19374",
                                  "mainzisegred_group_sizze_18839",
                                  "mainzisegred_group_sizze_19650",
                                  "mainzisegred_group_sizze_20267",
                                  "mainzisegred_group_sizze_20549",
                                  "mainzisegred_group_sizze_23351",
                                  "mainzisegred_group_sizze_23383",
                                  "mainzisegred_num_groups_18841",
                                  "mainzisegred_num_groups_19652",
                                  "mainzisegred_num_groups_20269",
                                  "mainzisegred_num_groups_20551",
                                  "mainzisegred_num_groups_23349",
                                  "mainzisegred_num_groups_23381",
                                  "mainzisuff_intra_par_7",
                                  "mainzisuff_outer_par_0",
                                  "mainzisuff_outer_par_6",
                                  "mainzisuff_outer_redomap_5",
                                  "testzisegmap_group_sizze_21035",
                                  "testzisegmap_group_sizze_21211",
                                  "testzisegmap_group_sizze_21544",
                                  "testzisegmap_group_sizze_21643",
                                  "testzisegmap_group_sizze_21706",
                                  "testzisegmap_group_sizze_21981",
                                  "testzisegmap_group_sizze_22383",
                                  "testzisegmap_num_groups_21546",
                                  "testzisegred_group_sizze_21011",
                                  "testzisegred_group_sizze_21822",
                                  "testzisegred_group_sizze_22410",
                                  "testzisegred_group_sizze_22677",
                                  "testzisegred_group_sizze_23426",
                                  "testzisegred_group_sizze_23458",
                                  "testzisegred_num_groups_21013",
                                  "testzisegred_num_groups_21824",
                                  "testzisegred_num_groups_22412",
                                  "testzisegred_num_groups_22679",
                                  "testzisegred_num_groups_23424",
                                  "testzisegred_num_groups_23456",
                                  "testzisuff_intra_par_7",
                                  "testzisuff_outer_par_0",
                                  "testzisuff_outer_par_6",
                                  "testzisuff_outer_redomap_5"};
static const char *size_classes[] = {"group_size", "group_size", "group_size",
                                     "group_size", "group_size", "group_size",
                                     "group_size", "num_groups", "group_size",
                                     "group_size", "group_size", "group_size",
                                     "group_size", "group_size", "num_groups",
                                     "num_groups", "num_groups", "num_groups",
                                     "num_groups", "num_groups",
                                     "threshold (!main.suff_outer_par_6 !main.suff_outer_redomap_5)",
                                     "threshold ()",
                                     "threshold (!main.suff_outer_redomap_5)",
                                     "threshold ()", "group_size", "group_size",
                                     "group_size", "group_size", "group_size",
                                     "group_size", "group_size", "num_groups",
                                     "group_size", "group_size", "group_size",
                                     "group_size", "group_size", "group_size",
                                     "num_groups", "num_groups", "num_groups",
                                     "num_groups", "num_groups", "num_groups",
                                     "threshold (!test.suff_outer_par_6 !test.suff_outer_redomap_5)",
                                     "threshold ()",
                                     "threshold (!test.suff_outer_redomap_5)",
                                     "threshold ()"};
int futhark_get_num_sizes(void)
{
    return 48;
}
const char *futhark_get_size_name(int i)
{
    return size_names[i];
}
const char *futhark_get_size_class(int i)
{
    return size_classes[i];
}
struct sizes {
    size_t mainzisegmap_group_sizze_18863;
    size_t mainzisegmap_group_sizze_19039;
    size_t mainzisegmap_group_sizze_19372;
    size_t mainzisegmap_group_sizze_19471;
    size_t mainzisegmap_group_sizze_19534;
    size_t mainzisegmap_group_sizze_19818;
    size_t mainzisegmap_group_sizze_20240;
    size_t mainzisegmap_num_groups_19374;
    size_t mainzisegred_group_sizze_18839;
    size_t mainzisegred_group_sizze_19650;
    size_t mainzisegred_group_sizze_20267;
    size_t mainzisegred_group_sizze_20549;
    size_t mainzisegred_group_sizze_23351;
    size_t mainzisegred_group_sizze_23383;
    size_t mainzisegred_num_groups_18841;
    size_t mainzisegred_num_groups_19652;
    size_t mainzisegred_num_groups_20269;
    size_t mainzisegred_num_groups_20551;
    size_t mainzisegred_num_groups_23349;
    size_t mainzisegred_num_groups_23381;
    size_t mainzisuff_intra_par_7;
    size_t mainzisuff_outer_par_0;
    size_t mainzisuff_outer_par_6;
    size_t mainzisuff_outer_redomap_5;
    size_t testzisegmap_group_sizze_21035;
    size_t testzisegmap_group_sizze_21211;
    size_t testzisegmap_group_sizze_21544;
    size_t testzisegmap_group_sizze_21643;
    size_t testzisegmap_group_sizze_21706;
    size_t testzisegmap_group_sizze_21981;
    size_t testzisegmap_group_sizze_22383;
    size_t testzisegmap_num_groups_21546;
    size_t testzisegred_group_sizze_21011;
    size_t testzisegred_group_sizze_21822;
    size_t testzisegred_group_sizze_22410;
    size_t testzisegred_group_sizze_22677;
    size_t testzisegred_group_sizze_23426;
    size_t testzisegred_group_sizze_23458;
    size_t testzisegred_num_groups_21013;
    size_t testzisegred_num_groups_21824;
    size_t testzisegred_num_groups_22412;
    size_t testzisegred_num_groups_22679;
    size_t testzisegred_num_groups_23424;
    size_t testzisegred_num_groups_23456;
    size_t testzisuff_intra_par_7;
    size_t testzisuff_outer_par_0;
    size_t testzisuff_outer_par_6;
    size_t testzisuff_outer_redomap_5;
} ;
struct futhark_context_config {
    struct opencl_config opencl;
    size_t sizes[48];
    int num_build_opts;
    const char **build_opts;
} ;
struct futhark_context_config *futhark_context_config_new(void)
{
    struct futhark_context_config *cfg =
                                  (struct futhark_context_config *) malloc(sizeof(struct futhark_context_config));
    
    if (cfg == NULL)
        return NULL;
    cfg->num_build_opts = 0;
    cfg->build_opts = (const char **) malloc(sizeof(const char *));
    cfg->build_opts[0] = NULL;
    cfg->sizes[0] = 0;
    cfg->sizes[1] = 0;
    cfg->sizes[2] = 0;
    cfg->sizes[3] = 0;
    cfg->sizes[4] = 0;
    cfg->sizes[5] = 0;
    cfg->sizes[6] = 0;
    cfg->sizes[7] = 0;
    cfg->sizes[8] = 0;
    cfg->sizes[9] = 0;
    cfg->sizes[10] = 0;
    cfg->sizes[11] = 0;
    cfg->sizes[12] = 0;
    cfg->sizes[13] = 0;
    cfg->sizes[14] = 0;
    cfg->sizes[15] = 0;
    cfg->sizes[16] = 0;
    cfg->sizes[17] = 0;
    cfg->sizes[18] = 0;
    cfg->sizes[19] = 0;
    cfg->sizes[20] = 32;
    cfg->sizes[21] = 0;
    cfg->sizes[22] = 0;
    cfg->sizes[23] = 0;
    cfg->sizes[24] = 0;
    cfg->sizes[25] = 0;
    cfg->sizes[26] = 0;
    cfg->sizes[27] = 0;
    cfg->sizes[28] = 0;
    cfg->sizes[29] = 0;
    cfg->sizes[30] = 0;
    cfg->sizes[31] = 0;
    cfg->sizes[32] = 0;
    cfg->sizes[33] = 0;
    cfg->sizes[34] = 0;
    cfg->sizes[35] = 0;
    cfg->sizes[36] = 0;
    cfg->sizes[37] = 0;
    cfg->sizes[38] = 0;
    cfg->sizes[39] = 0;
    cfg->sizes[40] = 0;
    cfg->sizes[41] = 0;
    cfg->sizes[42] = 0;
    cfg->sizes[43] = 0;
    cfg->sizes[44] = 32;
    cfg->sizes[45] = 0;
    cfg->sizes[46] = 0;
    cfg->sizes[47] = 0;
    opencl_config_init(&cfg->opencl, 48, size_names, size_vars, cfg->sizes,
                       size_classes);
    return cfg;
}
void futhark_context_config_free(struct futhark_context_config *cfg)
{
    free(cfg->build_opts);
    free(cfg);
}
void futhark_context_config_add_build_option(struct futhark_context_config *cfg,
                                             const char *opt)
{
    cfg->build_opts[cfg->num_build_opts] = opt;
    cfg->num_build_opts++;
    cfg->build_opts = (const char **) realloc(cfg->build_opts,
                                              (cfg->num_build_opts + 1) *
                                              sizeof(const char *));
    cfg->build_opts[cfg->num_build_opts] = NULL;
}
void futhark_context_config_set_debugging(struct futhark_context_config *cfg,
                                          int flag)
{
    cfg->opencl.profiling = cfg->opencl.logging = cfg->opencl.debugging = flag;
}
void futhark_context_config_set_profiling(struct futhark_context_config *cfg,
                                          int flag)
{
    cfg->opencl.profiling = flag;
}
void futhark_context_config_set_logging(struct futhark_context_config *cfg,
                                        int flag)
{
    cfg->opencl.logging = flag;
}
void futhark_context_config_set_device(struct futhark_context_config *cfg, const
                                       char *s)
{
    set_preferred_device(&cfg->opencl, s);
}
void futhark_context_config_set_platform(struct futhark_context_config *cfg,
                                         const char *s)
{
    set_preferred_platform(&cfg->opencl, s);
}
void futhark_context_config_select_device_interactively(struct futhark_context_config *cfg)
{
    select_device_interactively(&cfg->opencl);
}
void futhark_context_config_list_devices(struct futhark_context_config *cfg)
{
    list_devices(&cfg->opencl);
}
void futhark_context_config_dump_program_to(struct futhark_context_config *cfg,
                                            const char *path)
{
    cfg->opencl.dump_program_to = path;
}
void futhark_context_config_load_program_from(struct futhark_context_config *cfg,
                                              const char *path)
{
    cfg->opencl.load_program_from = path;
}
void futhark_context_config_dump_binary_to(struct futhark_context_config *cfg,
                                           const char *path)
{
    cfg->opencl.dump_binary_to = path;
}
void futhark_context_config_load_binary_from(struct futhark_context_config *cfg,
                                             const char *path)
{
    cfg->opencl.load_binary_from = path;
}
void futhark_context_config_set_default_group_size(struct futhark_context_config *cfg,
                                                   int size)
{
    cfg->opencl.default_group_size = size;
    cfg->opencl.default_group_size_changed = 1;
}
void futhark_context_config_set_default_num_groups(struct futhark_context_config *cfg,
                                                   int num)
{
    cfg->opencl.default_num_groups = num;
}
void futhark_context_config_set_default_tile_size(struct futhark_context_config *cfg,
                                                  int size)
{
    cfg->opencl.default_tile_size = size;
    cfg->opencl.default_tile_size_changed = 1;
}
void futhark_context_config_set_default_threshold(struct futhark_context_config *cfg,
                                                  int size)
{
    cfg->opencl.default_threshold = size;
}
int futhark_context_config_set_size(struct futhark_context_config *cfg, const
                                    char *size_name, size_t size_value)
{
    for (int i = 0; i < 48; i++) {
        if (strcmp(size_name, size_names[i]) == 0) {
            cfg->sizes[i] = size_value;
            return 0;
        }
    }
    if (strcmp(size_name, "default_group_size") == 0) {
        cfg->opencl.default_group_size = size_value;
        return 0;
    }
    if (strcmp(size_name, "default_num_groups") == 0) {
        cfg->opencl.default_num_groups = size_value;
        return 0;
    }
    if (strcmp(size_name, "default_threshold") == 0) {
        cfg->opencl.default_threshold = size_value;
        return 0;
    }
    if (strcmp(size_name, "default_tile_size") == 0) {
        cfg->opencl.default_tile_size = size_value;
        return 0;
    }
    return 1;
}
struct futhark_context {
    int detail_memory;
    int debugging;
    int profiling;
    int profiling_paused;
    int logging;
    lock_t lock;
    char *error;
    int64_t peak_mem_usage_device;
    int64_t cur_mem_usage_device;
    int64_t peak_mem_usage_default;
    int64_t cur_mem_usage_default;
    struct {
        int dummy;
    } constants;
    struct memblock_device mainzicounter_mem_23493;
    struct memblock_device mainzicounter_mem_23523;
    struct memblock_device mainzicounter_mem_23560;
    struct memblock_device mainzicounter_mem_23623;
    struct memblock_device mainzicounter_mem_23706;
    struct memblock_device mainzicounter_mem_23747;
    struct memblock_device testzistatic_array_23490;
    struct memblock_device testzistatic_array_23491;
    struct memblock_device testzistatic_array_23492;
    struct memblock_device testzicounter_mem_23494;
    struct memblock_device testzicounter_mem_23524;
    struct memblock_device testzicounter_mem_23561;
    struct memblock_device testzicounter_mem_23624;
    struct memblock_device testzicounter_mem_23707;
    struct memblock_device testzicounter_mem_23748;
    int total_runs;
    long total_runtime;
    cl_kernel gpu_map_transpose_f32;
    cl_kernel gpu_map_transpose_f32_low_height;
    cl_kernel gpu_map_transpose_f32_low_width;
    cl_kernel gpu_map_transpose_f32_small;
    cl_kernel mainzisegmap_18861;
    cl_kernel mainzisegmap_19037;
    cl_kernel mainzisegmap_19370;
    cl_kernel mainzisegmap_19468;
    cl_kernel mainzisegmap_19532;
    cl_kernel mainzisegmap_19816;
    cl_kernel mainzisegmap_20238;
    cl_kernel mainzisegmap_intragroup_19814;
    cl_kernel mainzisegred_large_20273;
    cl_kernel mainzisegred_nonseg_18847;
    cl_kernel mainzisegred_nonseg_19659;
    cl_kernel mainzisegred_nonseg_20557;
    cl_kernel mainzisegred_nonseg_23356;
    cl_kernel mainzisegred_nonseg_23388;
    cl_kernel mainzisegred_small_20273;
    cl_kernel testzisegmap_21033;
    cl_kernel testzisegmap_21209;
    cl_kernel testzisegmap_21542;
    cl_kernel testzisegmap_21640;
    cl_kernel testzisegmap_21704;
    cl_kernel testzisegmap_21979;
    cl_kernel testzisegmap_22381;
    cl_kernel testzisegmap_intragroup_21977;
    cl_kernel testzisegred_large_22416;
    cl_kernel testzisegred_nonseg_21019;
    cl_kernel testzisegred_nonseg_21830;
    cl_kernel testzisegred_nonseg_22685;
    cl_kernel testzisegred_nonseg_23431;
    cl_kernel testzisegred_nonseg_23463;
    cl_kernel testzisegred_small_22416;
    int64_t copy_dev_to_dev_total_runtime;
    int copy_dev_to_dev_runs;
    int64_t copy_dev_to_host_total_runtime;
    int copy_dev_to_host_runs;
    int64_t copy_host_to_dev_total_runtime;
    int copy_host_to_dev_runs;
    int64_t copy_scalar_to_dev_total_runtime;
    int copy_scalar_to_dev_runs;
    int64_t copy_scalar_from_dev_total_runtime;
    int copy_scalar_from_dev_runs;
    int64_t gpu_map_transpose_f32_total_runtime;
    int gpu_map_transpose_f32_runs;
    int64_t gpu_map_transpose_f32_low_height_total_runtime;
    int gpu_map_transpose_f32_low_height_runs;
    int64_t gpu_map_transpose_f32_low_width_total_runtime;
    int gpu_map_transpose_f32_low_width_runs;
    int64_t gpu_map_transpose_f32_small_total_runtime;
    int gpu_map_transpose_f32_small_runs;
    int64_t mainzisegmap_18861_total_runtime;
    int mainzisegmap_18861_runs;
    int64_t mainzisegmap_19037_total_runtime;
    int mainzisegmap_19037_runs;
    int64_t mainzisegmap_19370_total_runtime;
    int mainzisegmap_19370_runs;
    int64_t mainzisegmap_19468_total_runtime;
    int mainzisegmap_19468_runs;
    int64_t mainzisegmap_19532_total_runtime;
    int mainzisegmap_19532_runs;
    int64_t mainzisegmap_19816_total_runtime;
    int mainzisegmap_19816_runs;
    int64_t mainzisegmap_20238_total_runtime;
    int mainzisegmap_20238_runs;
    int64_t mainzisegmap_intragroup_19814_total_runtime;
    int mainzisegmap_intragroup_19814_runs;
    int64_t mainzisegred_large_20273_total_runtime;
    int mainzisegred_large_20273_runs;
    int64_t mainzisegred_nonseg_18847_total_runtime;
    int mainzisegred_nonseg_18847_runs;
    int64_t mainzisegred_nonseg_19659_total_runtime;
    int mainzisegred_nonseg_19659_runs;
    int64_t mainzisegred_nonseg_20557_total_runtime;
    int mainzisegred_nonseg_20557_runs;
    int64_t mainzisegred_nonseg_23356_total_runtime;
    int mainzisegred_nonseg_23356_runs;
    int64_t mainzisegred_nonseg_23388_total_runtime;
    int mainzisegred_nonseg_23388_runs;
    int64_t mainzisegred_small_20273_total_runtime;
    int mainzisegred_small_20273_runs;
    int64_t testzisegmap_21033_total_runtime;
    int testzisegmap_21033_runs;
    int64_t testzisegmap_21209_total_runtime;
    int testzisegmap_21209_runs;
    int64_t testzisegmap_21542_total_runtime;
    int testzisegmap_21542_runs;
    int64_t testzisegmap_21640_total_runtime;
    int testzisegmap_21640_runs;
    int64_t testzisegmap_21704_total_runtime;
    int testzisegmap_21704_runs;
    int64_t testzisegmap_21979_total_runtime;
    int testzisegmap_21979_runs;
    int64_t testzisegmap_22381_total_runtime;
    int testzisegmap_22381_runs;
    int64_t testzisegmap_intragroup_21977_total_runtime;
    int testzisegmap_intragroup_21977_runs;
    int64_t testzisegred_large_22416_total_runtime;
    int testzisegred_large_22416_runs;
    int64_t testzisegred_nonseg_21019_total_runtime;
    int testzisegred_nonseg_21019_runs;
    int64_t testzisegred_nonseg_21830_total_runtime;
    int testzisegred_nonseg_21830_runs;
    int64_t testzisegred_nonseg_22685_total_runtime;
    int testzisegred_nonseg_22685_runs;
    int64_t testzisegred_nonseg_23431_total_runtime;
    int testzisegred_nonseg_23431_runs;
    int64_t testzisegred_nonseg_23463_total_runtime;
    int testzisegred_nonseg_23463_runs;
    int64_t testzisegred_small_22416_total_runtime;
    int testzisegred_small_22416_runs;
    cl_mem global_failure;
    cl_mem global_failure_args;
    struct opencl_context opencl;
    struct sizes sizes;
    cl_int failure_is_an_option;
} ;
void post_opencl_setup(struct opencl_context *ctx,
                       struct opencl_device_option *option)
{
    if ((ctx->lockstep_width == 0 && strstr(option->platform_name,
                                            "NVIDIA CUDA") != NULL) &&
        (option->device_type & CL_DEVICE_TYPE_GPU) == CL_DEVICE_TYPE_GPU) {
        ctx->lockstep_width = 32;
    }
    if ((ctx->lockstep_width == 0 && strstr(option->platform_name,
                                            "AMD Accelerated Parallel Processing") !=
         NULL) && (option->device_type & CL_DEVICE_TYPE_GPU) ==
        CL_DEVICE_TYPE_GPU) {
        ctx->lockstep_width = 32;
    }
    if ((ctx->lockstep_width == 0 && strstr(option->platform_name, "") !=
         NULL) && (option->device_type & CL_DEVICE_TYPE_GPU) ==
        CL_DEVICE_TYPE_GPU) {
        ctx->lockstep_width = 1;
    }
    if ((ctx->cfg.default_num_groups == 0 && strstr(option->platform_name,
                                                    "") != NULL) &&
        (option->device_type & CL_DEVICE_TYPE_GPU) == CL_DEVICE_TYPE_GPU) {
        size_t MAX_COMPUTE_UNITS_val = 0;
        
        clGetDeviceInfo(ctx->device, CL_DEVICE_MAX_COMPUTE_UNITS,
                        sizeof(MAX_COMPUTE_UNITS_val), &MAX_COMPUTE_UNITS_val,
                        NULL);
        ctx->cfg.default_num_groups = 4 * MAX_COMPUTE_UNITS_val;
    }
    if ((ctx->cfg.default_group_size == 0 && strstr(option->platform_name,
                                                    "") != NULL) &&
        (option->device_type & CL_DEVICE_TYPE_GPU) == CL_DEVICE_TYPE_GPU) {
        ctx->cfg.default_group_size = 256;
    }
    if ((ctx->cfg.default_tile_size == 0 && strstr(option->platform_name, "") !=
         NULL) && (option->device_type & CL_DEVICE_TYPE_GPU) ==
        CL_DEVICE_TYPE_GPU) {
        ctx->cfg.default_tile_size = 32;
    }
    if ((ctx->cfg.default_threshold == 0 && strstr(option->platform_name, "") !=
         NULL) && (option->device_type & CL_DEVICE_TYPE_GPU) ==
        CL_DEVICE_TYPE_GPU) {
        ctx->cfg.default_threshold = 32768;
    }
    if ((ctx->lockstep_width == 0 && strstr(option->platform_name, "") !=
         NULL) && (option->device_type & CL_DEVICE_TYPE_CPU) ==
        CL_DEVICE_TYPE_CPU) {
        ctx->lockstep_width = 1;
    }
    if ((ctx->cfg.default_num_groups == 0 && strstr(option->platform_name,
                                                    "") != NULL) &&
        (option->device_type & CL_DEVICE_TYPE_CPU) == CL_DEVICE_TYPE_CPU) {
        size_t MAX_COMPUTE_UNITS_val = 0;
        
        clGetDeviceInfo(ctx->device, CL_DEVICE_MAX_COMPUTE_UNITS,
                        sizeof(MAX_COMPUTE_UNITS_val), &MAX_COMPUTE_UNITS_val,
                        NULL);
        ctx->cfg.default_num_groups = MAX_COMPUTE_UNITS_val;
    }
    if ((ctx->cfg.default_group_size == 0 && strstr(option->platform_name,
                                                    "") != NULL) &&
        (option->device_type & CL_DEVICE_TYPE_CPU) == CL_DEVICE_TYPE_CPU) {
        ctx->cfg.default_group_size = 32;
    }
    if ((ctx->cfg.default_tile_size == 0 && strstr(option->platform_name, "") !=
         NULL) && (option->device_type & CL_DEVICE_TYPE_CPU) ==
        CL_DEVICE_TYPE_CPU) {
        ctx->cfg.default_tile_size = 4;
    }
    if ((ctx->cfg.default_threshold == 0 && strstr(option->platform_name, "") !=
         NULL) && (option->device_type & CL_DEVICE_TYPE_CPU) ==
        CL_DEVICE_TYPE_CPU) {
        size_t MAX_COMPUTE_UNITS_val = 0;
        
        clGetDeviceInfo(ctx->device, CL_DEVICE_MAX_COMPUTE_UNITS,
                        sizeof(MAX_COMPUTE_UNITS_val), &MAX_COMPUTE_UNITS_val,
                        NULL);
        ctx->cfg.default_threshold = MAX_COMPUTE_UNITS_val;
    }
}
static void init_context_early(struct futhark_context_config *cfg,
                               struct futhark_context *ctx)
{
    ctx->opencl.cfg = cfg->opencl;
    ctx->detail_memory = cfg->opencl.debugging;
    ctx->debugging = cfg->opencl.debugging;
    ctx->profiling = cfg->opencl.profiling;
    ctx->profiling_paused = 0;
    ctx->logging = cfg->opencl.logging;
    ctx->error = NULL;
    ctx->opencl.profiling_records_capacity = 200;
    ctx->opencl.profiling_records_used = 0;
    ctx->opencl.profiling_records =
        malloc(ctx->opencl.profiling_records_capacity *
        sizeof(struct profiling_record));
    create_lock(&ctx->lock);
    ctx->failure_is_an_option = 0;
    ctx->peak_mem_usage_device = 0;
    ctx->cur_mem_usage_device = 0;
    ctx->peak_mem_usage_default = 0;
    ctx->cur_mem_usage_default = 0;
    ctx->total_runs = 0;
    ctx->total_runtime = 0;
    ctx->copy_dev_to_dev_total_runtime = 0;
    ctx->copy_dev_to_dev_runs = 0;
    ctx->copy_dev_to_host_total_runtime = 0;
    ctx->copy_dev_to_host_runs = 0;
    ctx->copy_host_to_dev_total_runtime = 0;
    ctx->copy_host_to_dev_runs = 0;
    ctx->copy_scalar_to_dev_total_runtime = 0;
    ctx->copy_scalar_to_dev_runs = 0;
    ctx->copy_scalar_from_dev_total_runtime = 0;
    ctx->copy_scalar_from_dev_runs = 0;
    ctx->gpu_map_transpose_f32_total_runtime = 0;
    ctx->gpu_map_transpose_f32_runs = 0;
    ctx->gpu_map_transpose_f32_low_height_total_runtime = 0;
    ctx->gpu_map_transpose_f32_low_height_runs = 0;
    ctx->gpu_map_transpose_f32_low_width_total_runtime = 0;
    ctx->gpu_map_transpose_f32_low_width_runs = 0;
    ctx->gpu_map_transpose_f32_small_total_runtime = 0;
    ctx->gpu_map_transpose_f32_small_runs = 0;
    ctx->mainzisegmap_18861_total_runtime = 0;
    ctx->mainzisegmap_18861_runs = 0;
    ctx->mainzisegmap_19037_total_runtime = 0;
    ctx->mainzisegmap_19037_runs = 0;
    ctx->mainzisegmap_19370_total_runtime = 0;
    ctx->mainzisegmap_19370_runs = 0;
    ctx->mainzisegmap_19468_total_runtime = 0;
    ctx->mainzisegmap_19468_runs = 0;
    ctx->mainzisegmap_19532_total_runtime = 0;
    ctx->mainzisegmap_19532_runs = 0;
    ctx->mainzisegmap_19816_total_runtime = 0;
    ctx->mainzisegmap_19816_runs = 0;
    ctx->mainzisegmap_20238_total_runtime = 0;
    ctx->mainzisegmap_20238_runs = 0;
    ctx->mainzisegmap_intragroup_19814_total_runtime = 0;
    ctx->mainzisegmap_intragroup_19814_runs = 0;
    ctx->mainzisegred_large_20273_total_runtime = 0;
    ctx->mainzisegred_large_20273_runs = 0;
    ctx->mainzisegred_nonseg_18847_total_runtime = 0;
    ctx->mainzisegred_nonseg_18847_runs = 0;
    ctx->mainzisegred_nonseg_19659_total_runtime = 0;
    ctx->mainzisegred_nonseg_19659_runs = 0;
    ctx->mainzisegred_nonseg_20557_total_runtime = 0;
    ctx->mainzisegred_nonseg_20557_runs = 0;
    ctx->mainzisegred_nonseg_23356_total_runtime = 0;
    ctx->mainzisegred_nonseg_23356_runs = 0;
    ctx->mainzisegred_nonseg_23388_total_runtime = 0;
    ctx->mainzisegred_nonseg_23388_runs = 0;
    ctx->mainzisegred_small_20273_total_runtime = 0;
    ctx->mainzisegred_small_20273_runs = 0;
    ctx->testzisegmap_21033_total_runtime = 0;
    ctx->testzisegmap_21033_runs = 0;
    ctx->testzisegmap_21209_total_runtime = 0;
    ctx->testzisegmap_21209_runs = 0;
    ctx->testzisegmap_21542_total_runtime = 0;
    ctx->testzisegmap_21542_runs = 0;
    ctx->testzisegmap_21640_total_runtime = 0;
    ctx->testzisegmap_21640_runs = 0;
    ctx->testzisegmap_21704_total_runtime = 0;
    ctx->testzisegmap_21704_runs = 0;
    ctx->testzisegmap_21979_total_runtime = 0;
    ctx->testzisegmap_21979_runs = 0;
    ctx->testzisegmap_22381_total_runtime = 0;
    ctx->testzisegmap_22381_runs = 0;
    ctx->testzisegmap_intragroup_21977_total_runtime = 0;
    ctx->testzisegmap_intragroup_21977_runs = 0;
    ctx->testzisegred_large_22416_total_runtime = 0;
    ctx->testzisegred_large_22416_runs = 0;
    ctx->testzisegred_nonseg_21019_total_runtime = 0;
    ctx->testzisegred_nonseg_21019_runs = 0;
    ctx->testzisegred_nonseg_21830_total_runtime = 0;
    ctx->testzisegred_nonseg_21830_runs = 0;
    ctx->testzisegred_nonseg_22685_total_runtime = 0;
    ctx->testzisegred_nonseg_22685_runs = 0;
    ctx->testzisegred_nonseg_23431_total_runtime = 0;
    ctx->testzisegred_nonseg_23431_runs = 0;
    ctx->testzisegred_nonseg_23463_total_runtime = 0;
    ctx->testzisegred_nonseg_23463_runs = 0;
    ctx->testzisegred_small_22416_total_runtime = 0;
    ctx->testzisegred_small_22416_runs = 0;
}
static int init_context_late(struct futhark_context_config *cfg,
                             struct futhark_context *ctx, cl_program prog)
{
    cl_int error;
    cl_int no_error = -1;
    
    ctx->global_failure = clCreateBuffer(ctx->opencl.ctx, CL_MEM_READ_WRITE |
                                         CL_MEM_COPY_HOST_PTR, sizeof(cl_int),
                                         &no_error, &error);
    OPENCL_SUCCEED_OR_RETURN(error);
    // The +1 is to avoid zero-byte allocations.
    ctx->global_failure_args = clCreateBuffer(ctx->opencl.ctx,
                                              CL_MEM_READ_WRITE,
                                              sizeof(int64_t) * (3 + 1), NULL,
                                              &error);
    OPENCL_SUCCEED_OR_RETURN(error);
    {
        ctx->gpu_map_transpose_f32 = clCreateKernel(prog,
                                                    "gpu_map_transpose_f32",
                                                    &error);
        OPENCL_SUCCEED_FATAL(error);
        if (ctx->debugging)
            fprintf(stderr, "Created kernel %s.\n", "gpu_map_transpose_f32");
    }
    {
        ctx->gpu_map_transpose_f32_low_height = clCreateKernel(prog,
                                                               "gpu_map_transpose_f32_low_height",
                                                               &error);
        OPENCL_SUCCEED_FATAL(error);
        if (ctx->debugging)
            fprintf(stderr, "Created kernel %s.\n",
                    "gpu_map_transpose_f32_low_height");
    }
    {
        ctx->gpu_map_transpose_f32_low_width = clCreateKernel(prog,
                                                              "gpu_map_transpose_f32_low_width",
                                                              &error);
        OPENCL_SUCCEED_FATAL(error);
        if (ctx->debugging)
            fprintf(stderr, "Created kernel %s.\n",
                    "gpu_map_transpose_f32_low_width");
    }
    {
        ctx->gpu_map_transpose_f32_small = clCreateKernel(prog,
                                                          "gpu_map_transpose_f32_small",
                                                          &error);
        OPENCL_SUCCEED_FATAL(error);
        if (ctx->debugging)
            fprintf(stderr, "Created kernel %s.\n",
                    "gpu_map_transpose_f32_small");
    }
    {
        ctx->mainzisegmap_18861 = clCreateKernel(prog, "mainzisegmap_18861",
                                                 &error);
        OPENCL_SUCCEED_FATAL(error);
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->mainzisegmap_18861, 0,
                                            sizeof(cl_mem),
                                            &ctx->global_failure));
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->mainzisegmap_18861, 2,
                                            sizeof(cl_mem),
                                            &ctx->global_failure_args));
        if (ctx->debugging)
            fprintf(stderr, "Created kernel %s.\n", "main.segmap_18861");
    }
    {
        ctx->mainzisegmap_19037 = clCreateKernel(prog, "mainzisegmap_19037",
                                                 &error);
        OPENCL_SUCCEED_FATAL(error);
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->mainzisegmap_19037, 0,
                                            sizeof(cl_mem),
                                            &ctx->global_failure));
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->mainzisegmap_19037, 2,
                                            sizeof(cl_mem),
                                            &ctx->global_failure_args));
        if (ctx->debugging)
            fprintf(stderr, "Created kernel %s.\n", "main.segmap_19037");
    }
    {
        ctx->mainzisegmap_19370 = clCreateKernel(prog, "mainzisegmap_19370",
                                                 &error);
        OPENCL_SUCCEED_FATAL(error);
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->mainzisegmap_19370, 0,
                                            sizeof(cl_mem),
                                            &ctx->global_failure));
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->mainzisegmap_19370, 2,
                                            sizeof(cl_mem),
                                            &ctx->global_failure_args));
        if (ctx->debugging)
            fprintf(stderr, "Created kernel %s.\n", "main.segmap_19370");
    }
    {
        ctx->mainzisegmap_19468 = clCreateKernel(prog, "mainzisegmap_19468",
                                                 &error);
        OPENCL_SUCCEED_FATAL(error);
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->mainzisegmap_19468, 0,
                                            sizeof(cl_mem),
                                            &ctx->global_failure));
        if (ctx->debugging)
            fprintf(stderr, "Created kernel %s.\n", "main.segmap_19468");
    }
    {
        ctx->mainzisegmap_19532 = clCreateKernel(prog, "mainzisegmap_19532",
                                                 &error);
        OPENCL_SUCCEED_FATAL(error);
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->mainzisegmap_19532, 0,
                                            sizeof(cl_mem),
                                            &ctx->global_failure));
        if (ctx->debugging)
            fprintf(stderr, "Created kernel %s.\n", "main.segmap_19532");
    }
    {
        ctx->mainzisegmap_19816 = clCreateKernel(prog, "mainzisegmap_19816",
                                                 &error);
        OPENCL_SUCCEED_FATAL(error);
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->mainzisegmap_19816, 0,
                                            sizeof(cl_mem),
                                            &ctx->global_failure));
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->mainzisegmap_19816, 2,
                                            sizeof(cl_mem),
                                            &ctx->global_failure_args));
        if (ctx->debugging)
            fprintf(stderr, "Created kernel %s.\n", "main.segmap_19816");
    }
    {
        ctx->mainzisegmap_20238 = clCreateKernel(prog, "mainzisegmap_20238",
                                                 &error);
        OPENCL_SUCCEED_FATAL(error);
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->mainzisegmap_20238, 0,
                                            sizeof(cl_mem),
                                            &ctx->global_failure));
        if (ctx->debugging)
            fprintf(stderr, "Created kernel %s.\n", "main.segmap_20238");
    }
    {
        ctx->mainzisegmap_intragroup_19814 = clCreateKernel(prog,
                                                            "mainzisegmap_intragroup_19814",
                                                            &error);
        OPENCL_SUCCEED_FATAL(error);
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->mainzisegmap_intragroup_19814,
                                            0, sizeof(cl_mem),
                                            &ctx->global_failure));
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->mainzisegmap_intragroup_19814,
                                            2, sizeof(cl_mem),
                                            &ctx->global_failure_args));
        if (ctx->debugging)
            fprintf(stderr, "Created kernel %s.\n",
                    "main.segmap_intragroup_19814");
    }
    {
        ctx->mainzisegred_large_20273 = clCreateKernel(prog,
                                                       "mainzisegred_large_20273",
                                                       &error);
        OPENCL_SUCCEED_FATAL(error);
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->mainzisegred_large_20273, 0,
                                            sizeof(cl_mem),
                                            &ctx->global_failure));
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->mainzisegred_large_20273, 2,
                                            sizeof(cl_mem),
                                            &ctx->global_failure_args));
        if (ctx->debugging)
            fprintf(stderr, "Created kernel %s.\n", "main.segred_large_20273");
    }
    {
        ctx->mainzisegred_nonseg_18847 = clCreateKernel(prog,
                                                        "mainzisegred_nonseg_18847",
                                                        &error);
        OPENCL_SUCCEED_FATAL(error);
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->mainzisegred_nonseg_18847, 0,
                                            sizeof(cl_mem),
                                            &ctx->global_failure));
        if (ctx->debugging)
            fprintf(stderr, "Created kernel %s.\n", "main.segred_nonseg_18847");
    }
    {
        ctx->mainzisegred_nonseg_19659 = clCreateKernel(prog,
                                                        "mainzisegred_nonseg_19659",
                                                        &error);
        OPENCL_SUCCEED_FATAL(error);
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->mainzisegred_nonseg_19659, 0,
                                            sizeof(cl_mem),
                                            &ctx->global_failure));
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->mainzisegred_nonseg_19659, 2,
                                            sizeof(cl_mem),
                                            &ctx->global_failure_args));
        if (ctx->debugging)
            fprintf(stderr, "Created kernel %s.\n", "main.segred_nonseg_19659");
    }
    {
        ctx->mainzisegred_nonseg_20557 = clCreateKernel(prog,
                                                        "mainzisegred_nonseg_20557",
                                                        &error);
        OPENCL_SUCCEED_FATAL(error);
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->mainzisegred_nonseg_20557, 0,
                                            sizeof(cl_mem),
                                            &ctx->global_failure));
        if (ctx->debugging)
            fprintf(stderr, "Created kernel %s.\n", "main.segred_nonseg_20557");
    }
    {
        ctx->mainzisegred_nonseg_23356 = clCreateKernel(prog,
                                                        "mainzisegred_nonseg_23356",
                                                        &error);
        OPENCL_SUCCEED_FATAL(error);
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->mainzisegred_nonseg_23356, 0,
                                            sizeof(cl_mem),
                                            &ctx->global_failure));
        if (ctx->debugging)
            fprintf(stderr, "Created kernel %s.\n", "main.segred_nonseg_23356");
    }
    {
        ctx->mainzisegred_nonseg_23388 = clCreateKernel(prog,
                                                        "mainzisegred_nonseg_23388",
                                                        &error);
        OPENCL_SUCCEED_FATAL(error);
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->mainzisegred_nonseg_23388, 0,
                                            sizeof(cl_mem),
                                            &ctx->global_failure));
        if (ctx->debugging)
            fprintf(stderr, "Created kernel %s.\n", "main.segred_nonseg_23388");
    }
    {
        ctx->mainzisegred_small_20273 = clCreateKernel(prog,
                                                       "mainzisegred_small_20273",
                                                       &error);
        OPENCL_SUCCEED_FATAL(error);
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->mainzisegred_small_20273, 0,
                                            sizeof(cl_mem),
                                            &ctx->global_failure));
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->mainzisegred_small_20273, 2,
                                            sizeof(cl_mem),
                                            &ctx->global_failure_args));
        if (ctx->debugging)
            fprintf(stderr, "Created kernel %s.\n", "main.segred_small_20273");
    }
    {
        ctx->testzisegmap_21033 = clCreateKernel(prog, "testzisegmap_21033",
                                                 &error);
        OPENCL_SUCCEED_FATAL(error);
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->testzisegmap_21033, 0,
                                            sizeof(cl_mem),
                                            &ctx->global_failure));
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->testzisegmap_21033, 2,
                                            sizeof(cl_mem),
                                            &ctx->global_failure_args));
        if (ctx->debugging)
            fprintf(stderr, "Created kernel %s.\n", "test.segmap_21033");
    }
    {
        ctx->testzisegmap_21209 = clCreateKernel(prog, "testzisegmap_21209",
                                                 &error);
        OPENCL_SUCCEED_FATAL(error);
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->testzisegmap_21209, 0,
                                            sizeof(cl_mem),
                                            &ctx->global_failure));
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->testzisegmap_21209, 2,
                                            sizeof(cl_mem),
                                            &ctx->global_failure_args));
        if (ctx->debugging)
            fprintf(stderr, "Created kernel %s.\n", "test.segmap_21209");
    }
    {
        ctx->testzisegmap_21542 = clCreateKernel(prog, "testzisegmap_21542",
                                                 &error);
        OPENCL_SUCCEED_FATAL(error);
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->testzisegmap_21542, 0,
                                            sizeof(cl_mem),
                                            &ctx->global_failure));
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->testzisegmap_21542, 2,
                                            sizeof(cl_mem),
                                            &ctx->global_failure_args));
        if (ctx->debugging)
            fprintf(stderr, "Created kernel %s.\n", "test.segmap_21542");
    }
    {
        ctx->testzisegmap_21640 = clCreateKernel(prog, "testzisegmap_21640",
                                                 &error);
        OPENCL_SUCCEED_FATAL(error);
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->testzisegmap_21640, 0,
                                            sizeof(cl_mem),
                                            &ctx->global_failure));
        if (ctx->debugging)
            fprintf(stderr, "Created kernel %s.\n", "test.segmap_21640");
    }
    {
        ctx->testzisegmap_21704 = clCreateKernel(prog, "testzisegmap_21704",
                                                 &error);
        OPENCL_SUCCEED_FATAL(error);
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->testzisegmap_21704, 0,
                                            sizeof(cl_mem),
                                            &ctx->global_failure));
        if (ctx->debugging)
            fprintf(stderr, "Created kernel %s.\n", "test.segmap_21704");
    }
    {
        ctx->testzisegmap_21979 = clCreateKernel(prog, "testzisegmap_21979",
                                                 &error);
        OPENCL_SUCCEED_FATAL(error);
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->testzisegmap_21979, 0,
                                            sizeof(cl_mem),
                                            &ctx->global_failure));
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->testzisegmap_21979, 2,
                                            sizeof(cl_mem),
                                            &ctx->global_failure_args));
        if (ctx->debugging)
            fprintf(stderr, "Created kernel %s.\n", "test.segmap_21979");
    }
    {
        ctx->testzisegmap_22381 = clCreateKernel(prog, "testzisegmap_22381",
                                                 &error);
        OPENCL_SUCCEED_FATAL(error);
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->testzisegmap_22381, 0,
                                            sizeof(cl_mem),
                                            &ctx->global_failure));
        if (ctx->debugging)
            fprintf(stderr, "Created kernel %s.\n", "test.segmap_22381");
    }
    {
        ctx->testzisegmap_intragroup_21977 = clCreateKernel(prog,
                                                            "testzisegmap_intragroup_21977",
                                                            &error);
        OPENCL_SUCCEED_FATAL(error);
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->testzisegmap_intragroup_21977,
                                            0, sizeof(cl_mem),
                                            &ctx->global_failure));
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->testzisegmap_intragroup_21977,
                                            2, sizeof(cl_mem),
                                            &ctx->global_failure_args));
        if (ctx->debugging)
            fprintf(stderr, "Created kernel %s.\n",
                    "test.segmap_intragroup_21977");
    }
    {
        ctx->testzisegred_large_22416 = clCreateKernel(prog,
                                                       "testzisegred_large_22416",
                                                       &error);
        OPENCL_SUCCEED_FATAL(error);
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->testzisegred_large_22416, 0,
                                            sizeof(cl_mem),
                                            &ctx->global_failure));
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->testzisegred_large_22416, 2,
                                            sizeof(cl_mem),
                                            &ctx->global_failure_args));
        if (ctx->debugging)
            fprintf(stderr, "Created kernel %s.\n", "test.segred_large_22416");
    }
    {
        ctx->testzisegred_nonseg_21019 = clCreateKernel(prog,
                                                        "testzisegred_nonseg_21019",
                                                        &error);
        OPENCL_SUCCEED_FATAL(error);
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->testzisegred_nonseg_21019, 0,
                                            sizeof(cl_mem),
                                            &ctx->global_failure));
        if (ctx->debugging)
            fprintf(stderr, "Created kernel %s.\n", "test.segred_nonseg_21019");
    }
    {
        ctx->testzisegred_nonseg_21830 = clCreateKernel(prog,
                                                        "testzisegred_nonseg_21830",
                                                        &error);
        OPENCL_SUCCEED_FATAL(error);
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->testzisegred_nonseg_21830, 0,
                                            sizeof(cl_mem),
                                            &ctx->global_failure));
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->testzisegred_nonseg_21830, 2,
                                            sizeof(cl_mem),
                                            &ctx->global_failure_args));
        if (ctx->debugging)
            fprintf(stderr, "Created kernel %s.\n", "test.segred_nonseg_21830");
    }
    {
        ctx->testzisegred_nonseg_22685 = clCreateKernel(prog,
                                                        "testzisegred_nonseg_22685",
                                                        &error);
        OPENCL_SUCCEED_FATAL(error);
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->testzisegred_nonseg_22685, 0,
                                            sizeof(cl_mem),
                                            &ctx->global_failure));
        if (ctx->debugging)
            fprintf(stderr, "Created kernel %s.\n", "test.segred_nonseg_22685");
    }
    {
        ctx->testzisegred_nonseg_23431 = clCreateKernel(prog,
                                                        "testzisegred_nonseg_23431",
                                                        &error);
        OPENCL_SUCCEED_FATAL(error);
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->testzisegred_nonseg_23431, 0,
                                            sizeof(cl_mem),
                                            &ctx->global_failure));
        if (ctx->debugging)
            fprintf(stderr, "Created kernel %s.\n", "test.segred_nonseg_23431");
    }
    {
        ctx->testzisegred_nonseg_23463 = clCreateKernel(prog,
                                                        "testzisegred_nonseg_23463",
                                                        &error);
        OPENCL_SUCCEED_FATAL(error);
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->testzisegred_nonseg_23463, 0,
                                            sizeof(cl_mem),
                                            &ctx->global_failure));
        if (ctx->debugging)
            fprintf(stderr, "Created kernel %s.\n", "test.segred_nonseg_23463");
    }
    {
        ctx->testzisegred_small_22416 = clCreateKernel(prog,
                                                       "testzisegred_small_22416",
                                                       &error);
        OPENCL_SUCCEED_FATAL(error);
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->testzisegred_small_22416, 0,
                                            sizeof(cl_mem),
                                            &ctx->global_failure));
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->testzisegred_small_22416, 2,
                                            sizeof(cl_mem),
                                            &ctx->global_failure_args));
        if (ctx->debugging)
            fprintf(stderr, "Created kernel %s.\n", "test.segred_small_22416");
    }
    {
        cl_int success;
        
        ctx->mainzicounter_mem_23493.references = NULL;
        ctx->mainzicounter_mem_23493.size = 0;
        ctx->mainzicounter_mem_23493.mem = clCreateBuffer(ctx->opencl.ctx,
                                                          CL_MEM_READ_WRITE,
                                                          (10 > 0 ? 10 : 1) *
                                                          sizeof(int32_t), NULL,
                                                          &success);
        OPENCL_SUCCEED_OR_RETURN(success);
        if (10 > 0)
            OPENCL_SUCCEED_OR_RETURN(clEnqueueWriteBuffer(ctx->opencl.queue,
                                                          ctx->mainzicounter_mem_23493.mem,
                                                          CL_TRUE, 0, 10 *
                                                          sizeof(int32_t),
                                                          mainzicounter_mem_realtype_23802,
                                                          0, NULL, NULL));
    }
    {
        cl_int success;
        
        ctx->mainzicounter_mem_23523.references = NULL;
        ctx->mainzicounter_mem_23523.size = 0;
        ctx->mainzicounter_mem_23523.mem = clCreateBuffer(ctx->opencl.ctx,
                                                          CL_MEM_READ_WRITE,
                                                          (10 > 0 ? 10 : 1) *
                                                          sizeof(int32_t), NULL,
                                                          &success);
        OPENCL_SUCCEED_OR_RETURN(success);
        if (10 > 0)
            OPENCL_SUCCEED_OR_RETURN(clEnqueueWriteBuffer(ctx->opencl.queue,
                                                          ctx->mainzicounter_mem_23523.mem,
                                                          CL_TRUE, 0, 10 *
                                                          sizeof(int32_t),
                                                          mainzicounter_mem_realtype_23809,
                                                          0, NULL, NULL));
    }
    {
        cl_int success;
        
        ctx->mainzicounter_mem_23560.references = NULL;
        ctx->mainzicounter_mem_23560.size = 0;
        ctx->mainzicounter_mem_23560.mem = clCreateBuffer(ctx->opencl.ctx,
                                                          CL_MEM_READ_WRITE,
                                                          (10 > 0 ? 10 : 1) *
                                                          sizeof(int32_t), NULL,
                                                          &success);
        OPENCL_SUCCEED_OR_RETURN(success);
        if (10 > 0)
            OPENCL_SUCCEED_OR_RETURN(clEnqueueWriteBuffer(ctx->opencl.queue,
                                                          ctx->mainzicounter_mem_23560.mem,
                                                          CL_TRUE, 0, 10 *
                                                          sizeof(int32_t),
                                                          mainzicounter_mem_realtype_23821,
                                                          0, NULL, NULL));
    }
    {
        cl_int success;
        
        ctx->mainzicounter_mem_23623.references = NULL;
        ctx->mainzicounter_mem_23623.size = 0;
        ctx->mainzicounter_mem_23623.mem = clCreateBuffer(ctx->opencl.ctx,
                                                          CL_MEM_READ_WRITE,
                                                          (10 > 0 ? 10 : 1) *
                                                          sizeof(int32_t), NULL,
                                                          &success);
        OPENCL_SUCCEED_OR_RETURN(success);
        if (10 > 0)
            OPENCL_SUCCEED_OR_RETURN(clEnqueueWriteBuffer(ctx->opencl.queue,
                                                          ctx->mainzicounter_mem_23623.mem,
                                                          CL_TRUE, 0, 10 *
                                                          sizeof(int32_t),
                                                          mainzicounter_mem_realtype_23848,
                                                          0, NULL, NULL));
    }
    {
        cl_int success;
        
        ctx->mainzicounter_mem_23706.references = NULL;
        ctx->mainzicounter_mem_23706.size = 0;
        ctx->mainzicounter_mem_23706.mem = clCreateBuffer(ctx->opencl.ctx,
                                                          CL_MEM_READ_WRITE,
                                                          (10240 >
                                                           0 ? 10240 : 1) *
                                                          sizeof(int32_t), NULL,
                                                          &success);
        OPENCL_SUCCEED_OR_RETURN(success);
        if (10240 > 0)
            OPENCL_SUCCEED_OR_RETURN(clEnqueueWriteBuffer(ctx->opencl.queue,
                                                          ctx->mainzicounter_mem_23706.mem,
                                                          CL_TRUE, 0, 10240 *
                                                          sizeof(int32_t),
                                                          mainzicounter_mem_realtype_23870,
                                                          0, NULL, NULL));
    }
    {
        cl_int success;
        
        ctx->mainzicounter_mem_23747.references = NULL;
        ctx->mainzicounter_mem_23747.size = 0;
        ctx->mainzicounter_mem_23747.mem = clCreateBuffer(ctx->opencl.ctx,
                                                          CL_MEM_READ_WRITE,
                                                          (10 > 0 ? 10 : 1) *
                                                          sizeof(int32_t), NULL,
                                                          &success);
        OPENCL_SUCCEED_OR_RETURN(success);
        if (10 > 0)
            OPENCL_SUCCEED_OR_RETURN(clEnqueueWriteBuffer(ctx->opencl.queue,
                                                          ctx->mainzicounter_mem_23747.mem,
                                                          CL_TRUE, 0, 10 *
                                                          sizeof(int32_t),
                                                          mainzicounter_mem_realtype_23881,
                                                          0, NULL, NULL));
    }
    {
        cl_int success;
        
        ctx->testzistatic_array_23490.references = NULL;
        ctx->testzistatic_array_23490.size = 0;
        ctx->testzistatic_array_23490.mem = clCreateBuffer(ctx->opencl.ctx,
                                                           CL_MEM_READ_WRITE,
                                                           (9 > 0 ? 9 : 1) *
                                                           sizeof(float), NULL,
                                                           &success);
        OPENCL_SUCCEED_OR_RETURN(success);
        if (9 > 0)
            OPENCL_SUCCEED_OR_RETURN(clEnqueueWriteBuffer(ctx->opencl.queue,
                                                          ctx->testzistatic_array_23490.mem,
                                                          CL_TRUE, 0, 9 *
                                                          sizeof(float),
                                                          testzistatic_array_realtype_23889,
                                                          0, NULL, NULL));
    }
    {
        cl_int success;
        
        ctx->testzistatic_array_23491.references = NULL;
        ctx->testzistatic_array_23491.size = 0;
        ctx->testzistatic_array_23491.mem = clCreateBuffer(ctx->opencl.ctx,
                                                           CL_MEM_READ_WRITE,
                                                           (9 > 0 ? 9 : 1) *
                                                           sizeof(int64_t),
                                                           NULL, &success);
        OPENCL_SUCCEED_OR_RETURN(success);
        if (9 > 0)
            OPENCL_SUCCEED_OR_RETURN(clEnqueueWriteBuffer(ctx->opencl.queue,
                                                          ctx->testzistatic_array_23491.mem,
                                                          CL_TRUE, 0, 9 *
                                                          sizeof(int64_t),
                                                          testzistatic_array_realtype_23890,
                                                          0, NULL, NULL));
    }
    {
        cl_int success;
        
        ctx->testzistatic_array_23492.references = NULL;
        ctx->testzistatic_array_23492.size = 0;
        ctx->testzistatic_array_23492.mem = clCreateBuffer(ctx->opencl.ctx,
                                                           CL_MEM_READ_WRITE,
                                                           (9 > 0 ? 9 : 1) *
                                                           sizeof(float), NULL,
                                                           &success);
        OPENCL_SUCCEED_OR_RETURN(success);
        if (9 > 0)
            OPENCL_SUCCEED_OR_RETURN(clEnqueueWriteBuffer(ctx->opencl.queue,
                                                          ctx->testzistatic_array_23492.mem,
                                                          CL_TRUE, 0, 9 *
                                                          sizeof(float),
                                                          testzistatic_array_realtype_23891,
                                                          0, NULL, NULL));
    }
    {
        cl_int success;
        
        ctx->testzicounter_mem_23494.references = NULL;
        ctx->testzicounter_mem_23494.size = 0;
        ctx->testzicounter_mem_23494.mem = clCreateBuffer(ctx->opencl.ctx,
                                                          CL_MEM_READ_WRITE,
                                                          (10 > 0 ? 10 : 1) *
                                                          sizeof(int32_t), NULL,
                                                          &success);
        OPENCL_SUCCEED_OR_RETURN(success);
        if (10 > 0)
            OPENCL_SUCCEED_OR_RETURN(clEnqueueWriteBuffer(ctx->opencl.queue,
                                                          ctx->testzicounter_mem_23494.mem,
                                                          CL_TRUE, 0, 10 *
                                                          sizeof(int32_t),
                                                          testzicounter_mem_realtype_23892,
                                                          0, NULL, NULL));
    }
    {
        cl_int success;
        
        ctx->testzicounter_mem_23524.references = NULL;
        ctx->testzicounter_mem_23524.size = 0;
        ctx->testzicounter_mem_23524.mem = clCreateBuffer(ctx->opencl.ctx,
                                                          CL_MEM_READ_WRITE,
                                                          (10 > 0 ? 10 : 1) *
                                                          sizeof(int32_t), NULL,
                                                          &success);
        OPENCL_SUCCEED_OR_RETURN(success);
        if (10 > 0)
            OPENCL_SUCCEED_OR_RETURN(clEnqueueWriteBuffer(ctx->opencl.queue,
                                                          ctx->testzicounter_mem_23524.mem,
                                                          CL_TRUE, 0, 10 *
                                                          sizeof(int32_t),
                                                          testzicounter_mem_realtype_23899,
                                                          0, NULL, NULL));
    }
    {
        cl_int success;
        
        ctx->testzicounter_mem_23561.references = NULL;
        ctx->testzicounter_mem_23561.size = 0;
        ctx->testzicounter_mem_23561.mem = clCreateBuffer(ctx->opencl.ctx,
                                                          CL_MEM_READ_WRITE,
                                                          (10 > 0 ? 10 : 1) *
                                                          sizeof(int32_t), NULL,
                                                          &success);
        OPENCL_SUCCEED_OR_RETURN(success);
        if (10 > 0)
            OPENCL_SUCCEED_OR_RETURN(clEnqueueWriteBuffer(ctx->opencl.queue,
                                                          ctx->testzicounter_mem_23561.mem,
                                                          CL_TRUE, 0, 10 *
                                                          sizeof(int32_t),
                                                          testzicounter_mem_realtype_23911,
                                                          0, NULL, NULL));
    }
    {
        cl_int success;
        
        ctx->testzicounter_mem_23624.references = NULL;
        ctx->testzicounter_mem_23624.size = 0;
        ctx->testzicounter_mem_23624.mem = clCreateBuffer(ctx->opencl.ctx,
                                                          CL_MEM_READ_WRITE,
                                                          (10 > 0 ? 10 : 1) *
                                                          sizeof(int32_t), NULL,
                                                          &success);
        OPENCL_SUCCEED_OR_RETURN(success);
        if (10 > 0)
            OPENCL_SUCCEED_OR_RETURN(clEnqueueWriteBuffer(ctx->opencl.queue,
                                                          ctx->testzicounter_mem_23624.mem,
                                                          CL_TRUE, 0, 10 *
                                                          sizeof(int32_t),
                                                          testzicounter_mem_realtype_23938,
                                                          0, NULL, NULL));
    }
    {
        cl_int success;
        
        ctx->testzicounter_mem_23707.references = NULL;
        ctx->testzicounter_mem_23707.size = 0;
        ctx->testzicounter_mem_23707.mem = clCreateBuffer(ctx->opencl.ctx,
                                                          CL_MEM_READ_WRITE,
                                                          (10240 >
                                                           0 ? 10240 : 1) *
                                                          sizeof(int32_t), NULL,
                                                          &success);
        OPENCL_SUCCEED_OR_RETURN(success);
        if (10240 > 0)
            OPENCL_SUCCEED_OR_RETURN(clEnqueueWriteBuffer(ctx->opencl.queue,
                                                          ctx->testzicounter_mem_23707.mem,
                                                          CL_TRUE, 0, 10240 *
                                                          sizeof(int32_t),
                                                          testzicounter_mem_realtype_23960,
                                                          0, NULL, NULL));
    }
    {
        cl_int success;
        
        ctx->testzicounter_mem_23748.references = NULL;
        ctx->testzicounter_mem_23748.size = 0;
        ctx->testzicounter_mem_23748.mem = clCreateBuffer(ctx->opencl.ctx,
                                                          CL_MEM_READ_WRITE,
                                                          (10 > 0 ? 10 : 1) *
                                                          sizeof(int32_t), NULL,
                                                          &success);
        OPENCL_SUCCEED_OR_RETURN(success);
        if (10 > 0)
            OPENCL_SUCCEED_OR_RETURN(clEnqueueWriteBuffer(ctx->opencl.queue,
                                                          ctx->testzicounter_mem_23748.mem,
                                                          CL_TRUE, 0, 10 *
                                                          sizeof(int32_t),
                                                          testzicounter_mem_realtype_23971,
                                                          0, NULL, NULL));
    }
    ctx->sizes.mainzisegmap_group_sizze_18863 = cfg->sizes[0];
    ctx->sizes.mainzisegmap_group_sizze_19039 = cfg->sizes[1];
    ctx->sizes.mainzisegmap_group_sizze_19372 = cfg->sizes[2];
    ctx->sizes.mainzisegmap_group_sizze_19471 = cfg->sizes[3];
    ctx->sizes.mainzisegmap_group_sizze_19534 = cfg->sizes[4];
    ctx->sizes.mainzisegmap_group_sizze_19818 = cfg->sizes[5];
    ctx->sizes.mainzisegmap_group_sizze_20240 = cfg->sizes[6];
    ctx->sizes.mainzisegmap_num_groups_19374 = cfg->sizes[7];
    ctx->sizes.mainzisegred_group_sizze_18839 = cfg->sizes[8];
    ctx->sizes.mainzisegred_group_sizze_19650 = cfg->sizes[9];
    ctx->sizes.mainzisegred_group_sizze_20267 = cfg->sizes[10];
    ctx->sizes.mainzisegred_group_sizze_20549 = cfg->sizes[11];
    ctx->sizes.mainzisegred_group_sizze_23351 = cfg->sizes[12];
    ctx->sizes.mainzisegred_group_sizze_23383 = cfg->sizes[13];
    ctx->sizes.mainzisegred_num_groups_18841 = cfg->sizes[14];
    ctx->sizes.mainzisegred_num_groups_19652 = cfg->sizes[15];
    ctx->sizes.mainzisegred_num_groups_20269 = cfg->sizes[16];
    ctx->sizes.mainzisegred_num_groups_20551 = cfg->sizes[17];
    ctx->sizes.mainzisegred_num_groups_23349 = cfg->sizes[18];
    ctx->sizes.mainzisegred_num_groups_23381 = cfg->sizes[19];
    ctx->sizes.mainzisuff_intra_par_7 = cfg->sizes[20];
    ctx->sizes.mainzisuff_outer_par_0 = cfg->sizes[21];
    ctx->sizes.mainzisuff_outer_par_6 = cfg->sizes[22];
    ctx->sizes.mainzisuff_outer_redomap_5 = cfg->sizes[23];
    ctx->sizes.testzisegmap_group_sizze_21035 = cfg->sizes[24];
    ctx->sizes.testzisegmap_group_sizze_21211 = cfg->sizes[25];
    ctx->sizes.testzisegmap_group_sizze_21544 = cfg->sizes[26];
    ctx->sizes.testzisegmap_group_sizze_21643 = cfg->sizes[27];
    ctx->sizes.testzisegmap_group_sizze_21706 = cfg->sizes[28];
    ctx->sizes.testzisegmap_group_sizze_21981 = cfg->sizes[29];
    ctx->sizes.testzisegmap_group_sizze_22383 = cfg->sizes[30];
    ctx->sizes.testzisegmap_num_groups_21546 = cfg->sizes[31];
    ctx->sizes.testzisegred_group_sizze_21011 = cfg->sizes[32];
    ctx->sizes.testzisegred_group_sizze_21822 = cfg->sizes[33];
    ctx->sizes.testzisegred_group_sizze_22410 = cfg->sizes[34];
    ctx->sizes.testzisegred_group_sizze_22677 = cfg->sizes[35];
    ctx->sizes.testzisegred_group_sizze_23426 = cfg->sizes[36];
    ctx->sizes.testzisegred_group_sizze_23458 = cfg->sizes[37];
    ctx->sizes.testzisegred_num_groups_21013 = cfg->sizes[38];
    ctx->sizes.testzisegred_num_groups_21824 = cfg->sizes[39];
    ctx->sizes.testzisegred_num_groups_22412 = cfg->sizes[40];
    ctx->sizes.testzisegred_num_groups_22679 = cfg->sizes[41];
    ctx->sizes.testzisegred_num_groups_23424 = cfg->sizes[42];
    ctx->sizes.testzisegred_num_groups_23456 = cfg->sizes[43];
    ctx->sizes.testzisuff_intra_par_7 = cfg->sizes[44];
    ctx->sizes.testzisuff_outer_par_0 = cfg->sizes[45];
    ctx->sizes.testzisuff_outer_par_6 = cfg->sizes[46];
    ctx->sizes.testzisuff_outer_redomap_5 = cfg->sizes[47];
    init_constants(ctx);
    // Clear the free list of any deallocations that occurred while initialising constants.
    OPENCL_SUCCEED_OR_RETURN(opencl_free_all(&ctx->opencl));
    // The program will be properly freed after all the kernels have also been freed.
    OPENCL_SUCCEED_OR_RETURN(clReleaseProgram(prog));
    return futhark_context_sync(ctx);
}
struct futhark_context *futhark_context_new(struct futhark_context_config *cfg)
{
    struct futhark_context *ctx =
                           (struct futhark_context *) malloc(sizeof(struct futhark_context));
    
    if (ctx == NULL)
        return NULL;
    
    int required_types = 0;
    
    init_context_early(cfg, ctx);
    
    cl_program prog = setup_opencl(&ctx->opencl, opencl_program, required_types,
                                   cfg->build_opts);
    
    init_context_late(cfg, ctx, prog);
    return ctx;
}
struct futhark_context *futhark_context_new_with_command_queue(struct futhark_context_config *cfg,
                                                               cl_command_queue queue)
{
    struct futhark_context *ctx =
                           (struct futhark_context *) malloc(sizeof(struct futhark_context));
    
    if (ctx == NULL)
        return NULL;
    
    int required_types = 0;
    
    init_context_early(cfg, ctx);
    
    cl_program prog = setup_opencl_with_command_queue(&ctx->opencl, queue,
                                                      opencl_program,
                                                      required_types,
                                                      cfg->build_opts);
    
    init_context_late(cfg, ctx, prog);
    return ctx;
}
void futhark_context_free(struct futhark_context *ctx)
{
    free_constants(ctx);
    free_lock(&ctx->lock);
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->gpu_map_transpose_f32));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->gpu_map_transpose_f32_low_height));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->gpu_map_transpose_f32_low_width));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->gpu_map_transpose_f32_small));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->mainzisegmap_18861));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->mainzisegmap_19037));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->mainzisegmap_19370));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->mainzisegmap_19468));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->mainzisegmap_19532));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->mainzisegmap_19816));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->mainzisegmap_20238));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->mainzisegmap_intragroup_19814));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->mainzisegred_large_20273));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->mainzisegred_nonseg_18847));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->mainzisegred_nonseg_19659));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->mainzisegred_nonseg_20557));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->mainzisegred_nonseg_23356));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->mainzisegred_nonseg_23388));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->mainzisegred_small_20273));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->testzisegmap_21033));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->testzisegmap_21209));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->testzisegmap_21542));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->testzisegmap_21640));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->testzisegmap_21704));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->testzisegmap_21979));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->testzisegmap_22381));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->testzisegmap_intragroup_21977));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->testzisegred_large_22416));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->testzisegred_nonseg_21019));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->testzisegred_nonseg_21830));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->testzisegred_nonseg_22685));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->testzisegred_nonseg_23431));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->testzisegred_nonseg_23463));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->testzisegred_small_22416));
    teardown_opencl(&ctx->opencl);
    free(ctx);
}
int futhark_context_sync(struct futhark_context *ctx)
{
    cl_int failure_idx = -1;
    
    if (ctx->failure_is_an_option) {
        OPENCL_SUCCEED_OR_RETURN(clEnqueueReadBuffer(ctx->opencl.queue,
                                                     ctx->global_failure,
                                                     CL_FALSE, 0,
                                                     sizeof(cl_int),
                                                     &failure_idx, 0, NULL,
                                                     ctx->profiling_paused ||
                                                     !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                               &ctx->copy_scalar_from_dev_runs,
                                                                                               &ctx->copy_scalar_from_dev_total_runtime)));
        ctx->failure_is_an_option = 0;
    }
    OPENCL_SUCCEED_OR_RETURN(clFinish(ctx->opencl.queue));
    if (failure_idx >= 0) {
        cl_int no_failure = -1;
        
        OPENCL_SUCCEED_OR_RETURN(clEnqueueWriteBuffer(ctx->opencl.queue,
                                                      ctx->global_failure,
                                                      CL_TRUE, 0,
                                                      sizeof(cl_int),
                                                      &no_failure, 0, NULL,
                                                      NULL));
        
        int64_t args[3 + 1];
        
        OPENCL_SUCCEED_OR_RETURN(clEnqueueReadBuffer(ctx->opencl.queue,
                                                     ctx->global_failure_args,
                                                     CL_TRUE, 0, sizeof(args),
                                                     &args, 0, NULL,
                                                     ctx->profiling_paused ||
                                                     !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                               &ctx->copy_dev_to_host_runs,
                                                                                               &ctx->copy_dev_to_host_total_runtime)));
        switch (failure_idx) {
            
          case 0:
            {
                ctx->error =
                    msgprintf("Range %lld..%lld...%lld is invalid.\n-> #0  cvaold.fut:54:29-52\n   #1  cvaold.fut:95:25-65\n   #2  cvaold.fut:109:16-62\n   #3  cvaold.fut:105:17-109:85\n   #4  cvaold.fut:100:1-160:20\n",
                              args[0], args[1], args[2]);
                break;
            }
            
          case 1:
            {
                ctx->error =
                    msgprintf("Index [%lld] out of bounds for array of shape [%lld].\n-> #0  cvaold.fut:96:47-70\n   #1  cvaold.fut:109:16-62\n   #2  cvaold.fut:105:17-109:85\n   #3  cvaold.fut:100:1-160:20\n",
                              args[0], args[1]);
                break;
            }
            
          case 2:
            {
                ctx->error =
                    msgprintf("Index [%lld:] out of bounds for array of shape [%lld].\n-> #0  cvaold.fut:97:74-90\n   #1  cvaold.fut:109:16-62\n   #2  cvaold.fut:105:17-109:85\n   #3  cvaold.fut:100:1-160:20\n",
                              args[0], args[1]);
                break;
            }
            
          case 3:
            {
                ctx->error =
                    msgprintf("Range %lld..%lld...%lld is invalid.\n-> #0  cvaold.fut:54:29-52\n   #1  cvaold.fut:95:25-65\n   #2  cvaold.fut:109:16-62\n   #3  cvaold.fut:105:17-109:85\n   #4  cvaold.fut:100:1-160:20\n",
                              args[0], args[1], args[2]);
                break;
            }
            
          case 4:
            {
                ctx->error =
                    msgprintf("Index [%lld] out of bounds for array of shape [%lld].\n-> #0  cvaold.fut:96:47-70\n   #1  cvaold.fut:109:16-62\n   #2  cvaold.fut:105:17-109:85\n   #3  cvaold.fut:100:1-160:20\n",
                              args[0], args[1]);
                break;
            }
            
          case 5:
            {
                ctx->error =
                    msgprintf("Index [%lld:] out of bounds for array of shape [%lld].\n-> #0  cvaold.fut:97:74-90\n   #1  cvaold.fut:109:16-62\n   #2  cvaold.fut:105:17-109:85\n   #3  cvaold.fut:100:1-160:20\n",
                              args[0], args[1]);
                break;
            }
            
          case 6:
            {
                ctx->error =
                    msgprintf("Index [%lld] out of bounds for array of shape [%lld].\n-> #0  cvaold.fut:71:97-104\n   #1  cvaold.fut:123:32-62\n   #2  cvaold.fut:123:22-69\n   #3  cvaold.fut:100:1-160:20\n",
                              args[0], args[1]);
                break;
            }
            
          case 7:
            {
                ctx->error =
                    msgprintf("Index [%lld] out of bounds for array of shape [%lld].\n-> #0  cvaold.fut:71:58-105\n   #1  cvaold.fut:123:32-62\n   #2  cvaold.fut:123:22-69\n   #3  cvaold.fut:100:1-160:20\n",
                              args[0], args[1]);
                break;
            }
            
          case 8:
            {
                ctx->error =
                    msgprintf("Range %lld..%lld...%lld is invalid.\n-> #0  cvaold.fut:39:30-45\n   #1  cvaold.fut:47:27-71\n   #2  cvaold.fut:153:34-59\n   #3  cvaold.fut:151:40-153:66\n   #4  /prelude/soacs.fut:56:19-23\n   #5  /prelude/soacs.fut:56:3-37\n   #6  cvaold.fut:150:25-154:34\n   #7  cvaold.fut:149:21-154:46\n   #8  cvaold.fut:100:1-160:20\n",
                              args[0], args[1], args[2]);
                break;
            }
            
          case 9:
            {
                ctx->error =
                    msgprintf("Index [%lld] out of bounds for array of shape [%lld].\n-> #0  cvaold.fut:49:38-63\n   #1  cvaold.fut:153:34-59\n   #2  cvaold.fut:151:40-153:66\n   #3  /prelude/soacs.fut:56:19-23\n   #4  /prelude/soacs.fut:56:3-37\n   #5  cvaold.fut:150:25-154:34\n   #6  cvaold.fut:149:21-154:46\n   #7  cvaold.fut:100:1-160:20\n",
                              args[0], args[1]);
                break;
            }
            
          case 10:
            {
                ctx->error =
                    msgprintf("Range %lld..%lld...%lld is invalid.\n-> #0  cvaold.fut:39:30-45\n   #1  cvaold.fut:47:27-71\n   #2  cvaold.fut:153:34-59\n   #3  cvaold.fut:151:40-153:66\n   #4  /prelude/soacs.fut:56:19-23\n   #5  /prelude/soacs.fut:56:3-37\n   #6  cvaold.fut:150:25-154:34\n   #7  cvaold.fut:149:21-154:46\n   #8  cvaold.fut:100:1-160:20\n",
                              args[0], args[1], args[2]);
                break;
            }
            
          case 11:
            {
                ctx->error =
                    msgprintf("Index [%lld] out of bounds for array of shape [%lld].\n-> #0  cvaold.fut:49:38-63\n   #1  cvaold.fut:153:34-59\n   #2  cvaold.fut:151:40-153:66\n   #3  /prelude/soacs.fut:56:19-23\n   #4  /prelude/soacs.fut:56:3-37\n   #5  cvaold.fut:150:25-154:34\n   #6  cvaold.fut:149:21-154:46\n   #7  cvaold.fut:100:1-160:20\n",
                              args[0], args[1]);
                break;
            }
            
          case 12:
            {
                ctx->error =
                    msgprintf("Range %lld..%lld...%lld is invalid.\n-> #0  cvaold.fut:39:30-45\n   #1  cvaold.fut:47:27-71\n   #2  cvaold.fut:153:34-59\n   #3  cvaold.fut:151:40-153:66\n   #4  /prelude/soacs.fut:56:19-23\n   #5  /prelude/soacs.fut:56:3-37\n   #6  cvaold.fut:150:25-154:34\n   #7  cvaold.fut:149:21-154:46\n   #8  cvaold.fut:100:1-160:20\n",
                              args[0], args[1], args[2]);
                break;
            }
            
          case 13:
            {
                ctx->error =
                    msgprintf("Index [%lld] out of bounds for array of shape [%lld].\n-> #0  cvaold.fut:49:38-63\n   #1  cvaold.fut:153:34-59\n   #2  cvaold.fut:151:40-153:66\n   #3  /prelude/soacs.fut:56:19-23\n   #4  /prelude/soacs.fut:56:3-37\n   #5  cvaold.fut:150:25-154:34\n   #6  cvaold.fut:149:21-154:46\n   #7  cvaold.fut:100:1-160:20\n",
                              args[0], args[1]);
                break;
            }
            
          case 14:
            {
                ctx->error =
                    msgprintf("Range %lld..%lld...%lld is invalid.\n-> #0  cvaold.fut:39:30-45\n   #1  cvaold.fut:47:27-71\n   #2  cvaold.fut:153:34-59\n   #3  cvaold.fut:151:40-153:66\n   #4  /prelude/soacs.fut:56:19-23\n   #5  /prelude/soacs.fut:56:3-37\n   #6  cvaold.fut:150:25-154:34\n   #7  cvaold.fut:149:21-154:46\n   #8  cvaold.fut:100:1-160:20\n",
                              args[0], args[1], args[2]);
                break;
            }
            
          case 15:
            {
                ctx->error =
                    msgprintf("Index [%lld] out of bounds for array of shape [%lld].\n-> #0  cvaold.fut:49:38-63\n   #1  cvaold.fut:153:34-59\n   #2  cvaold.fut:151:40-153:66\n   #3  /prelude/soacs.fut:56:19-23\n   #4  /prelude/soacs.fut:56:3-37\n   #5  cvaold.fut:150:25-154:34\n   #6  cvaold.fut:149:21-154:46\n   #7  cvaold.fut:100:1-160:20\n",
                              args[0], args[1]);
                break;
            }
            
          case 16:
            {
                ctx->error =
                    msgprintf("Range %lld..%lld...%lld is invalid.\n-> #0  cvaold.fut:39:30-45\n   #1  cvaold.fut:47:27-71\n   #2  cvaold.fut:153:34-59\n   #3  cvaold.fut:151:40-153:66\n   #4  /prelude/soacs.fut:56:19-23\n   #5  /prelude/soacs.fut:56:3-37\n   #6  cvaold.fut:150:25-154:34\n   #7  cvaold.fut:149:21-154:46\n   #8  cvaold.fut:100:1-160:20\n",
                              args[0], args[1], args[2]);
                break;
            }
            
          case 17:
            {
                ctx->error =
                    msgprintf("Index [%lld] out of bounds for array of shape [%lld].\n-> #0  cvaold.fut:49:38-63\n   #1  cvaold.fut:153:34-59\n   #2  cvaold.fut:151:40-153:66\n   #3  /prelude/soacs.fut:56:19-23\n   #4  /prelude/soacs.fut:56:3-37\n   #5  cvaold.fut:150:25-154:34\n   #6  cvaold.fut:149:21-154:46\n   #7  cvaold.fut:100:1-160:20\n",
                              args[0], args[1]);
                break;
            }
            
          case 18:
            {
                ctx->error =
                    msgprintf("Range %lld..%lld...%lld is invalid.\n-> #0  cvaold.fut:54:29-52\n   #1  cvaold.fut:95:25-65\n   #2  cvaold.fut:109:16-62\n   #3  cvaold.fut:105:17-109:85\n   #4  cvaold.fut:168:3-120\n   #5  cvaold.fut:167:1-168:128\n",
                              args[0], args[1], args[2]);
                break;
            }
            
          case 19:
            {
                ctx->error =
                    msgprintf("Index [%lld] out of bounds for array of shape [%lld].\n-> #0  cvaold.fut:96:47-70\n   #1  cvaold.fut:109:16-62\n   #2  cvaold.fut:105:17-109:85\n   #3  cvaold.fut:168:3-120\n   #4  cvaold.fut:167:1-168:128\n",
                              args[0], args[1]);
                break;
            }
            
          case 20:
            {
                ctx->error =
                    msgprintf("Index [%lld:] out of bounds for array of shape [%lld].\n-> #0  cvaold.fut:97:74-90\n   #1  cvaold.fut:109:16-62\n   #2  cvaold.fut:105:17-109:85\n   #3  cvaold.fut:168:3-120\n   #4  cvaold.fut:167:1-168:128\n",
                              args[0], args[1]);
                break;
            }
            
          case 21:
            {
                ctx->error =
                    msgprintf("Range %lld..%lld...%lld is invalid.\n-> #0  cvaold.fut:54:29-52\n   #1  cvaold.fut:95:25-65\n   #2  cvaold.fut:109:16-62\n   #3  cvaold.fut:105:17-109:85\n   #4  cvaold.fut:168:3-120\n   #5  cvaold.fut:167:1-168:128\n",
                              args[0], args[1], args[2]);
                break;
            }
            
          case 22:
            {
                ctx->error =
                    msgprintf("Index [%lld] out of bounds for array of shape [%lld].\n-> #0  cvaold.fut:96:47-70\n   #1  cvaold.fut:109:16-62\n   #2  cvaold.fut:105:17-109:85\n   #3  cvaold.fut:168:3-120\n   #4  cvaold.fut:167:1-168:128\n",
                              args[0], args[1]);
                break;
            }
            
          case 23:
            {
                ctx->error =
                    msgprintf("Index [%lld:] out of bounds for array of shape [%lld].\n-> #0  cvaold.fut:97:74-90\n   #1  cvaold.fut:109:16-62\n   #2  cvaold.fut:105:17-109:85\n   #3  cvaold.fut:168:3-120\n   #4  cvaold.fut:167:1-168:128\n",
                              args[0], args[1]);
                break;
            }
            
          case 24:
            {
                ctx->error =
                    msgprintf("Index [%lld] out of bounds for array of shape [%lld].\n-> #0  cvaold.fut:71:97-104\n   #1  cvaold.fut:123:32-62\n   #2  cvaold.fut:123:22-69\n   #3  cvaold.fut:168:3-120\n   #4  cvaold.fut:167:1-168:128\n",
                              args[0], args[1]);
                break;
            }
            
          case 25:
            {
                ctx->error =
                    msgprintf("Index [%lld] out of bounds for array of shape [%lld].\n-> #0  cvaold.fut:71:58-105\n   #1  cvaold.fut:123:32-62\n   #2  cvaold.fut:123:22-69\n   #3  cvaold.fut:168:3-120\n   #4  cvaold.fut:167:1-168:128\n",
                              args[0], args[1]);
                break;
            }
            
          case 26:
            {
                ctx->error =
                    msgprintf("Range %lld..%lld...%lld is invalid.\n-> #0  cvaold.fut:39:30-45\n   #1  cvaold.fut:47:27-71\n   #2  cvaold.fut:153:34-59\n   #3  cvaold.fut:151:40-153:66\n   #4  /prelude/soacs.fut:56:19-23\n   #5  /prelude/soacs.fut:56:3-37\n   #6  cvaold.fut:150:25-154:34\n   #7  cvaold.fut:149:21-154:46\n   #8  cvaold.fut:168:3-120\n   #9  cvaold.fut:167:1-168:128\n",
                              args[0], args[1], args[2]);
                break;
            }
            
          case 27:
            {
                ctx->error =
                    msgprintf("Index [%lld] out of bounds for array of shape [%lld].\n-> #0  cvaold.fut:49:38-63\n   #1  cvaold.fut:153:34-59\n   #2  cvaold.fut:151:40-153:66\n   #3  /prelude/soacs.fut:56:19-23\n   #4  /prelude/soacs.fut:56:3-37\n   #5  cvaold.fut:150:25-154:34\n   #6  cvaold.fut:149:21-154:46\n   #7  cvaold.fut:168:3-120\n   #8  cvaold.fut:167:1-168:128\n",
                              args[0], args[1]);
                break;
            }
            
          case 28:
            {
                ctx->error =
                    msgprintf("Range %lld..%lld...%lld is invalid.\n-> #0  cvaold.fut:39:30-45\n   #1  cvaold.fut:47:27-71\n   #2  cvaold.fut:153:34-59\n   #3  cvaold.fut:151:40-153:66\n   #4  /prelude/soacs.fut:56:19-23\n   #5  /prelude/soacs.fut:56:3-37\n   #6  cvaold.fut:150:25-154:34\n   #7  cvaold.fut:149:21-154:46\n   #8  cvaold.fut:168:3-120\n   #9  cvaold.fut:167:1-168:128\n",
                              args[0], args[1], args[2]);
                break;
            }
            
          case 29:
            {
                ctx->error =
                    msgprintf("Index [%lld] out of bounds for array of shape [%lld].\n-> #0  cvaold.fut:49:38-63\n   #1  cvaold.fut:153:34-59\n   #2  cvaold.fut:151:40-153:66\n   #3  /prelude/soacs.fut:56:19-23\n   #4  /prelude/soacs.fut:56:3-37\n   #5  cvaold.fut:150:25-154:34\n   #6  cvaold.fut:149:21-154:46\n   #7  cvaold.fut:168:3-120\n   #8  cvaold.fut:167:1-168:128\n",
                              args[0], args[1]);
                break;
            }
            
          case 30:
            {
                ctx->error =
                    msgprintf("Range %lld..%lld...%lld is invalid.\n-> #0  cvaold.fut:39:30-45\n   #1  cvaold.fut:47:27-71\n   #2  cvaold.fut:153:34-59\n   #3  cvaold.fut:151:40-153:66\n   #4  /prelude/soacs.fut:56:19-23\n   #5  /prelude/soacs.fut:56:3-37\n   #6  cvaold.fut:150:25-154:34\n   #7  cvaold.fut:149:21-154:46\n   #8  cvaold.fut:168:3-120\n   #9  cvaold.fut:167:1-168:128\n",
                              args[0], args[1], args[2]);
                break;
            }
            
          case 31:
            {
                ctx->error =
                    msgprintf("Index [%lld] out of bounds for array of shape [%lld].\n-> #0  cvaold.fut:49:38-63\n   #1  cvaold.fut:153:34-59\n   #2  cvaold.fut:151:40-153:66\n   #3  /prelude/soacs.fut:56:19-23\n   #4  /prelude/soacs.fut:56:3-37\n   #5  cvaold.fut:150:25-154:34\n   #6  cvaold.fut:149:21-154:46\n   #7  cvaold.fut:168:3-120\n   #8  cvaold.fut:167:1-168:128\n",
                              args[0], args[1]);
                break;
            }
            
          case 32:
            {
                ctx->error =
                    msgprintf("Range %lld..%lld...%lld is invalid.\n-> #0  cvaold.fut:39:30-45\n   #1  cvaold.fut:47:27-71\n   #2  cvaold.fut:153:34-59\n   #3  cvaold.fut:151:40-153:66\n   #4  /prelude/soacs.fut:56:19-23\n   #5  /prelude/soacs.fut:56:3-37\n   #6  cvaold.fut:150:25-154:34\n   #7  cvaold.fut:149:21-154:46\n   #8  cvaold.fut:168:3-120\n   #9  cvaold.fut:167:1-168:128\n",
                              args[0], args[1], args[2]);
                break;
            }
            
          case 33:
            {
                ctx->error =
                    msgprintf("Index [%lld] out of bounds for array of shape [%lld].\n-> #0  cvaold.fut:49:38-63\n   #1  cvaold.fut:153:34-59\n   #2  cvaold.fut:151:40-153:66\n   #3  /prelude/soacs.fut:56:19-23\n   #4  /prelude/soacs.fut:56:3-37\n   #5  cvaold.fut:150:25-154:34\n   #6  cvaold.fut:149:21-154:46\n   #7  cvaold.fut:168:3-120\n   #8  cvaold.fut:167:1-168:128\n",
                              args[0], args[1]);
                break;
            }
            
          case 34:
            {
                ctx->error =
                    msgprintf("Range %lld..%lld...%lld is invalid.\n-> #0  cvaold.fut:39:30-45\n   #1  cvaold.fut:47:27-71\n   #2  cvaold.fut:153:34-59\n   #3  cvaold.fut:151:40-153:66\n   #4  /prelude/soacs.fut:56:19-23\n   #5  /prelude/soacs.fut:56:3-37\n   #6  cvaold.fut:150:25-154:34\n   #7  cvaold.fut:149:21-154:46\n   #8  cvaold.fut:168:3-120\n   #9  cvaold.fut:167:1-168:128\n",
                              args[0], args[1], args[2]);
                break;
            }
            
          case 35:
            {
                ctx->error =
                    msgprintf("Index [%lld] out of bounds for array of shape [%lld].\n-> #0  cvaold.fut:49:38-63\n   #1  cvaold.fut:153:34-59\n   #2  cvaold.fut:151:40-153:66\n   #3  /prelude/soacs.fut:56:19-23\n   #4  /prelude/soacs.fut:56:3-37\n   #5  cvaold.fut:150:25-154:34\n   #6  cvaold.fut:149:21-154:46\n   #7  cvaold.fut:168:3-120\n   #8  cvaold.fut:167:1-168:128\n",
                              args[0], args[1]);
                break;
            }
        }
        return 1;
    }
    return 0;
}
int futhark_context_clear_caches(struct futhark_context *ctx)
{
    ctx->error = OPENCL_SUCCEED_NONFATAL(opencl_free_all(&ctx->opencl));
    return ctx->error != NULL;
}
cl_command_queue futhark_context_get_command_queue(struct futhark_context *ctx)
{
    return ctx->opencl.queue;
}
static int memblock_unref_device(struct futhark_context *ctx,
                                 struct memblock_device *block, const
                                 char *desc)
{
    if (block->references != NULL) {
        *block->references -= 1;
        if (ctx->detail_memory)
            fprintf(stderr,
                    "Unreferencing block %s (allocated as %s) in %s: %d references remaining.\n",
                    desc, block->desc, "space 'device'", *block->references);
        if (*block->references == 0) {
            ctx->cur_mem_usage_device -= block->size;
            OPENCL_SUCCEED_OR_RETURN(opencl_free(&ctx->opencl, block->mem,
                                                 desc));
            free(block->references);
            if (ctx->detail_memory)
                fprintf(stderr,
                        "%lld bytes freed (now allocated: %lld bytes)\n",
                        (long long) block->size,
                        (long long) ctx->cur_mem_usage_device);
        }
        block->references = NULL;
    }
    return 0;
}
static int memblock_alloc_device(struct futhark_context *ctx,
                                 struct memblock_device *block, int64_t size,
                                 const char *desc)
{
    if (size < 0)
        futhark_panic(1,
                      "Negative allocation of %lld bytes attempted for %s in %s.\n",
                      (long long) size, desc, "space 'device'",
                      ctx->cur_mem_usage_device);
    
    int ret = memblock_unref_device(ctx, block, desc);
    
    ctx->cur_mem_usage_device += size;
    if (ctx->detail_memory)
        fprintf(stderr,
                "Allocating %lld bytes for %s in %s (then allocated: %lld bytes)",
                (long long) size, desc, "space 'device'",
                (long long) ctx->cur_mem_usage_device);
    if (ctx->cur_mem_usage_device > ctx->peak_mem_usage_device) {
        ctx->peak_mem_usage_device = ctx->cur_mem_usage_device;
        if (ctx->detail_memory)
            fprintf(stderr, " (new peak).\n");
    } else if (ctx->detail_memory)
        fprintf(stderr, ".\n");
    OPENCL_SUCCEED_OR_RETURN(opencl_alloc(&ctx->opencl, size, desc,
                                          &block->mem));
    block->references = (int *) malloc(sizeof(int));
    *block->references = 1;
    block->size = size;
    block->desc = desc;
    return ret;
}
static int memblock_set_device(struct futhark_context *ctx,
                               struct memblock_device *lhs,
                               struct memblock_device *rhs, const
                               char *lhs_desc)
{
    int ret = memblock_unref_device(ctx, lhs, lhs_desc);
    
    if (rhs->references != NULL)
        (*rhs->references)++;
    *lhs = *rhs;
    return ret;
}
static int memblock_unref(struct futhark_context *ctx, struct memblock *block,
                          const char *desc)
{
    if (block->references != NULL) {
        *block->references -= 1;
        if (ctx->detail_memory)
            fprintf(stderr,
                    "Unreferencing block %s (allocated as %s) in %s: %d references remaining.\n",
                    desc, block->desc, "default space", *block->references);
        if (*block->references == 0) {
            ctx->cur_mem_usage_default -= block->size;
            free(block->mem);
            free(block->references);
            if (ctx->detail_memory)
                fprintf(stderr,
                        "%lld bytes freed (now allocated: %lld bytes)\n",
                        (long long) block->size,
                        (long long) ctx->cur_mem_usage_default);
        }
        block->references = NULL;
    }
    return 0;
}
static int memblock_alloc(struct futhark_context *ctx, struct memblock *block,
                          int64_t size, const char *desc)
{
    if (size < 0)
        futhark_panic(1,
                      "Negative allocation of %lld bytes attempted for %s in %s.\n",
                      (long long) size, desc, "default space",
                      ctx->cur_mem_usage_default);
    
    int ret = memblock_unref(ctx, block, desc);
    
    ctx->cur_mem_usage_default += size;
    if (ctx->detail_memory)
        fprintf(stderr,
                "Allocating %lld bytes for %s in %s (then allocated: %lld bytes)",
                (long long) size, desc, "default space",
                (long long) ctx->cur_mem_usage_default);
    if (ctx->cur_mem_usage_default > ctx->peak_mem_usage_default) {
        ctx->peak_mem_usage_default = ctx->cur_mem_usage_default;
        if (ctx->detail_memory)
            fprintf(stderr, " (new peak).\n");
    } else if (ctx->detail_memory)
        fprintf(stderr, ".\n");
    block->mem = (char *) malloc(size);
    block->references = (int *) malloc(sizeof(int));
    *block->references = 1;
    block->size = size;
    block->desc = desc;
    return ret;
}
static int memblock_set(struct futhark_context *ctx, struct memblock *lhs,
                        struct memblock *rhs, const char *lhs_desc)
{
    int ret = memblock_unref(ctx, lhs, lhs_desc);
    
    if (rhs->references != NULL)
        (*rhs->references)++;
    *lhs = *rhs;
    return ret;
}
char *futhark_context_report(struct futhark_context *ctx)
{
    struct str_builder builder;
    
    str_builder_init(&builder);
    if (ctx->detail_memory || ctx->profiling) {
        str_builder(&builder,
                    "Peak memory usage for space 'device': %lld bytes.\n",
                    (long long) ctx->peak_mem_usage_device);
        { }
    }
    if (ctx->profiling) {
        OPENCL_SUCCEED_FATAL(opencl_tally_profiling_records(&ctx->opencl));
        str_builder(&builder,
                    "copy_dev_to_dev                  ran %5d times; avg: %8ldus; total: %8ldus\n",
                    ctx->copy_dev_to_dev_runs,
                    (long) ctx->copy_dev_to_dev_total_runtime /
                    (ctx->copy_dev_to_dev_runs !=
                     0 ? ctx->copy_dev_to_dev_runs : 1),
                    (long) ctx->copy_dev_to_dev_total_runtime);
        ctx->total_runtime += ctx->copy_dev_to_dev_total_runtime;
        ctx->total_runs += ctx->copy_dev_to_dev_runs;
        str_builder(&builder,
                    "copy_dev_to_host                 ran %5d times; avg: %8ldus; total: %8ldus\n",
                    ctx->copy_dev_to_host_runs,
                    (long) ctx->copy_dev_to_host_total_runtime /
                    (ctx->copy_dev_to_host_runs !=
                     0 ? ctx->copy_dev_to_host_runs : 1),
                    (long) ctx->copy_dev_to_host_total_runtime);
        ctx->total_runtime += ctx->copy_dev_to_host_total_runtime;
        ctx->total_runs += ctx->copy_dev_to_host_runs;
        str_builder(&builder,
                    "copy_host_to_dev                 ran %5d times; avg: %8ldus; total: %8ldus\n",
                    ctx->copy_host_to_dev_runs,
                    (long) ctx->copy_host_to_dev_total_runtime /
                    (ctx->copy_host_to_dev_runs !=
                     0 ? ctx->copy_host_to_dev_runs : 1),
                    (long) ctx->copy_host_to_dev_total_runtime);
        ctx->total_runtime += ctx->copy_host_to_dev_total_runtime;
        ctx->total_runs += ctx->copy_host_to_dev_runs;
        str_builder(&builder,
                    "copy_scalar_to_dev               ran %5d times; avg: %8ldus; total: %8ldus\n",
                    ctx->copy_scalar_to_dev_runs,
                    (long) ctx->copy_scalar_to_dev_total_runtime /
                    (ctx->copy_scalar_to_dev_runs !=
                     0 ? ctx->copy_scalar_to_dev_runs : 1),
                    (long) ctx->copy_scalar_to_dev_total_runtime);
        ctx->total_runtime += ctx->copy_scalar_to_dev_total_runtime;
        ctx->total_runs += ctx->copy_scalar_to_dev_runs;
        str_builder(&builder,
                    "copy_scalar_from_dev             ran %5d times; avg: %8ldus; total: %8ldus\n",
                    ctx->copy_scalar_from_dev_runs,
                    (long) ctx->copy_scalar_from_dev_total_runtime /
                    (ctx->copy_scalar_from_dev_runs !=
                     0 ? ctx->copy_scalar_from_dev_runs : 1),
                    (long) ctx->copy_scalar_from_dev_total_runtime);
        ctx->total_runtime += ctx->copy_scalar_from_dev_total_runtime;
        ctx->total_runs += ctx->copy_scalar_from_dev_runs;
        str_builder(&builder,
                    "gpu_map_transpose_f32            ran %5d times; avg: %8ldus; total: %8ldus\n",
                    ctx->gpu_map_transpose_f32_runs,
                    (long) ctx->gpu_map_transpose_f32_total_runtime /
                    (ctx->gpu_map_transpose_f32_runs !=
                     0 ? ctx->gpu_map_transpose_f32_runs : 1),
                    (long) ctx->gpu_map_transpose_f32_total_runtime);
        ctx->total_runtime += ctx->gpu_map_transpose_f32_total_runtime;
        ctx->total_runs += ctx->gpu_map_transpose_f32_runs;
        str_builder(&builder,
                    "gpu_map_transpose_f32_low_height ran %5d times; avg: %8ldus; total: %8ldus\n",
                    ctx->gpu_map_transpose_f32_low_height_runs,
                    (long) ctx->gpu_map_transpose_f32_low_height_total_runtime /
                    (ctx->gpu_map_transpose_f32_low_height_runs !=
                     0 ? ctx->gpu_map_transpose_f32_low_height_runs : 1),
                    (long) ctx->gpu_map_transpose_f32_low_height_total_runtime);
        ctx->total_runtime +=
            ctx->gpu_map_transpose_f32_low_height_total_runtime;
        ctx->total_runs += ctx->gpu_map_transpose_f32_low_height_runs;
        str_builder(&builder,
                    "gpu_map_transpose_f32_low_width  ran %5d times; avg: %8ldus; total: %8ldus\n",
                    ctx->gpu_map_transpose_f32_low_width_runs,
                    (long) ctx->gpu_map_transpose_f32_low_width_total_runtime /
                    (ctx->gpu_map_transpose_f32_low_width_runs !=
                     0 ? ctx->gpu_map_transpose_f32_low_width_runs : 1),
                    (long) ctx->gpu_map_transpose_f32_low_width_total_runtime);
        ctx->total_runtime +=
            ctx->gpu_map_transpose_f32_low_width_total_runtime;
        ctx->total_runs += ctx->gpu_map_transpose_f32_low_width_runs;
        str_builder(&builder,
                    "gpu_map_transpose_f32_small      ran %5d times; avg: %8ldus; total: %8ldus\n",
                    ctx->gpu_map_transpose_f32_small_runs,
                    (long) ctx->gpu_map_transpose_f32_small_total_runtime /
                    (ctx->gpu_map_transpose_f32_small_runs !=
                     0 ? ctx->gpu_map_transpose_f32_small_runs : 1),
                    (long) ctx->gpu_map_transpose_f32_small_total_runtime);
        ctx->total_runtime += ctx->gpu_map_transpose_f32_small_total_runtime;
        ctx->total_runs += ctx->gpu_map_transpose_f32_small_runs;
        str_builder(&builder,
                    "main.segmap_18861                ran %5d times; avg: %8ldus; total: %8ldus\n",
                    ctx->mainzisegmap_18861_runs,
                    (long) ctx->mainzisegmap_18861_total_runtime /
                    (ctx->mainzisegmap_18861_runs !=
                     0 ? ctx->mainzisegmap_18861_runs : 1),
                    (long) ctx->mainzisegmap_18861_total_runtime);
        ctx->total_runtime += ctx->mainzisegmap_18861_total_runtime;
        ctx->total_runs += ctx->mainzisegmap_18861_runs;
        str_builder(&builder,
                    "main.segmap_19037                ran %5d times; avg: %8ldus; total: %8ldus\n",
                    ctx->mainzisegmap_19037_runs,
                    (long) ctx->mainzisegmap_19037_total_runtime /
                    (ctx->mainzisegmap_19037_runs !=
                     0 ? ctx->mainzisegmap_19037_runs : 1),
                    (long) ctx->mainzisegmap_19037_total_runtime);
        ctx->total_runtime += ctx->mainzisegmap_19037_total_runtime;
        ctx->total_runs += ctx->mainzisegmap_19037_runs;
        str_builder(&builder,
                    "main.segmap_19370                ran %5d times; avg: %8ldus; total: %8ldus\n",
                    ctx->mainzisegmap_19370_runs,
                    (long) ctx->mainzisegmap_19370_total_runtime /
                    (ctx->mainzisegmap_19370_runs !=
                     0 ? ctx->mainzisegmap_19370_runs : 1),
                    (long) ctx->mainzisegmap_19370_total_runtime);
        ctx->total_runtime += ctx->mainzisegmap_19370_total_runtime;
        ctx->total_runs += ctx->mainzisegmap_19370_runs;
        str_builder(&builder,
                    "main.segmap_19468                ran %5d times; avg: %8ldus; total: %8ldus\n",
                    ctx->mainzisegmap_19468_runs,
                    (long) ctx->mainzisegmap_19468_total_runtime /
                    (ctx->mainzisegmap_19468_runs !=
                     0 ? ctx->mainzisegmap_19468_runs : 1),
                    (long) ctx->mainzisegmap_19468_total_runtime);
        ctx->total_runtime += ctx->mainzisegmap_19468_total_runtime;
        ctx->total_runs += ctx->mainzisegmap_19468_runs;
        str_builder(&builder,
                    "main.segmap_19532                ran %5d times; avg: %8ldus; total: %8ldus\n",
                    ctx->mainzisegmap_19532_runs,
                    (long) ctx->mainzisegmap_19532_total_runtime /
                    (ctx->mainzisegmap_19532_runs !=
                     0 ? ctx->mainzisegmap_19532_runs : 1),
                    (long) ctx->mainzisegmap_19532_total_runtime);
        ctx->total_runtime += ctx->mainzisegmap_19532_total_runtime;
        ctx->total_runs += ctx->mainzisegmap_19532_runs;
        str_builder(&builder,
                    "main.segmap_19816                ran %5d times; avg: %8ldus; total: %8ldus\n",
                    ctx->mainzisegmap_19816_runs,
                    (long) ctx->mainzisegmap_19816_total_runtime /
                    (ctx->mainzisegmap_19816_runs !=
                     0 ? ctx->mainzisegmap_19816_runs : 1),
                    (long) ctx->mainzisegmap_19816_total_runtime);
        ctx->total_runtime += ctx->mainzisegmap_19816_total_runtime;
        ctx->total_runs += ctx->mainzisegmap_19816_runs;
        str_builder(&builder,
                    "main.segmap_20238                ran %5d times; avg: %8ldus; total: %8ldus\n",
                    ctx->mainzisegmap_20238_runs,
                    (long) ctx->mainzisegmap_20238_total_runtime /
                    (ctx->mainzisegmap_20238_runs !=
                     0 ? ctx->mainzisegmap_20238_runs : 1),
                    (long) ctx->mainzisegmap_20238_total_runtime);
        ctx->total_runtime += ctx->mainzisegmap_20238_total_runtime;
        ctx->total_runs += ctx->mainzisegmap_20238_runs;
        str_builder(&builder,
                    "main.segmap_intragroup_19814     ran %5d times; avg: %8ldus; total: %8ldus\n",
                    ctx->mainzisegmap_intragroup_19814_runs,
                    (long) ctx->mainzisegmap_intragroup_19814_total_runtime /
                    (ctx->mainzisegmap_intragroup_19814_runs !=
                     0 ? ctx->mainzisegmap_intragroup_19814_runs : 1),
                    (long) ctx->mainzisegmap_intragroup_19814_total_runtime);
        ctx->total_runtime += ctx->mainzisegmap_intragroup_19814_total_runtime;
        ctx->total_runs += ctx->mainzisegmap_intragroup_19814_runs;
        str_builder(&builder,
                    "main.segred_large_20273          ran %5d times; avg: %8ldus; total: %8ldus\n",
                    ctx->mainzisegred_large_20273_runs,
                    (long) ctx->mainzisegred_large_20273_total_runtime /
                    (ctx->mainzisegred_large_20273_runs !=
                     0 ? ctx->mainzisegred_large_20273_runs : 1),
                    (long) ctx->mainzisegred_large_20273_total_runtime);
        ctx->total_runtime += ctx->mainzisegred_large_20273_total_runtime;
        ctx->total_runs += ctx->mainzisegred_large_20273_runs;
        str_builder(&builder,
                    "main.segred_nonseg_18847         ran %5d times; avg: %8ldus; total: %8ldus\n",
                    ctx->mainzisegred_nonseg_18847_runs,
                    (long) ctx->mainzisegred_nonseg_18847_total_runtime /
                    (ctx->mainzisegred_nonseg_18847_runs !=
                     0 ? ctx->mainzisegred_nonseg_18847_runs : 1),
                    (long) ctx->mainzisegred_nonseg_18847_total_runtime);
        ctx->total_runtime += ctx->mainzisegred_nonseg_18847_total_runtime;
        ctx->total_runs += ctx->mainzisegred_nonseg_18847_runs;
        str_builder(&builder,
                    "main.segred_nonseg_19659         ran %5d times; avg: %8ldus; total: %8ldus\n",
                    ctx->mainzisegred_nonseg_19659_runs,
                    (long) ctx->mainzisegred_nonseg_19659_total_runtime /
                    (ctx->mainzisegred_nonseg_19659_runs !=
                     0 ? ctx->mainzisegred_nonseg_19659_runs : 1),
                    (long) ctx->mainzisegred_nonseg_19659_total_runtime);
        ctx->total_runtime += ctx->mainzisegred_nonseg_19659_total_runtime;
        ctx->total_runs += ctx->mainzisegred_nonseg_19659_runs;
        str_builder(&builder,
                    "main.segred_nonseg_20557         ran %5d times; avg: %8ldus; total: %8ldus\n",
                    ctx->mainzisegred_nonseg_20557_runs,
                    (long) ctx->mainzisegred_nonseg_20557_total_runtime /
                    (ctx->mainzisegred_nonseg_20557_runs !=
                     0 ? ctx->mainzisegred_nonseg_20557_runs : 1),
                    (long) ctx->mainzisegred_nonseg_20557_total_runtime);
        ctx->total_runtime += ctx->mainzisegred_nonseg_20557_total_runtime;
        ctx->total_runs += ctx->mainzisegred_nonseg_20557_runs;
        str_builder(&builder,
                    "main.segred_nonseg_23356         ran %5d times; avg: %8ldus; total: %8ldus\n",
                    ctx->mainzisegred_nonseg_23356_runs,
                    (long) ctx->mainzisegred_nonseg_23356_total_runtime /
                    (ctx->mainzisegred_nonseg_23356_runs !=
                     0 ? ctx->mainzisegred_nonseg_23356_runs : 1),
                    (long) ctx->mainzisegred_nonseg_23356_total_runtime);
        ctx->total_runtime += ctx->mainzisegred_nonseg_23356_total_runtime;
        ctx->total_runs += ctx->mainzisegred_nonseg_23356_runs;
        str_builder(&builder,
                    "main.segred_nonseg_23388         ran %5d times; avg: %8ldus; total: %8ldus\n",
                    ctx->mainzisegred_nonseg_23388_runs,
                    (long) ctx->mainzisegred_nonseg_23388_total_runtime /
                    (ctx->mainzisegred_nonseg_23388_runs !=
                     0 ? ctx->mainzisegred_nonseg_23388_runs : 1),
                    (long) ctx->mainzisegred_nonseg_23388_total_runtime);
        ctx->total_runtime += ctx->mainzisegred_nonseg_23388_total_runtime;
        ctx->total_runs += ctx->mainzisegred_nonseg_23388_runs;
        str_builder(&builder,
                    "main.segred_small_20273          ran %5d times; avg: %8ldus; total: %8ldus\n",
                    ctx->mainzisegred_small_20273_runs,
                    (long) ctx->mainzisegred_small_20273_total_runtime /
                    (ctx->mainzisegred_small_20273_runs !=
                     0 ? ctx->mainzisegred_small_20273_runs : 1),
                    (long) ctx->mainzisegred_small_20273_total_runtime);
        ctx->total_runtime += ctx->mainzisegred_small_20273_total_runtime;
        ctx->total_runs += ctx->mainzisegred_small_20273_runs;
        str_builder(&builder,
                    "test.segmap_21033                ran %5d times; avg: %8ldus; total: %8ldus\n",
                    ctx->testzisegmap_21033_runs,
                    (long) ctx->testzisegmap_21033_total_runtime /
                    (ctx->testzisegmap_21033_runs !=
                     0 ? ctx->testzisegmap_21033_runs : 1),
                    (long) ctx->testzisegmap_21033_total_runtime);
        ctx->total_runtime += ctx->testzisegmap_21033_total_runtime;
        ctx->total_runs += ctx->testzisegmap_21033_runs;
        str_builder(&builder,
                    "test.segmap_21209                ran %5d times; avg: %8ldus; total: %8ldus\n",
                    ctx->testzisegmap_21209_runs,
                    (long) ctx->testzisegmap_21209_total_runtime /
                    (ctx->testzisegmap_21209_runs !=
                     0 ? ctx->testzisegmap_21209_runs : 1),
                    (long) ctx->testzisegmap_21209_total_runtime);
        ctx->total_runtime += ctx->testzisegmap_21209_total_runtime;
        ctx->total_runs += ctx->testzisegmap_21209_runs;
        str_builder(&builder,
                    "test.segmap_21542                ran %5d times; avg: %8ldus; total: %8ldus\n",
                    ctx->testzisegmap_21542_runs,
                    (long) ctx->testzisegmap_21542_total_runtime /
                    (ctx->testzisegmap_21542_runs !=
                     0 ? ctx->testzisegmap_21542_runs : 1),
                    (long) ctx->testzisegmap_21542_total_runtime);
        ctx->total_runtime += ctx->testzisegmap_21542_total_runtime;
        ctx->total_runs += ctx->testzisegmap_21542_runs;
        str_builder(&builder,
                    "test.segmap_21640                ran %5d times; avg: %8ldus; total: %8ldus\n",
                    ctx->testzisegmap_21640_runs,
                    (long) ctx->testzisegmap_21640_total_runtime /
                    (ctx->testzisegmap_21640_runs !=
                     0 ? ctx->testzisegmap_21640_runs : 1),
                    (long) ctx->testzisegmap_21640_total_runtime);
        ctx->total_runtime += ctx->testzisegmap_21640_total_runtime;
        ctx->total_runs += ctx->testzisegmap_21640_runs;
        str_builder(&builder,
                    "test.segmap_21704                ran %5d times; avg: %8ldus; total: %8ldus\n",
                    ctx->testzisegmap_21704_runs,
                    (long) ctx->testzisegmap_21704_total_runtime /
                    (ctx->testzisegmap_21704_runs !=
                     0 ? ctx->testzisegmap_21704_runs : 1),
                    (long) ctx->testzisegmap_21704_total_runtime);
        ctx->total_runtime += ctx->testzisegmap_21704_total_runtime;
        ctx->total_runs += ctx->testzisegmap_21704_runs;
        str_builder(&builder,
                    "test.segmap_21979                ran %5d times; avg: %8ldus; total: %8ldus\n",
                    ctx->testzisegmap_21979_runs,
                    (long) ctx->testzisegmap_21979_total_runtime /
                    (ctx->testzisegmap_21979_runs !=
                     0 ? ctx->testzisegmap_21979_runs : 1),
                    (long) ctx->testzisegmap_21979_total_runtime);
        ctx->total_runtime += ctx->testzisegmap_21979_total_runtime;
        ctx->total_runs += ctx->testzisegmap_21979_runs;
        str_builder(&builder,
                    "test.segmap_22381                ran %5d times; avg: %8ldus; total: %8ldus\n",
                    ctx->testzisegmap_22381_runs,
                    (long) ctx->testzisegmap_22381_total_runtime /
                    (ctx->testzisegmap_22381_runs !=
                     0 ? ctx->testzisegmap_22381_runs : 1),
                    (long) ctx->testzisegmap_22381_total_runtime);
        ctx->total_runtime += ctx->testzisegmap_22381_total_runtime;
        ctx->total_runs += ctx->testzisegmap_22381_runs;
        str_builder(&builder,
                    "test.segmap_intragroup_21977     ran %5d times; avg: %8ldus; total: %8ldus\n",
                    ctx->testzisegmap_intragroup_21977_runs,
                    (long) ctx->testzisegmap_intragroup_21977_total_runtime /
                    (ctx->testzisegmap_intragroup_21977_runs !=
                     0 ? ctx->testzisegmap_intragroup_21977_runs : 1),
                    (long) ctx->testzisegmap_intragroup_21977_total_runtime);
        ctx->total_runtime += ctx->testzisegmap_intragroup_21977_total_runtime;
        ctx->total_runs += ctx->testzisegmap_intragroup_21977_runs;
        str_builder(&builder,
                    "test.segred_large_22416          ran %5d times; avg: %8ldus; total: %8ldus\n",
                    ctx->testzisegred_large_22416_runs,
                    (long) ctx->testzisegred_large_22416_total_runtime /
                    (ctx->testzisegred_large_22416_runs !=
                     0 ? ctx->testzisegred_large_22416_runs : 1),
                    (long) ctx->testzisegred_large_22416_total_runtime);
        ctx->total_runtime += ctx->testzisegred_large_22416_total_runtime;
        ctx->total_runs += ctx->testzisegred_large_22416_runs;
        str_builder(&builder,
                    "test.segred_nonseg_21019         ran %5d times; avg: %8ldus; total: %8ldus\n",
                    ctx->testzisegred_nonseg_21019_runs,
                    (long) ctx->testzisegred_nonseg_21019_total_runtime /
                    (ctx->testzisegred_nonseg_21019_runs !=
                     0 ? ctx->testzisegred_nonseg_21019_runs : 1),
                    (long) ctx->testzisegred_nonseg_21019_total_runtime);
        ctx->total_runtime += ctx->testzisegred_nonseg_21019_total_runtime;
        ctx->total_runs += ctx->testzisegred_nonseg_21019_runs;
        str_builder(&builder,
                    "test.segred_nonseg_21830         ran %5d times; avg: %8ldus; total: %8ldus\n",
                    ctx->testzisegred_nonseg_21830_runs,
                    (long) ctx->testzisegred_nonseg_21830_total_runtime /
                    (ctx->testzisegred_nonseg_21830_runs !=
                     0 ? ctx->testzisegred_nonseg_21830_runs : 1),
                    (long) ctx->testzisegred_nonseg_21830_total_runtime);
        ctx->total_runtime += ctx->testzisegred_nonseg_21830_total_runtime;
        ctx->total_runs += ctx->testzisegred_nonseg_21830_runs;
        str_builder(&builder,
                    "test.segred_nonseg_22685         ran %5d times; avg: %8ldus; total: %8ldus\n",
                    ctx->testzisegred_nonseg_22685_runs,
                    (long) ctx->testzisegred_nonseg_22685_total_runtime /
                    (ctx->testzisegred_nonseg_22685_runs !=
                     0 ? ctx->testzisegred_nonseg_22685_runs : 1),
                    (long) ctx->testzisegred_nonseg_22685_total_runtime);
        ctx->total_runtime += ctx->testzisegred_nonseg_22685_total_runtime;
        ctx->total_runs += ctx->testzisegred_nonseg_22685_runs;
        str_builder(&builder,
                    "test.segred_nonseg_23431         ran %5d times; avg: %8ldus; total: %8ldus\n",
                    ctx->testzisegred_nonseg_23431_runs,
                    (long) ctx->testzisegred_nonseg_23431_total_runtime /
                    (ctx->testzisegred_nonseg_23431_runs !=
                     0 ? ctx->testzisegred_nonseg_23431_runs : 1),
                    (long) ctx->testzisegred_nonseg_23431_total_runtime);
        ctx->total_runtime += ctx->testzisegred_nonseg_23431_total_runtime;
        ctx->total_runs += ctx->testzisegred_nonseg_23431_runs;
        str_builder(&builder,
                    "test.segred_nonseg_23463         ran %5d times; avg: %8ldus; total: %8ldus\n",
                    ctx->testzisegred_nonseg_23463_runs,
                    (long) ctx->testzisegred_nonseg_23463_total_runtime /
                    (ctx->testzisegred_nonseg_23463_runs !=
                     0 ? ctx->testzisegred_nonseg_23463_runs : 1),
                    (long) ctx->testzisegred_nonseg_23463_total_runtime);
        ctx->total_runtime += ctx->testzisegred_nonseg_23463_total_runtime;
        ctx->total_runs += ctx->testzisegred_nonseg_23463_runs;
        str_builder(&builder,
                    "test.segred_small_22416          ran %5d times; avg: %8ldus; total: %8ldus\n",
                    ctx->testzisegred_small_22416_runs,
                    (long) ctx->testzisegred_small_22416_total_runtime /
                    (ctx->testzisegred_small_22416_runs !=
                     0 ? ctx->testzisegred_small_22416_runs : 1),
                    (long) ctx->testzisegred_small_22416_total_runtime);
        ctx->total_runtime += ctx->testzisegred_small_22416_total_runtime;
        ctx->total_runs += ctx->testzisegred_small_22416_runs;
        str_builder(&builder, "%d operations with cumulative runtime: %6ldus\n",
                    ctx->total_runs, ctx->total_runtime);
    }
    return builder.str;
}
char *futhark_context_get_error(struct futhark_context *ctx)
{
    char *error = ctx->error;
    
    ctx->error = NULL;
    return error;
}
void futhark_context_pause_profiling(struct futhark_context *ctx)
{
    ctx->profiling_paused = 1;
}
void futhark_context_unpause_profiling(struct futhark_context *ctx)
{
    ctx->profiling_paused = 0;
}
static int futrts_builtinzhgpu_map_transpose_f32(struct futhark_context *ctx,
                                                 struct memblock_device destmem_0,
                                                 int32_t destoffset_1,
                                                 struct memblock_device srcmem_2,
                                                 int32_t srcoffset_3,
                                                 int32_t num_arrays_4,
                                                 int32_t x_elems_5,
                                                 int32_t y_elems_6);
static int futrts_main(struct futhark_context *ctx, float *out_scalar_out_23799,
                       struct memblock_device *out_mem_p_23800,
                       int64_t *out_out_arrsizze_23801,
                       struct memblock_device swap_term_mem_23220,
                       struct memblock_device payments_mem_23221,
                       struct memblock_device notional_mem_23222,
                       int64_t n_18078, int64_t n_18079, int64_t n_18080,
                       int64_t paths_18081, int64_t steps_18082, float a_18086,
                       float b_18087, float sigma_18088, float r0_18089);
static int futrts_test(struct futhark_context *ctx, float *out_scalar_out_23888,
                       int64_t paths_18528, int64_t steps_18529);
int init_constants(struct futhark_context *ctx)
{
    (void) ctx;
    
    int err = 0;
    
    
  cleanup:
    return err;
}
int free_constants(struct futhark_context *ctx)
{
    (void) ctx;
    return 0;
}
static int futrts_builtinzhgpu_map_transpose_f32(struct futhark_context *ctx,
                                                 struct memblock_device destmem_0,
                                                 int32_t destoffset_1,
                                                 struct memblock_device srcmem_2,
                                                 int32_t srcoffset_3,
                                                 int32_t num_arrays_4,
                                                 int32_t x_elems_5,
                                                 int32_t y_elems_6)
{
    (void) ctx;
    
    int err = 0;
    
    if (!(num_arrays_4 == 0 || (x_elems_5 == 0 || y_elems_6 == 0))) {
        int32_t muly_8 = squot32(16, x_elems_5);
        int32_t mulx_7 = squot32(16, y_elems_6);
        
        if (num_arrays_4 == 1 && (x_elems_5 == 1 || y_elems_6 == 1)) {
            if (sext_i32_i64(x_elems_5 * y_elems_6 * (int32_t) sizeof(float)) >
                0) {
                OPENCL_SUCCEED_OR_RETURN(clEnqueueCopyBuffer(ctx->opencl.queue,
                                                             srcmem_2.mem,
                                                             destmem_0.mem,
                                                             sext_i32_i64(srcoffset_3),
                                                             sext_i32_i64(destoffset_1),
                                                             sext_i32_i64(x_elems_5 *
                                                             y_elems_6 *
                                                             (int32_t) sizeof(float)),
                                                             0, NULL,
                                                             ctx->profiling_paused ||
                                                             !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                                       &ctx->copy_dev_to_dev_runs,
                                                                                                       &ctx->copy_dev_to_dev_total_runtime)));
                if (ctx->debugging)
                    OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
            }
        } else {
            if (sle32(x_elems_5, 8) && slt32(16, y_elems_6)) {
                OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->gpu_map_transpose_f32_low_width,
                                                        0, 1088, NULL));
                OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->gpu_map_transpose_f32_low_width,
                                                        1, sizeof(destoffset_1),
                                                        &destoffset_1));
                OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->gpu_map_transpose_f32_low_width,
                                                        2, sizeof(srcoffset_3),
                                                        &srcoffset_3));
                OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->gpu_map_transpose_f32_low_width,
                                                        3, sizeof(num_arrays_4),
                                                        &num_arrays_4));
                OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->gpu_map_transpose_f32_low_width,
                                                        4, sizeof(x_elems_5),
                                                        &x_elems_5));
                OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->gpu_map_transpose_f32_low_width,
                                                        5, sizeof(y_elems_6),
                                                        &y_elems_6));
                OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->gpu_map_transpose_f32_low_width,
                                                        6, sizeof(mulx_7),
                                                        &mulx_7));
                OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->gpu_map_transpose_f32_low_width,
                                                        7, sizeof(muly_8),
                                                        &muly_8));
                OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->gpu_map_transpose_f32_low_width,
                                                        8,
                                                        sizeof(destmem_0.mem),
                                                        &destmem_0.mem));
                OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->gpu_map_transpose_f32_low_width,
                                                        9, sizeof(srcmem_2.mem),
                                                        &srcmem_2.mem));
                if (1 * ((size_t) sdiv_up32(x_elems_5, 16) * (size_t) 16) *
                    ((size_t) sdiv_up32(sdiv_up32(y_elems_6, muly_8), 16) *
                     (size_t) 16) * ((size_t) num_arrays_4 * (size_t) 1) != 0) {
                    const size_t global_work_sizze_23779[3] =
                                 {(size_t) sdiv_up32(x_elems_5, 16) *
                                  (size_t) 16,
                                  (size_t) sdiv_up32(sdiv_up32(y_elems_6,
                                                               muly_8), 16) *
                                  (size_t) 16, (size_t) num_arrays_4 *
                                  (size_t) 1};
                    const size_t local_work_sizze_23783[3] = {16, 16, 1};
                    int64_t time_start_23780 = 0, time_end_23781 = 0;
                    
                    if (ctx->debugging) {
                        fprintf(stderr, "Launching %s with global work size [",
                                "gpu_map_transpose_f32_low_width");
                        fprintf(stderr, "%zu", global_work_sizze_23779[0]);
                        fprintf(stderr, ", ");
                        fprintf(stderr, "%zu", global_work_sizze_23779[1]);
                        fprintf(stderr, ", ");
                        fprintf(stderr, "%zu", global_work_sizze_23779[2]);
                        fprintf(stderr, "] and local work size [");
                        fprintf(stderr, "%zu", local_work_sizze_23783[0]);
                        fprintf(stderr, ", ");
                        fprintf(stderr, "%zu", local_work_sizze_23783[1]);
                        fprintf(stderr, ", ");
                        fprintf(stderr, "%zu", local_work_sizze_23783[2]);
                        fprintf(stderr,
                                "]; local memory parameters sum to %d bytes.\n",
                                (int) (0 + 1088));
                        time_start_23780 = get_wall_time();
                    }
                    OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->opencl.queue,
                                                                    ctx->gpu_map_transpose_f32_low_width,
                                                                    3, NULL,
                                                                    global_work_sizze_23779,
                                                                    local_work_sizze_23783,
                                                                    0, NULL,
                                                                    ctx->profiling_paused ||
                                                                    !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                                              &ctx->gpu_map_transpose_f32_low_width_runs,
                                                                                                              &ctx->gpu_map_transpose_f32_low_width_total_runtime)));
                    if (ctx->debugging) {
                        OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
                        time_end_23781 = get_wall_time();
                        
                        long time_diff_23782 = time_end_23781 -
                             time_start_23780;
                        
                        fprintf(stderr, "kernel %s runtime: %ldus\n",
                                "gpu_map_transpose_f32_low_width",
                                time_diff_23782);
                    }
                }
            } else {
                if (sle32(y_elems_6, 8) && slt32(16, x_elems_5)) {
                    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->gpu_map_transpose_f32_low_height,
                                                            0, 1088, NULL));
                    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->gpu_map_transpose_f32_low_height,
                                                            1,
                                                            sizeof(destoffset_1),
                                                            &destoffset_1));
                    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->gpu_map_transpose_f32_low_height,
                                                            2,
                                                            sizeof(srcoffset_3),
                                                            &srcoffset_3));
                    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->gpu_map_transpose_f32_low_height,
                                                            3,
                                                            sizeof(num_arrays_4),
                                                            &num_arrays_4));
                    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->gpu_map_transpose_f32_low_height,
                                                            4,
                                                            sizeof(x_elems_5),
                                                            &x_elems_5));
                    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->gpu_map_transpose_f32_low_height,
                                                            5,
                                                            sizeof(y_elems_6),
                                                            &y_elems_6));
                    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->gpu_map_transpose_f32_low_height,
                                                            6, sizeof(mulx_7),
                                                            &mulx_7));
                    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->gpu_map_transpose_f32_low_height,
                                                            7, sizeof(muly_8),
                                                            &muly_8));
                    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->gpu_map_transpose_f32_low_height,
                                                            8,
                                                            sizeof(destmem_0.mem),
                                                            &destmem_0.mem));
                    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->gpu_map_transpose_f32_low_height,
                                                            9,
                                                            sizeof(srcmem_2.mem),
                                                            &srcmem_2.mem));
                    if (1 * ((size_t) sdiv_up32(sdiv_up32(x_elems_5, mulx_7),
                                                16) * (size_t) 16) *
                        ((size_t) sdiv_up32(y_elems_6, 16) * (size_t) 16) *
                        ((size_t) num_arrays_4 * (size_t) 1) != 0) {
                        const size_t global_work_sizze_23784[3] =
                                     {(size_t) sdiv_up32(sdiv_up32(x_elems_5,
                                                                   mulx_7),
                                                         16) * (size_t) 16,
                                      (size_t) sdiv_up32(y_elems_6, 16) *
                                      (size_t) 16, (size_t) num_arrays_4 *
                                      (size_t) 1};
                        const size_t local_work_sizze_23788[3] = {16, 16, 1};
                        int64_t time_start_23785 = 0, time_end_23786 = 0;
                        
                        if (ctx->debugging) {
                            fprintf(stderr,
                                    "Launching %s with global work size [",
                                    "gpu_map_transpose_f32_low_height");
                            fprintf(stderr, "%zu", global_work_sizze_23784[0]);
                            fprintf(stderr, ", ");
                            fprintf(stderr, "%zu", global_work_sizze_23784[1]);
                            fprintf(stderr, ", ");
                            fprintf(stderr, "%zu", global_work_sizze_23784[2]);
                            fprintf(stderr, "] and local work size [");
                            fprintf(stderr, "%zu", local_work_sizze_23788[0]);
                            fprintf(stderr, ", ");
                            fprintf(stderr, "%zu", local_work_sizze_23788[1]);
                            fprintf(stderr, ", ");
                            fprintf(stderr, "%zu", local_work_sizze_23788[2]);
                            fprintf(stderr,
                                    "]; local memory parameters sum to %d bytes.\n",
                                    (int) (0 + 1088));
                            time_start_23785 = get_wall_time();
                        }
                        OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->opencl.queue,
                                                                        ctx->gpu_map_transpose_f32_low_height,
                                                                        3, NULL,
                                                                        global_work_sizze_23784,
                                                                        local_work_sizze_23788,
                                                                        0, NULL,
                                                                        ctx->profiling_paused ||
                                                                        !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                                                  &ctx->gpu_map_transpose_f32_low_height_runs,
                                                                                                                  &ctx->gpu_map_transpose_f32_low_height_total_runtime)));
                        if (ctx->debugging) {
                            OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
                            time_end_23786 = get_wall_time();
                            
                            long time_diff_23787 = time_end_23786 -
                                 time_start_23785;
                            
                            fprintf(stderr, "kernel %s runtime: %ldus\n",
                                    "gpu_map_transpose_f32_low_height",
                                    time_diff_23787);
                        }
                    }
                } else {
                    if (sle32(x_elems_5, 8) && sle32(y_elems_6, 8)) {
                        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->gpu_map_transpose_f32_small,
                                                                0, 1, NULL));
                        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->gpu_map_transpose_f32_small,
                                                                1,
                                                                sizeof(destoffset_1),
                                                                &destoffset_1));
                        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->gpu_map_transpose_f32_small,
                                                                2,
                                                                sizeof(srcoffset_3),
                                                                &srcoffset_3));
                        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->gpu_map_transpose_f32_small,
                                                                3,
                                                                sizeof(num_arrays_4),
                                                                &num_arrays_4));
                        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->gpu_map_transpose_f32_small,
                                                                4,
                                                                sizeof(x_elems_5),
                                                                &x_elems_5));
                        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->gpu_map_transpose_f32_small,
                                                                5,
                                                                sizeof(y_elems_6),
                                                                &y_elems_6));
                        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->gpu_map_transpose_f32_small,
                                                                6,
                                                                sizeof(mulx_7),
                                                                &mulx_7));
                        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->gpu_map_transpose_f32_small,
                                                                7,
                                                                sizeof(muly_8),
                                                                &muly_8));
                        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->gpu_map_transpose_f32_small,
                                                                8,
                                                                sizeof(destmem_0.mem),
                                                                &destmem_0.mem));
                        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->gpu_map_transpose_f32_small,
                                                                9,
                                                                sizeof(srcmem_2.mem),
                                                                &srcmem_2.mem));
                        if (1 * ((size_t) sdiv_up32(num_arrays_4 * x_elems_5 *
                                                    y_elems_6, 256) *
                                 (size_t) 256) != 0) {
                            const size_t global_work_sizze_23789[1] =
                                         {(size_t) sdiv_up32(num_arrays_4 *
                                                             x_elems_5 *
                                                             y_elems_6, 256) *
                                         (size_t) 256};
                            const size_t local_work_sizze_23793[1] = {256};
                            int64_t time_start_23790 = 0, time_end_23791 = 0;
                            
                            if (ctx->debugging) {
                                fprintf(stderr,
                                        "Launching %s with global work size [",
                                        "gpu_map_transpose_f32_small");
                                fprintf(stderr, "%zu",
                                        global_work_sizze_23789[0]);
                                fprintf(stderr, "] and local work size [");
                                fprintf(stderr, "%zu",
                                        local_work_sizze_23793[0]);
                                fprintf(stderr,
                                        "]; local memory parameters sum to %d bytes.\n",
                                        (int) (0 + 1));
                                time_start_23790 = get_wall_time();
                            }
                            OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->opencl.queue,
                                                                            ctx->gpu_map_transpose_f32_small,
                                                                            1,
                                                                            NULL,
                                                                            global_work_sizze_23789,
                                                                            local_work_sizze_23793,
                                                                            0,
                                                                            NULL,
                                                                            ctx->profiling_paused ||
                                                                            !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                                                      &ctx->gpu_map_transpose_f32_small_runs,
                                                                                                                      &ctx->gpu_map_transpose_f32_small_total_runtime)));
                            if (ctx->debugging) {
                                OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
                                time_end_23791 = get_wall_time();
                                
                                long time_diff_23792 = time_end_23791 -
                                     time_start_23790;
                                
                                fprintf(stderr, "kernel %s runtime: %ldus\n",
                                        "gpu_map_transpose_f32_small",
                                        time_diff_23792);
                            }
                        }
                    } else {
                        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->gpu_map_transpose_f32,
                                                                0, 4224, NULL));
                        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->gpu_map_transpose_f32,
                                                                1,
                                                                sizeof(destoffset_1),
                                                                &destoffset_1));
                        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->gpu_map_transpose_f32,
                                                                2,
                                                                sizeof(srcoffset_3),
                                                                &srcoffset_3));
                        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->gpu_map_transpose_f32,
                                                                3,
                                                                sizeof(num_arrays_4),
                                                                &num_arrays_4));
                        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->gpu_map_transpose_f32,
                                                                4,
                                                                sizeof(x_elems_5),
                                                                &x_elems_5));
                        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->gpu_map_transpose_f32,
                                                                5,
                                                                sizeof(y_elems_6),
                                                                &y_elems_6));
                        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->gpu_map_transpose_f32,
                                                                6,
                                                                sizeof(mulx_7),
                                                                &mulx_7));
                        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->gpu_map_transpose_f32,
                                                                7,
                                                                sizeof(muly_8),
                                                                &muly_8));
                        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->gpu_map_transpose_f32,
                                                                8,
                                                                sizeof(destmem_0.mem),
                                                                &destmem_0.mem));
                        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->gpu_map_transpose_f32,
                                                                9,
                                                                sizeof(srcmem_2.mem),
                                                                &srcmem_2.mem));
                        if (1 * ((size_t) sdiv_up32(x_elems_5, 32) *
                                 (size_t) 32) * ((size_t) sdiv_up32(y_elems_6,
                                                                    32) *
                                                 (size_t) 8) *
                            ((size_t) num_arrays_4 * (size_t) 1) != 0) {
                            const size_t global_work_sizze_23794[3] =
                                         {(size_t) sdiv_up32(x_elems_5, 32) *
                                          (size_t) 32,
                                          (size_t) sdiv_up32(y_elems_6, 32) *
                                          (size_t) 8, (size_t) num_arrays_4 *
                                          (size_t) 1};
                            const size_t local_work_sizze_23798[3] = {32, 8, 1};
                            int64_t time_start_23795 = 0, time_end_23796 = 0;
                            
                            if (ctx->debugging) {
                                fprintf(stderr,
                                        "Launching %s with global work size [",
                                        "gpu_map_transpose_f32");
                                fprintf(stderr, "%zu",
                                        global_work_sizze_23794[0]);
                                fprintf(stderr, ", ");
                                fprintf(stderr, "%zu",
                                        global_work_sizze_23794[1]);
                                fprintf(stderr, ", ");
                                fprintf(stderr, "%zu",
                                        global_work_sizze_23794[2]);
                                fprintf(stderr, "] and local work size [");
                                fprintf(stderr, "%zu",
                                        local_work_sizze_23798[0]);
                                fprintf(stderr, ", ");
                                fprintf(stderr, "%zu",
                                        local_work_sizze_23798[1]);
                                fprintf(stderr, ", ");
                                fprintf(stderr, "%zu",
                                        local_work_sizze_23798[2]);
                                fprintf(stderr,
                                        "]; local memory parameters sum to %d bytes.\n",
                                        (int) (0 + 4224));
                                time_start_23795 = get_wall_time();
                            }
                            OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->opencl.queue,
                                                                            ctx->gpu_map_transpose_f32,
                                                                            3,
                                                                            NULL,
                                                                            global_work_sizze_23794,
                                                                            local_work_sizze_23798,
                                                                            0,
                                                                            NULL,
                                                                            ctx->profiling_paused ||
                                                                            !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                                                      &ctx->gpu_map_transpose_f32_runs,
                                                                                                                      &ctx->gpu_map_transpose_f32_total_runtime)));
                            if (ctx->debugging) {
                                OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
                                time_end_23796 = get_wall_time();
                                
                                long time_diff_23797 = time_end_23796 -
                                     time_start_23795;
                                
                                fprintf(stderr, "kernel %s runtime: %ldus\n",
                                        "gpu_map_transpose_f32",
                                        time_diff_23797);
                            }
                        }
                    }
                }
            }
        }
    }
    
  cleanup:
    { }
    return err;
}
static int futrts_main(struct futhark_context *ctx, float *out_scalar_out_23799,
                       struct memblock_device *out_mem_p_23800,
                       int64_t *out_out_arrsizze_23801,
                       struct memblock_device swap_term_mem_23220,
                       struct memblock_device payments_mem_23221,
                       struct memblock_device notional_mem_23222,
                       int64_t n_18078, int64_t n_18079, int64_t n_18080,
                       int64_t paths_18081, int64_t steps_18082, float a_18086,
                       float b_18087, float sigma_18088, float r0_18089)
{
    (void) ctx;
    
    int err = 0;
    float scalar_out_23489;
    struct memblock_device out_mem_23490;
    
    out_mem_23490.references = NULL;
    
    int64_t out_arrsizze_23491;
    bool dim_match_18090 = n_18078 == n_18079;
    bool empty_or_match_cert_18091;
    
    if (!dim_match_18090) {
        ctx->error = msgprintf("Error: %s\n\nBacktrace:\n%s",
                               "function arguments of wrong shape",
                               "-> #0  cvaold.fut:100:1-160:20\n");
        if (memblock_unref_device(ctx, &out_mem_23490, "out_mem_23490") != 0)
            return 1;
        return 1;
    }
    
    int64_t segred_group_sizze_18840;
    
    segred_group_sizze_18840 = ctx->sizes.mainzisegred_group_sizze_18839;
    
    int64_t num_groups_18842;
    int32_t max_num_groups_23492;
    
    max_num_groups_23492 = ctx->sizes.mainzisegred_num_groups_18841;
    num_groups_18842 = sext_i64_i32(smax64(1, smin64(sdiv_up64(n_18078,
                                                               sext_i32_i64(segred_group_sizze_18840)),
                                                     sext_i32_i64(max_num_groups_23492))));
    
    struct memblock_device mem_23225;
    
    mem_23225.references = NULL;
    if (memblock_alloc_device(ctx, &mem_23225, 4, "mem_23225")) {
        err = 1;
        goto cleanup;
    }
    
    struct memblock_device mainzicounter_mem_23493 =
                           ctx->mainzicounter_mem_23493;
    struct memblock_device group_res_arr_mem_23495;
    
    group_res_arr_mem_23495.references = NULL;
    if (memblock_alloc_device(ctx, &group_res_arr_mem_23495,
                              (int32_t) sizeof(float) *
                              (segred_group_sizze_18840 * num_groups_18842),
                              "group_res_arr_mem_23495")) {
        err = 1;
        goto cleanup;
    }
    
    int64_t num_threads_23497;
    
    num_threads_23497 = num_groups_18842 * segred_group_sizze_18840;
    if (ctx->debugging)
        fprintf(stderr, "%s\n", "\n# SegRed");
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_nonseg_18847, 1,
                                            (int32_t) sizeof(float) *
                                            segred_group_sizze_18840, NULL));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_nonseg_18847, 2,
                                            (int32_t) sizeof(bool), NULL));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_nonseg_18847, 3,
                                            sizeof(n_18078), &n_18078));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_nonseg_18847, 4,
                                            sizeof(num_groups_18842),
                                            &num_groups_18842));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_nonseg_18847, 5,
                                            sizeof(swap_term_mem_23220.mem),
                                            &swap_term_mem_23220.mem));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_nonseg_18847, 6,
                                            sizeof(payments_mem_23221.mem),
                                            &payments_mem_23221.mem));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_nonseg_18847, 7,
                                            sizeof(mem_23225.mem),
                                            &mem_23225.mem));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_nonseg_18847, 8,
                                            sizeof(mainzicounter_mem_23493.mem),
                                            &mainzicounter_mem_23493.mem));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_nonseg_18847, 9,
                                            sizeof(group_res_arr_mem_23495.mem),
                                            &group_res_arr_mem_23495.mem));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_nonseg_18847, 10,
                                            sizeof(num_threads_23497),
                                            &num_threads_23497));
    if (1 * ((size_t) num_groups_18842 * (size_t) segred_group_sizze_18840) !=
        0) {
        const size_t global_work_sizze_23803[1] = {(size_t) num_groups_18842 *
                     (size_t) segred_group_sizze_18840};
        const size_t local_work_sizze_23807[1] = {segred_group_sizze_18840};
        int64_t time_start_23804 = 0, time_end_23805 = 0;
        
        if (ctx->debugging) {
            fprintf(stderr, "Launching %s with global work size [",
                    "main.segred_nonseg_18847");
            fprintf(stderr, "%zu", global_work_sizze_23803[0]);
            fprintf(stderr, "] and local work size [");
            fprintf(stderr, "%zu", local_work_sizze_23807[0]);
            fprintf(stderr, "]; local memory parameters sum to %d bytes.\n",
                    (int) (0 + (int32_t) sizeof(float) *
                           segred_group_sizze_18840 + (int32_t) sizeof(bool)));
            time_start_23804 = get_wall_time();
        }
        OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->opencl.queue,
                                                        ctx->mainzisegred_nonseg_18847,
                                                        1, NULL,
                                                        global_work_sizze_23803,
                                                        local_work_sizze_23807,
                                                        0, NULL,
                                                        ctx->profiling_paused ||
                                                        !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                                  &ctx->mainzisegred_nonseg_18847_runs,
                                                                                                  &ctx->mainzisegred_nonseg_18847_total_runtime)));
        if (ctx->debugging) {
            OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
            time_end_23805 = get_wall_time();
            
            long time_diff_23806 = time_end_23805 - time_start_23804;
            
            fprintf(stderr, "kernel %s runtime: %ldus\n",
                    "main.segred_nonseg_18847", time_diff_23806);
        }
    }
    
    float read_res_23808;
    
    OPENCL_SUCCEED_OR_RETURN(clEnqueueReadBuffer(ctx->opencl.queue,
                                                 mem_23225.mem,
                                                 ctx->failure_is_an_option ? CL_FALSE : CL_TRUE,
                                                 0 * sizeof(float),
                                                 sizeof(float), &read_res_23808,
                                                 0, NULL,
                                                 ctx->profiling_paused ||
                                                 !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                           &ctx->copy_scalar_from_dev_runs,
                                                                                           &ctx->copy_scalar_from_dev_total_runtime)));
    if (ctx->failure_is_an_option && futhark_context_sync(ctx) != 0)
        return 1;
    
    float res_18095 = read_res_23808;
    
    if (memblock_unref_device(ctx, &mem_23225, "mem_23225") != 0)
        return 1;
    
    float res_18103 = sitofp_i64_f32(steps_18082);
    float dt_18104 = res_18095 / res_18103;
    float x_18106 = fpow32(a_18086, 2.0F);
    float x_18107 = b_18087 * x_18106;
    float x_18108 = fpow32(sigma_18088, 2.0F);
    float y_18109 = x_18108 / 2.0F;
    float y_18110 = x_18107 - y_18109;
    float y_18111 = 4.0F * a_18086;
    bool suff_outer_par_18849;
    
    suff_outer_par_18849 = ctx->sizes.mainzisuff_outer_par_0 <= n_18078;
    if (ctx->logging)
        fprintf(stderr, "Compared %s <= %d.\n", "main.suff_outer_par_0",
                n_18078);
    
    int64_t segmap_group_sizze_18939;
    
    segmap_group_sizze_18939 = ctx->sizes.mainzisegmap_group_sizze_18863;
    
    int64_t segmap_group_sizze_19115;
    
    segmap_group_sizze_19115 = ctx->sizes.mainzisegmap_group_sizze_19039;
    
    int64_t bytes_23226 = 4 * n_18078;
    int64_t bytes_23228 = 8 * n_18078;
    int64_t segred_num_groups_23350;
    
    segred_num_groups_23350 = ctx->sizes.mainzisegred_num_groups_23349;
    
    int64_t segred_group_sizze_23352;
    
    segred_group_sizze_23352 = ctx->sizes.mainzisegred_group_sizze_23351;
    
    int64_t segred_num_groups_23382;
    
    segred_num_groups_23382 = ctx->sizes.mainzisegred_num_groups_23381;
    
    int64_t segred_group_sizze_23384;
    
    segred_group_sizze_23384 = ctx->sizes.mainzisegred_group_sizze_23383;
    
    struct memblock_device res_mem_23272;
    
    res_mem_23272.references = NULL;
    
    struct memblock_device res_mem_23273;
    
    res_mem_23273.references = NULL;
    
    struct memblock_device res_mem_23274;
    
    res_mem_23274.references = NULL;
    
    struct memblock_device res_mem_23275;
    
    res_mem_23275.references = NULL;
    
    int32_t local_memory_capacity_23597;
    
    local_memory_capacity_23597 = ctx->opencl.max_local_memory;
    if ((sle64((int32_t) sizeof(bool) + (int32_t) sizeof(int64_t) *
               segred_group_sizze_23352,
               sext_i32_i64(local_memory_capacity_23597)) && sle64(0,
                                                                   sext_i32_i64(local_memory_capacity_23597))) &&
        suff_outer_par_18849) {
        int64_t segmap_usable_groups_18940 = sdiv_up64(n_18078,
                                                       segmap_group_sizze_18939);
        struct memblock_device mem_23227;
        
        mem_23227.references = NULL;
        if (memblock_alloc_device(ctx, &mem_23227, bytes_23226, "mem_23227")) {
            err = 1;
            goto cleanup;
        }
        if (n_18078 * (int32_t) sizeof(float) > 0) {
            OPENCL_SUCCEED_OR_RETURN(clEnqueueCopyBuffer(ctx->opencl.queue,
                                                         swap_term_mem_23220.mem,
                                                         mem_23227.mem, 0, 0,
                                                         n_18078 *
                                                         (int32_t) sizeof(float),
                                                         0, NULL,
                                                         ctx->profiling_paused ||
                                                         !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                                   &ctx->copy_dev_to_dev_runs,
                                                                                                   &ctx->copy_dev_to_dev_total_runtime)));
            if (ctx->debugging)
                OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
        }
        
        struct memblock_device mem_23229;
        
        mem_23229.references = NULL;
        if (memblock_alloc_device(ctx, &mem_23229, bytes_23228, "mem_23229")) {
            err = 1;
            goto cleanup;
        }
        if (n_18078 * (int32_t) sizeof(int64_t) > 0) {
            OPENCL_SUCCEED_OR_RETURN(clEnqueueCopyBuffer(ctx->opencl.queue,
                                                         payments_mem_23221.mem,
                                                         mem_23229.mem, 0, 0,
                                                         n_18078 *
                                                         (int32_t) sizeof(int64_t),
                                                         0, NULL,
                                                         ctx->profiling_paused ||
                                                         !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                                   &ctx->copy_dev_to_dev_runs,
                                                                                                   &ctx->copy_dev_to_dev_total_runtime)));
            if (ctx->debugging)
                OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
        }
        
        struct memblock_device mem_23231;
        
        mem_23231.references = NULL;
        if (memblock_alloc_device(ctx, &mem_23231, bytes_23226, "mem_23231")) {
            err = 1;
            goto cleanup;
        }
        if (n_18078 * (int32_t) sizeof(float) > 0) {
            OPENCL_SUCCEED_OR_RETURN(clEnqueueCopyBuffer(ctx->opencl.queue,
                                                         notional_mem_23222.mem,
                                                         mem_23231.mem, 0, 0,
                                                         n_18078 *
                                                         (int32_t) sizeof(float),
                                                         0, NULL,
                                                         ctx->profiling_paused ||
                                                         !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                                   &ctx->copy_dev_to_dev_runs,
                                                                                                   &ctx->copy_dev_to_dev_total_runtime)));
            if (ctx->debugging)
                OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
        }
        
        struct memblock_device mem_23248;
        
        mem_23248.references = NULL;
        if (memblock_alloc_device(ctx, &mem_23248, bytes_23226, "mem_23248")) {
            err = 1;
            goto cleanup;
        }
        
        int64_t num_threads_23340 = segmap_group_sizze_18939 *
                segmap_usable_groups_18940;
        struct memblock_device mem_23368;
        
        mem_23368.references = NULL;
        if (memblock_alloc_device(ctx, &mem_23368, 8, "mem_23368")) {
            err = 1;
            goto cleanup;
        }
        
        struct memblock_device mainzicounter_mem_23523 =
                               ctx->mainzicounter_mem_23523;
        struct memblock_device group_res_arr_mem_23525;
        
        group_res_arr_mem_23525.references = NULL;
        if (memblock_alloc_device(ctx, &group_res_arr_mem_23525,
                                  (int32_t) sizeof(int64_t) *
                                  (segred_group_sizze_23352 *
                                   segred_num_groups_23350),
                                  "group_res_arr_mem_23525")) {
            err = 1;
            goto cleanup;
        }
        
        int64_t num_threads_23527;
        
        num_threads_23527 = segred_num_groups_23350 * segred_group_sizze_23352;
        if (ctx->debugging)
            fprintf(stderr, "%s\n", "\n# SegRed");
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_nonseg_23356,
                                                1, (int32_t) sizeof(int64_t) *
                                                segred_group_sizze_23352,
                                                NULL));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_nonseg_23356,
                                                2, (int32_t) sizeof(bool),
                                                NULL));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_nonseg_23356,
                                                3, sizeof(n_18078), &n_18078));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_nonseg_23356,
                                                4,
                                                sizeof(payments_mem_23221.mem),
                                                &payments_mem_23221.mem));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_nonseg_23356,
                                                5, sizeof(mem_23368.mem),
                                                &mem_23368.mem));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_nonseg_23356,
                                                6,
                                                sizeof(mainzicounter_mem_23523.mem),
                                                &mainzicounter_mem_23523.mem));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_nonseg_23356,
                                                7,
                                                sizeof(group_res_arr_mem_23525.mem),
                                                &group_res_arr_mem_23525.mem));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_nonseg_23356,
                                                8, sizeof(num_threads_23527),
                                                &num_threads_23527));
        if (1 * ((size_t) segred_num_groups_23350 *
                 (size_t) segred_group_sizze_23352) != 0) {
            const size_t global_work_sizze_23810[1] =
                         {(size_t) segred_num_groups_23350 *
                         (size_t) segred_group_sizze_23352};
            const size_t local_work_sizze_23814[1] = {segred_group_sizze_23352};
            int64_t time_start_23811 = 0, time_end_23812 = 0;
            
            if (ctx->debugging) {
                fprintf(stderr, "Launching %s with global work size [",
                        "main.segred_nonseg_23356");
                fprintf(stderr, "%zu", global_work_sizze_23810[0]);
                fprintf(stderr, "] and local work size [");
                fprintf(stderr, "%zu", local_work_sizze_23814[0]);
                fprintf(stderr, "]; local memory parameters sum to %d bytes.\n",
                        (int) (0 + (int32_t) sizeof(int64_t) *
                               segred_group_sizze_23352 +
                               (int32_t) sizeof(bool)));
                time_start_23811 = get_wall_time();
            }
            OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->opencl.queue,
                                                            ctx->mainzisegred_nonseg_23356,
                                                            1, NULL,
                                                            global_work_sizze_23810,
                                                            local_work_sizze_23814,
                                                            0, NULL,
                                                            ctx->profiling_paused ||
                                                            !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                                      &ctx->mainzisegred_nonseg_23356_runs,
                                                                                                      &ctx->mainzisegred_nonseg_23356_total_runtime)));
            if (ctx->debugging) {
                OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
                time_end_23812 = get_wall_time();
                
                long time_diff_23813 = time_end_23812 - time_start_23811;
                
                fprintf(stderr, "kernel %s runtime: %ldus\n",
                        "main.segred_nonseg_23356", time_diff_23813);
            }
        }
        
        int64_t read_res_23815;
        
        OPENCL_SUCCEED_OR_RETURN(clEnqueueReadBuffer(ctx->opencl.queue,
                                                     mem_23368.mem,
                                                     ctx->failure_is_an_option ? CL_FALSE : CL_TRUE,
                                                     0 * sizeof(int64_t),
                                                     sizeof(int64_t),
                                                     &read_res_23815, 0, NULL,
                                                     ctx->profiling_paused ||
                                                     !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                               &ctx->copy_scalar_from_dev_runs,
                                                                                               &ctx->copy_scalar_from_dev_total_runtime)));
        if (ctx->failure_is_an_option && futhark_context_sync(ctx) != 0)
            return 1;
        
        int64_t max_per_thread_23346 = read_res_23815;
        
        if (memblock_unref_device(ctx, &mem_23368, "mem_23368") != 0)
            return 1;
        
        int64_t sizze_sum_23363 = num_threads_23340 * max_per_thread_23346;
        struct memblock_device mem_23234;
        
        mem_23234.references = NULL;
        if (memblock_alloc_device(ctx, &mem_23234, sizze_sum_23363,
                                  "mem_23234")) {
            err = 1;
            goto cleanup;
        }
        if (ctx->debugging)
            fprintf(stderr, "%s\n", "\n# SegMap");
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_18861, 1,
                                                sizeof(ctx->failure_is_an_option),
                                                &ctx->failure_is_an_option));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_18861, 3,
                                                sizeof(n_18078), &n_18078));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_18861, 4,
                                                sizeof(a_18086), &a_18086));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_18861, 5,
                                                sizeof(r0_18089), &r0_18089));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_18861, 6,
                                                sizeof(x_18106), &x_18106));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_18861, 7,
                                                sizeof(x_18108), &x_18108));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_18861, 8,
                                                sizeof(y_18110), &y_18110));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_18861, 9,
                                                sizeof(y_18111), &y_18111));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_18861, 10,
                                                sizeof(swap_term_mem_23220.mem),
                                                &swap_term_mem_23220.mem));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_18861, 11,
                                                sizeof(payments_mem_23221.mem),
                                                &payments_mem_23221.mem));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_18861, 12,
                                                sizeof(mem_23234.mem),
                                                &mem_23234.mem));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_18861, 13,
                                                sizeof(mem_23248.mem),
                                                &mem_23248.mem));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_18861, 14,
                                                sizeof(num_threads_23340),
                                                &num_threads_23340));
        if (1 * ((size_t) segmap_usable_groups_18940 *
                 (size_t) segmap_group_sizze_18939) != 0) {
            const size_t global_work_sizze_23816[1] =
                         {(size_t) segmap_usable_groups_18940 *
                         (size_t) segmap_group_sizze_18939};
            const size_t local_work_sizze_23820[1] = {segmap_group_sizze_18939};
            int64_t time_start_23817 = 0, time_end_23818 = 0;
            
            if (ctx->debugging) {
                fprintf(stderr, "Launching %s with global work size [",
                        "main.segmap_18861");
                fprintf(stderr, "%zu", global_work_sizze_23816[0]);
                fprintf(stderr, "] and local work size [");
                fprintf(stderr, "%zu", local_work_sizze_23820[0]);
                fprintf(stderr, "]; local memory parameters sum to %d bytes.\n",
                        (int) 0);
                time_start_23817 = get_wall_time();
            }
            OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->opencl.queue,
                                                            ctx->mainzisegmap_18861,
                                                            1, NULL,
                                                            global_work_sizze_23816,
                                                            local_work_sizze_23820,
                                                            0, NULL,
                                                            ctx->profiling_paused ||
                                                            !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                                      &ctx->mainzisegmap_18861_runs,
                                                                                                      &ctx->mainzisegmap_18861_total_runtime)));
            if (ctx->debugging) {
                OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
                time_end_23818 = get_wall_time();
                
                long time_diff_23819 = time_end_23818 - time_start_23817;
                
                fprintf(stderr, "kernel %s runtime: %ldus\n",
                        "main.segmap_18861", time_diff_23819);
            }
        }
        ctx->failure_is_an_option = 1;
        if (memblock_unref_device(ctx, &mem_23234, "mem_23234") != 0)
            return 1;
        if (memblock_set_device(ctx, &res_mem_23272, &mem_23248, "mem_23248") !=
            0)
            return 1;
        if (memblock_set_device(ctx, &res_mem_23273, &mem_23231, "mem_23231") !=
            0)
            return 1;
        if (memblock_set_device(ctx, &res_mem_23274, &mem_23229, "mem_23229") !=
            0)
            return 1;
        if (memblock_set_device(ctx, &res_mem_23275, &mem_23227, "mem_23227") !=
            0)
            return 1;
        if (memblock_unref_device(ctx, &mem_23234, "mem_23234") != 0)
            return 1;
        if (memblock_unref_device(ctx, &group_res_arr_mem_23525,
                                  "group_res_arr_mem_23525") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_23368, "mem_23368") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_23248, "mem_23248") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_23231, "mem_23231") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_23229, "mem_23229") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_23227, "mem_23227") != 0)
            return 1;
    } else {
        int64_t segmap_usable_groups_19116 = sdiv_up64(n_18078,
                                                       segmap_group_sizze_19115);
        struct memblock_device mem_23250;
        
        mem_23250.references = NULL;
        if (memblock_alloc_device(ctx, &mem_23250, bytes_23226, "mem_23250")) {
            err = 1;
            goto cleanup;
        }
        if (n_18078 * (int32_t) sizeof(float) > 0) {
            OPENCL_SUCCEED_OR_RETURN(clEnqueueCopyBuffer(ctx->opencl.queue,
                                                         swap_term_mem_23220.mem,
                                                         mem_23250.mem, 0, 0,
                                                         n_18078 *
                                                         (int32_t) sizeof(float),
                                                         0, NULL,
                                                         ctx->profiling_paused ||
                                                         !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                                   &ctx->copy_dev_to_dev_runs,
                                                                                                   &ctx->copy_dev_to_dev_total_runtime)));
            if (ctx->debugging)
                OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
        }
        
        struct memblock_device mem_23252;
        
        mem_23252.references = NULL;
        if (memblock_alloc_device(ctx, &mem_23252, bytes_23228, "mem_23252")) {
            err = 1;
            goto cleanup;
        }
        if (n_18078 * (int32_t) sizeof(int64_t) > 0) {
            OPENCL_SUCCEED_OR_RETURN(clEnqueueCopyBuffer(ctx->opencl.queue,
                                                         payments_mem_23221.mem,
                                                         mem_23252.mem, 0, 0,
                                                         n_18078 *
                                                         (int32_t) sizeof(int64_t),
                                                         0, NULL,
                                                         ctx->profiling_paused ||
                                                         !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                                   &ctx->copy_dev_to_dev_runs,
                                                                                                   &ctx->copy_dev_to_dev_total_runtime)));
            if (ctx->debugging)
                OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
        }
        
        struct memblock_device mem_23254;
        
        mem_23254.references = NULL;
        if (memblock_alloc_device(ctx, &mem_23254, bytes_23226, "mem_23254")) {
            err = 1;
            goto cleanup;
        }
        if (n_18078 * (int32_t) sizeof(float) > 0) {
            OPENCL_SUCCEED_OR_RETURN(clEnqueueCopyBuffer(ctx->opencl.queue,
                                                         notional_mem_23222.mem,
                                                         mem_23254.mem, 0, 0,
                                                         n_18078 *
                                                         (int32_t) sizeof(float),
                                                         0, NULL,
                                                         ctx->profiling_paused ||
                                                         !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                                   &ctx->copy_dev_to_dev_runs,
                                                                                                   &ctx->copy_dev_to_dev_total_runtime)));
            if (ctx->debugging)
                OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
        }
        
        struct memblock_device mem_23271;
        
        mem_23271.references = NULL;
        if (memblock_alloc_device(ctx, &mem_23271, bytes_23226, "mem_23271")) {
            err = 1;
            goto cleanup;
        }
        
        int64_t num_threads_23372 = segmap_group_sizze_19115 *
                segmap_usable_groups_19116;
        struct memblock_device mem_23400;
        
        mem_23400.references = NULL;
        if (memblock_alloc_device(ctx, &mem_23400, 8, "mem_23400")) {
            err = 1;
            goto cleanup;
        }
        
        struct memblock_device mainzicounter_mem_23560 =
                               ctx->mainzicounter_mem_23560;
        struct memblock_device group_res_arr_mem_23562;
        
        group_res_arr_mem_23562.references = NULL;
        if (memblock_alloc_device(ctx, &group_res_arr_mem_23562,
                                  (int32_t) sizeof(int64_t) *
                                  (segred_group_sizze_23384 *
                                   segred_num_groups_23382),
                                  "group_res_arr_mem_23562")) {
            err = 1;
            goto cleanup;
        }
        
        int64_t num_threads_23564;
        
        num_threads_23564 = segred_num_groups_23382 * segred_group_sizze_23384;
        if (ctx->debugging)
            fprintf(stderr, "%s\n", "\n# SegRed");
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_nonseg_23388,
                                                1, (int32_t) sizeof(int64_t) *
                                                segred_group_sizze_23384,
                                                NULL));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_nonseg_23388,
                                                2, (int32_t) sizeof(bool),
                                                NULL));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_nonseg_23388,
                                                3, sizeof(n_18078), &n_18078));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_nonseg_23388,
                                                4,
                                                sizeof(payments_mem_23221.mem),
                                                &payments_mem_23221.mem));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_nonseg_23388,
                                                5, sizeof(mem_23400.mem),
                                                &mem_23400.mem));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_nonseg_23388,
                                                6,
                                                sizeof(mainzicounter_mem_23560.mem),
                                                &mainzicounter_mem_23560.mem));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_nonseg_23388,
                                                7,
                                                sizeof(group_res_arr_mem_23562.mem),
                                                &group_res_arr_mem_23562.mem));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_nonseg_23388,
                                                8, sizeof(num_threads_23564),
                                                &num_threads_23564));
        if (1 * ((size_t) segred_num_groups_23382 *
                 (size_t) segred_group_sizze_23384) != 0) {
            const size_t global_work_sizze_23822[1] =
                         {(size_t) segred_num_groups_23382 *
                         (size_t) segred_group_sizze_23384};
            const size_t local_work_sizze_23826[1] = {segred_group_sizze_23384};
            int64_t time_start_23823 = 0, time_end_23824 = 0;
            
            if (ctx->debugging) {
                fprintf(stderr, "Launching %s with global work size [",
                        "main.segred_nonseg_23388");
                fprintf(stderr, "%zu", global_work_sizze_23822[0]);
                fprintf(stderr, "] and local work size [");
                fprintf(stderr, "%zu", local_work_sizze_23826[0]);
                fprintf(stderr, "]; local memory parameters sum to %d bytes.\n",
                        (int) (0 + (int32_t) sizeof(int64_t) *
                               segred_group_sizze_23384 +
                               (int32_t) sizeof(bool)));
                time_start_23823 = get_wall_time();
            }
            OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->opencl.queue,
                                                            ctx->mainzisegred_nonseg_23388,
                                                            1, NULL,
                                                            global_work_sizze_23822,
                                                            local_work_sizze_23826,
                                                            0, NULL,
                                                            ctx->profiling_paused ||
                                                            !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                                      &ctx->mainzisegred_nonseg_23388_runs,
                                                                                                      &ctx->mainzisegred_nonseg_23388_total_runtime)));
            if (ctx->debugging) {
                OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
                time_end_23824 = get_wall_time();
                
                long time_diff_23825 = time_end_23824 - time_start_23823;
                
                fprintf(stderr, "kernel %s runtime: %ldus\n",
                        "main.segred_nonseg_23388", time_diff_23825);
            }
        }
        
        int64_t read_res_23827;
        
        OPENCL_SUCCEED_OR_RETURN(clEnqueueReadBuffer(ctx->opencl.queue,
                                                     mem_23400.mem,
                                                     ctx->failure_is_an_option ? CL_FALSE : CL_TRUE,
                                                     0 * sizeof(int64_t),
                                                     sizeof(int64_t),
                                                     &read_res_23827, 0, NULL,
                                                     ctx->profiling_paused ||
                                                     !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                               &ctx->copy_scalar_from_dev_runs,
                                                                                               &ctx->copy_scalar_from_dev_total_runtime)));
        if (ctx->failure_is_an_option && futhark_context_sync(ctx) != 0)
            return 1;
        
        int64_t max_per_thread_23378 = read_res_23827;
        
        if (memblock_unref_device(ctx, &mem_23400, "mem_23400") != 0)
            return 1;
        
        int64_t sizze_sum_23395 = num_threads_23372 * max_per_thread_23378;
        struct memblock_device mem_23257;
        
        mem_23257.references = NULL;
        if (memblock_alloc_device(ctx, &mem_23257, sizze_sum_23395,
                                  "mem_23257")) {
            err = 1;
            goto cleanup;
        }
        if (ctx->debugging)
            fprintf(stderr, "%s\n", "\n# SegMap");
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_19037, 1,
                                                sizeof(ctx->failure_is_an_option),
                                                &ctx->failure_is_an_option));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_19037, 3,
                                                sizeof(n_18078), &n_18078));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_19037, 4,
                                                sizeof(a_18086), &a_18086));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_19037, 5,
                                                sizeof(r0_18089), &r0_18089));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_19037, 6,
                                                sizeof(x_18106), &x_18106));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_19037, 7,
                                                sizeof(x_18108), &x_18108));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_19037, 8,
                                                sizeof(y_18110), &y_18110));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_19037, 9,
                                                sizeof(y_18111), &y_18111));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_19037, 10,
                                                sizeof(swap_term_mem_23220.mem),
                                                &swap_term_mem_23220.mem));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_19037, 11,
                                                sizeof(payments_mem_23221.mem),
                                                &payments_mem_23221.mem));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_19037, 12,
                                                sizeof(mem_23257.mem),
                                                &mem_23257.mem));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_19037, 13,
                                                sizeof(mem_23271.mem),
                                                &mem_23271.mem));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_19037, 14,
                                                sizeof(num_threads_23372),
                                                &num_threads_23372));
        if (1 * ((size_t) segmap_usable_groups_19116 *
                 (size_t) segmap_group_sizze_19115) != 0) {
            const size_t global_work_sizze_23828[1] =
                         {(size_t) segmap_usable_groups_19116 *
                         (size_t) segmap_group_sizze_19115};
            const size_t local_work_sizze_23832[1] = {segmap_group_sizze_19115};
            int64_t time_start_23829 = 0, time_end_23830 = 0;
            
            if (ctx->debugging) {
                fprintf(stderr, "Launching %s with global work size [",
                        "main.segmap_19037");
                fprintf(stderr, "%zu", global_work_sizze_23828[0]);
                fprintf(stderr, "] and local work size [");
                fprintf(stderr, "%zu", local_work_sizze_23832[0]);
                fprintf(stderr, "]; local memory parameters sum to %d bytes.\n",
                        (int) 0);
                time_start_23829 = get_wall_time();
            }
            OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->opencl.queue,
                                                            ctx->mainzisegmap_19037,
                                                            1, NULL,
                                                            global_work_sizze_23828,
                                                            local_work_sizze_23832,
                                                            0, NULL,
                                                            ctx->profiling_paused ||
                                                            !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                                      &ctx->mainzisegmap_19037_runs,
                                                                                                      &ctx->mainzisegmap_19037_total_runtime)));
            if (ctx->debugging) {
                OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
                time_end_23830 = get_wall_time();
                
                long time_diff_23831 = time_end_23830 - time_start_23829;
                
                fprintf(stderr, "kernel %s runtime: %ldus\n",
                        "main.segmap_19037", time_diff_23831);
            }
        }
        ctx->failure_is_an_option = 1;
        if (memblock_unref_device(ctx, &mem_23257, "mem_23257") != 0)
            return 1;
        if (memblock_set_device(ctx, &res_mem_23272, &mem_23271, "mem_23271") !=
            0)
            return 1;
        if (memblock_set_device(ctx, &res_mem_23273, &mem_23254, "mem_23254") !=
            0)
            return 1;
        if (memblock_set_device(ctx, &res_mem_23274, &mem_23252, "mem_23252") !=
            0)
            return 1;
        if (memblock_set_device(ctx, &res_mem_23275, &mem_23250, "mem_23250") !=
            0)
            return 1;
        if (memblock_unref_device(ctx, &mem_23257, "mem_23257") != 0)
            return 1;
        if (memblock_unref_device(ctx, &group_res_arr_mem_23562,
                                  "group_res_arr_mem_23562") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_23400, "mem_23400") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_23271, "mem_23271") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_23254, "mem_23254") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_23252, "mem_23252") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_23250, "mem_23250") != 0)
            return 1;
    }
    
    float sims_per_year_18188 = res_18103 / res_18095;
    bool bounds_invalid_upwards_18189 = slt64(steps_18082, 1);
    bool valid_18190 = !bounds_invalid_upwards_18189;
    bool range_valid_c_18191;
    
    if (!valid_18190) {
        ctx->error = msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s",
                               "Range ", 1, "..", 2, "...", steps_18082,
                               " is invalid.",
                               "-> #0  cvaold.fut:60:56-67\n   #1  cvaold.fut:111:17-44\n   #2  cvaold.fut:100:1-160:20\n");
        if (memblock_unref_device(ctx, &res_mem_23275, "res_mem_23275") != 0)
            return 1;
        if (memblock_unref_device(ctx, &res_mem_23274, "res_mem_23274") != 0)
            return 1;
        if (memblock_unref_device(ctx, &res_mem_23273, "res_mem_23273") != 0)
            return 1;
        if (memblock_unref_device(ctx, &res_mem_23272, "res_mem_23272") != 0)
            return 1;
        if (memblock_unref_device(ctx, &group_res_arr_mem_23495,
                                  "group_res_arr_mem_23495") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_23225, "mem_23225") != 0)
            return 1;
        if (memblock_unref_device(ctx, &out_mem_23490, "out_mem_23490") != 0)
            return 1;
        return 1;
    }
    
    bool bounds_invalid_upwards_18197 = slt64(paths_18081, 0);
    bool valid_18198 = !bounds_invalid_upwards_18197;
    bool range_valid_c_18199;
    
    if (!valid_18198) {
        ctx->error = msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s",
                               "Range ", 0, "..", 1, "..<", paths_18081,
                               " is invalid.",
                               "-> #0  /prelude/array.fut:60:3-10\n   #1  /prelude/array.fut:126:11-16\n   #2  lib/github.com/diku-dk/cpprandom/random.fut:174:8-56\n   #3  cvaold.fut:115:19-49\n   #4  cvaold.fut:100:1-160:20\n");
        if (memblock_unref_device(ctx, &res_mem_23275, "res_mem_23275") != 0)
            return 1;
        if (memblock_unref_device(ctx, &res_mem_23274, "res_mem_23274") != 0)
            return 1;
        if (memblock_unref_device(ctx, &res_mem_23273, "res_mem_23273") != 0)
            return 1;
        if (memblock_unref_device(ctx, &res_mem_23272, "res_mem_23272") != 0)
            return 1;
        if (memblock_unref_device(ctx, &group_res_arr_mem_23495,
                                  "group_res_arr_mem_23495") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_23225, "mem_23225") != 0)
            return 1;
        if (memblock_unref_device(ctx, &out_mem_23490, "out_mem_23490") != 0)
            return 1;
        return 1;
    }
    
    int64_t upper_bound_18202 = sub64(steps_18082, 1);
    float res_18203;
    
    res_18203 = futrts_sqrt32(dt_18104);
    
    int64_t segmap_group_sizze_19551;
    
    segmap_group_sizze_19551 = ctx->sizes.mainzisegmap_group_sizze_19534;
    
    int64_t segmap_usable_groups_19552 = sdiv_up64(paths_18081,
                                                   segmap_group_sizze_19551);
    int64_t bytes_23277 = 4 * paths_18081;
    struct memblock_device mem_23278;
    
    mem_23278.references = NULL;
    if (memblock_alloc_device(ctx, &mem_23278, bytes_23277, "mem_23278")) {
        err = 1;
        goto cleanup;
    }
    if (ctx->debugging)
        fprintf(stderr, "%s\n", "\n# SegMap");
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_19532, 1,
                                            sizeof(paths_18081), &paths_18081));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_19532, 2,
                                            sizeof(mem_23278.mem),
                                            &mem_23278.mem));
    if (1 * ((size_t) segmap_usable_groups_19552 *
             (size_t) segmap_group_sizze_19551) != 0) {
        const size_t global_work_sizze_23833[1] =
                     {(size_t) segmap_usable_groups_19552 *
                     (size_t) segmap_group_sizze_19551};
        const size_t local_work_sizze_23837[1] = {segmap_group_sizze_19551};
        int64_t time_start_23834 = 0, time_end_23835 = 0;
        
        if (ctx->debugging) {
            fprintf(stderr, "Launching %s with global work size [",
                    "main.segmap_19532");
            fprintf(stderr, "%zu", global_work_sizze_23833[0]);
            fprintf(stderr, "] and local work size [");
            fprintf(stderr, "%zu", local_work_sizze_23837[0]);
            fprintf(stderr, "]; local memory parameters sum to %d bytes.\n",
                    (int) 0);
            time_start_23834 = get_wall_time();
        }
        OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->opencl.queue,
                                                        ctx->mainzisegmap_19532,
                                                        1, NULL,
                                                        global_work_sizze_23833,
                                                        local_work_sizze_23837,
                                                        0, NULL,
                                                        ctx->profiling_paused ||
                                                        !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                                  &ctx->mainzisegmap_19532_runs,
                                                                                                  &ctx->mainzisegmap_19532_total_runtime)));
        if (ctx->debugging) {
            OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
            time_end_23835 = get_wall_time();
            
            long time_diff_23836 = time_end_23835 - time_start_23834;
            
            fprintf(stderr, "kernel %s runtime: %ldus\n", "main.segmap_19532",
                    time_diff_23836);
        }
    }
    
    int64_t nest_sizze_19575 = paths_18081 * steps_18082;
    int64_t segmap_group_sizze_19576;
    
    segmap_group_sizze_19576 = ctx->sizes.mainzisegmap_group_sizze_19471;
    
    int64_t segmap_usable_groups_19577 = sdiv_up64(nest_sizze_19575,
                                                   segmap_group_sizze_19576);
    int64_t bytes_23280 = 4 * nest_sizze_19575;
    struct memblock_device mem_23282;
    
    mem_23282.references = NULL;
    if (memblock_alloc_device(ctx, &mem_23282, bytes_23280, "mem_23282")) {
        err = 1;
        goto cleanup;
    }
    if (ctx->debugging)
        fprintf(stderr, "%s\n", "\n# SegMap");
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_19468, 1,
                                            sizeof(paths_18081), &paths_18081));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_19468, 2,
                                            sizeof(steps_18082), &steps_18082));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_19468, 3,
                                            sizeof(mem_23278.mem),
                                            &mem_23278.mem));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_19468, 4,
                                            sizeof(mem_23282.mem),
                                            &mem_23282.mem));
    if (1 * ((size_t) segmap_usable_groups_19577 *
             (size_t) segmap_group_sizze_19576) != 0) {
        const size_t global_work_sizze_23838[1] =
                     {(size_t) segmap_usable_groups_19577 *
                     (size_t) segmap_group_sizze_19576};
        const size_t local_work_sizze_23842[1] = {segmap_group_sizze_19576};
        int64_t time_start_23839 = 0, time_end_23840 = 0;
        
        if (ctx->debugging) {
            fprintf(stderr, "Launching %s with global work size [",
                    "main.segmap_19468");
            fprintf(stderr, "%zu", global_work_sizze_23838[0]);
            fprintf(stderr, "] and local work size [");
            fprintf(stderr, "%zu", local_work_sizze_23842[0]);
            fprintf(stderr, "]; local memory parameters sum to %d bytes.\n",
                    (int) 0);
            time_start_23839 = get_wall_time();
        }
        OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->opencl.queue,
                                                        ctx->mainzisegmap_19468,
                                                        1, NULL,
                                                        global_work_sizze_23838,
                                                        local_work_sizze_23842,
                                                        0, NULL,
                                                        ctx->profiling_paused ||
                                                        !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                                  &ctx->mainzisegmap_19468_runs,
                                                                                                  &ctx->mainzisegmap_19468_total_runtime)));
        if (ctx->debugging) {
            OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
            time_end_23840 = get_wall_time();
            
            long time_diff_23841 = time_end_23840 - time_start_23839;
            
            fprintf(stderr, "kernel %s runtime: %ldus\n", "main.segmap_19468",
                    time_diff_23841);
        }
    }
    if (memblock_unref_device(ctx, &mem_23278, "mem_23278") != 0)
        return 1;
    
    int64_t segmap_group_sizze_19621;
    
    segmap_group_sizze_19621 = ctx->sizes.mainzisegmap_group_sizze_19372;
    
    int64_t num_groups_19622;
    int32_t max_num_groups_23608;
    
    max_num_groups_23608 = ctx->sizes.mainzisegmap_num_groups_19374;
    num_groups_19622 = sext_i64_i32(smax64(1, smin64(sdiv_up64(paths_18081,
                                                               sext_i32_i64(segmap_group_sizze_19621)),
                                                     sext_i32_i64(max_num_groups_23608))));
    
    struct memblock_device mem_23285;
    
    mem_23285.references = NULL;
    if (memblock_alloc_device(ctx, &mem_23285, bytes_23280, "mem_23285")) {
        err = 1;
        goto cleanup;
    }
    if (futrts_builtinzhgpu_map_transpose_f32(ctx, mem_23285, 0, mem_23282, 0,
                                              1, steps_18082, paths_18081) !=
        0) {
        err = 1;
        goto cleanup;
    }
    if (memblock_unref_device(ctx, &mem_23282, "mem_23282") != 0)
        return 1;
    
    struct memblock_device mem_23303;
    
    mem_23303.references = NULL;
    if (memblock_alloc_device(ctx, &mem_23303, bytes_23280, "mem_23303")) {
        err = 1;
        goto cleanup;
    }
    
    int64_t bytes_23287 = 4 * steps_18082;
    int64_t num_threads_23406 = segmap_group_sizze_19621 * num_groups_19622;
    int64_t total_sizze_23407 = bytes_23287 * num_threads_23406;
    struct memblock_device mem_23288;
    
    mem_23288.references = NULL;
    if (memblock_alloc_device(ctx, &mem_23288, total_sizze_23407,
                              "mem_23288")) {
        err = 1;
        goto cleanup;
    }
    if (ctx->debugging)
        fprintf(stderr, "%s\n", "\n# SegMap");
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_19370, 1,
                                            sizeof(ctx->failure_is_an_option),
                                            &ctx->failure_is_an_option));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_19370, 3,
                                            sizeof(paths_18081), &paths_18081));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_19370, 4,
                                            sizeof(steps_18082), &steps_18082));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_19370, 5,
                                            sizeof(a_18086), &a_18086));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_19370, 6,
                                            sizeof(b_18087), &b_18087));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_19370, 7,
                                            sizeof(sigma_18088), &sigma_18088));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_19370, 8,
                                            sizeof(r0_18089), &r0_18089));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_19370, 9,
                                            sizeof(dt_18104), &dt_18104));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_19370, 10,
                                            sizeof(upper_bound_18202),
                                            &upper_bound_18202));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_19370, 11,
                                            sizeof(res_18203), &res_18203));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_19370, 12,
                                            sizeof(num_groups_19622),
                                            &num_groups_19622));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_19370, 13,
                                            sizeof(mem_23285.mem),
                                            &mem_23285.mem));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_19370, 14,
                                            sizeof(mem_23288.mem),
                                            &mem_23288.mem));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_19370, 15,
                                            sizeof(mem_23303.mem),
                                            &mem_23303.mem));
    if (1 * ((size_t) num_groups_19622 * (size_t) segmap_group_sizze_19621) !=
        0) {
        const size_t global_work_sizze_23843[1] = {(size_t) num_groups_19622 *
                     (size_t) segmap_group_sizze_19621};
        const size_t local_work_sizze_23847[1] = {segmap_group_sizze_19621};
        int64_t time_start_23844 = 0, time_end_23845 = 0;
        
        if (ctx->debugging) {
            fprintf(stderr, "Launching %s with global work size [",
                    "main.segmap_19370");
            fprintf(stderr, "%zu", global_work_sizze_23843[0]);
            fprintf(stderr, "] and local work size [");
            fprintf(stderr, "%zu", local_work_sizze_23847[0]);
            fprintf(stderr, "]; local memory parameters sum to %d bytes.\n",
                    (int) 0);
            time_start_23844 = get_wall_time();
        }
        OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->opencl.queue,
                                                        ctx->mainzisegmap_19370,
                                                        1, NULL,
                                                        global_work_sizze_23843,
                                                        local_work_sizze_23847,
                                                        0, NULL,
                                                        ctx->profiling_paused ||
                                                        !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                                  &ctx->mainzisegmap_19370_runs,
                                                                                                  &ctx->mainzisegmap_19370_total_runtime)));
        if (ctx->debugging) {
            OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
            time_end_23845 = get_wall_time();
            
            long time_diff_23846 = time_end_23845 - time_start_23844;
            
            fprintf(stderr, "kernel %s runtime: %ldus\n", "main.segmap_19370",
                    time_diff_23846);
        }
    }
    ctx->failure_is_an_option = 1;
    if (memblock_unref_device(ctx, &mem_23285, "mem_23285") != 0)
        return 1;
    if (memblock_unref_device(ctx, &mem_23288, "mem_23288") != 0)
        return 1;
    
    float res_18265 = sitofp_i64_f32(paths_18081);
    bool suff_outer_redomap_19648;
    
    suff_outer_redomap_19648 = ctx->sizes.mainzisuff_outer_redomap_5 <=
        steps_18082;
    if (ctx->logging)
        fprintf(stderr, "Compared %s <= %d.\n", "main.suff_outer_redomap_5",
                steps_18082);
    
    int64_t segred_group_sizze_19661;
    
    segred_group_sizze_19661 = ctx->sizes.mainzisegred_group_sizze_19650;
    
    int64_t num_groups_19662;
    int32_t max_num_groups_23620;
    
    max_num_groups_23620 = ctx->sizes.mainzisegred_num_groups_19652;
    num_groups_19662 = sext_i64_i32(smax64(1, smin64(sdiv_up64(steps_18082,
                                                               sext_i32_i64(segred_group_sizze_19661)),
                                                     sext_i32_i64(max_num_groups_23620))));
    
    bool suff_outer_par_20559;
    
    suff_outer_par_20559 = ctx->sizes.mainzisuff_outer_par_6 <= steps_18082;
    if (ctx->logging)
        fprintf(stderr, "Compared %s <= %d.\n", "main.suff_outer_par_6",
                steps_18082);
    
    int64_t max_group_sizze_20562;
    
    max_group_sizze_20562 = ctx->opencl.max_group_size;
    
    bool fits_20563 = sle64(paths_18081, max_group_sizze_20562);
    bool suff_intra_par_20565;
    
    suff_intra_par_20565 = ctx->sizes.mainzisuff_intra_par_7 <= paths_18081;
    if (ctx->logging)
        fprintf(stderr, "Compared %s <= %d.\n", "main.suff_intra_par_7",
                paths_18081);
    
    bool intra_suff_and_fits_20566 = fits_20563 && suff_intra_par_20565;
    int64_t segmap_group_sizze_20570;
    
    segmap_group_sizze_20570 = ctx->sizes.mainzisegmap_group_sizze_19818;
    
    int64_t segred_group_sizze_20855;
    
    segred_group_sizze_20855 = ctx->sizes.mainzisegred_group_sizze_20267;
    
    int64_t num_groups_20856;
    int32_t max_num_groups_23621;
    
    max_num_groups_23621 = ctx->sizes.mainzisegred_num_groups_20269;
    num_groups_20856 = sext_i64_i32(smax64(1, smin64(sdiv_up64(nest_sizze_19575,
                                                               sext_i32_i64(segred_group_sizze_20855)),
                                                     sext_i32_i64(max_num_groups_23621))));
    
    int64_t segmap_group_sizze_20971;
    
    segmap_group_sizze_20971 = ctx->sizes.mainzisegmap_group_sizze_20240;
    
    int64_t segred_group_sizze_20999;
    
    segred_group_sizze_20999 = ctx->sizes.mainzisegred_group_sizze_20549;
    
    int64_t num_groups_21000;
    int32_t max_num_groups_23622;
    
    max_num_groups_23622 = ctx->sizes.mainzisegred_num_groups_20551;
    num_groups_21000 = sext_i64_i32(smax64(1, smin64(sdiv_up64(steps_18082,
                                                               sext_i32_i64(segred_group_sizze_20999)),
                                                     sext_i32_i64(max_num_groups_23622))));
    
    struct memblock_device res_mem_23338;
    
    res_mem_23338.references = NULL;
    
    float res_18386;
    int32_t local_memory_capacity_23777;
    
    local_memory_capacity_23777 = ctx->opencl.max_local_memory;
    if (sle64((int32_t) sizeof(bool) + (int32_t) sizeof(float) *
              segred_group_sizze_19661,
              sext_i32_i64(local_memory_capacity_23777)) &&
        suff_outer_redomap_19648) {
        struct memblock_device mem_23306;
        
        mem_23306.references = NULL;
        if (memblock_alloc_device(ctx, &mem_23306, 4, "mem_23306")) {
            err = 1;
            goto cleanup;
        }
        
        struct memblock_device mem_23308;
        
        mem_23308.references = NULL;
        if (memblock_alloc_device(ctx, &mem_23308, bytes_23287, "mem_23308")) {
            err = 1;
            goto cleanup;
        }
        
        struct memblock_device mainzicounter_mem_23623 =
                               ctx->mainzicounter_mem_23623;
        struct memblock_device group_res_arr_mem_23625;
        
        group_res_arr_mem_23625.references = NULL;
        if (memblock_alloc_device(ctx, &group_res_arr_mem_23625,
                                  (int32_t) sizeof(float) *
                                  (segred_group_sizze_19661 * num_groups_19662),
                                  "group_res_arr_mem_23625")) {
            err = 1;
            goto cleanup;
        }
        
        int64_t num_threads_23627;
        
        num_threads_23627 = num_groups_19662 * segred_group_sizze_19661;
        if (ctx->debugging)
            fprintf(stderr, "%s\n", "\n# SegRed");
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_nonseg_19659,
                                                1,
                                                sizeof(ctx->failure_is_an_option),
                                                &ctx->failure_is_an_option));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_nonseg_19659,
                                                3, (int32_t) sizeof(float) *
                                                segred_group_sizze_19661,
                                                NULL));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_nonseg_19659,
                                                4, (int32_t) sizeof(bool),
                                                NULL));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_nonseg_19659,
                                                5, sizeof(n_18078), &n_18078));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_nonseg_19659,
                                                6, sizeof(paths_18081),
                                                &paths_18081));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_nonseg_19659,
                                                7, sizeof(steps_18082),
                                                &steps_18082));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_nonseg_19659,
                                                8, sizeof(a_18086), &a_18086));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_nonseg_19659,
                                                9, sizeof(b_18087), &b_18087));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_nonseg_19659,
                                                10, sizeof(sigma_18088),
                                                &sigma_18088));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_nonseg_19659,
                                                11, sizeof(x_18106), &x_18106));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_nonseg_19659,
                                                12, sizeof(x_18108), &x_18108));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_nonseg_19659,
                                                13, sizeof(y_18110), &y_18110));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_nonseg_19659,
                                                14, sizeof(y_18111), &y_18111));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_nonseg_19659,
                                                15, sizeof(sims_per_year_18188),
                                                &sims_per_year_18188));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_nonseg_19659,
                                                16, sizeof(res_18265),
                                                &res_18265));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_nonseg_19659,
                                                17, sizeof(num_groups_19662),
                                                &num_groups_19662));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_nonseg_19659,
                                                18, sizeof(res_mem_23272.mem),
                                                &res_mem_23272.mem));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_nonseg_19659,
                                                19, sizeof(res_mem_23273.mem),
                                                &res_mem_23273.mem));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_nonseg_19659,
                                                20, sizeof(res_mem_23274.mem),
                                                &res_mem_23274.mem));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_nonseg_19659,
                                                21, sizeof(res_mem_23275.mem),
                                                &res_mem_23275.mem));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_nonseg_19659,
                                                22, sizeof(mem_23303.mem),
                                                &mem_23303.mem));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_nonseg_19659,
                                                23, sizeof(mem_23306.mem),
                                                &mem_23306.mem));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_nonseg_19659,
                                                24, sizeof(mem_23308.mem),
                                                &mem_23308.mem));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_nonseg_19659,
                                                25,
                                                sizeof(mainzicounter_mem_23623.mem),
                                                &mainzicounter_mem_23623.mem));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_nonseg_19659,
                                                26,
                                                sizeof(group_res_arr_mem_23625.mem),
                                                &group_res_arr_mem_23625.mem));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_nonseg_19659,
                                                27, sizeof(num_threads_23627),
                                                &num_threads_23627));
        if (1 * ((size_t) num_groups_19662 *
                 (size_t) segred_group_sizze_19661) != 0) {
            const size_t global_work_sizze_23849[1] =
                         {(size_t) num_groups_19662 *
                         (size_t) segred_group_sizze_19661};
            const size_t local_work_sizze_23853[1] = {segred_group_sizze_19661};
            int64_t time_start_23850 = 0, time_end_23851 = 0;
            
            if (ctx->debugging) {
                fprintf(stderr, "Launching %s with global work size [",
                        "main.segred_nonseg_19659");
                fprintf(stderr, "%zu", global_work_sizze_23849[0]);
                fprintf(stderr, "] and local work size [");
                fprintf(stderr, "%zu", local_work_sizze_23853[0]);
                fprintf(stderr, "]; local memory parameters sum to %d bytes.\n",
                        (int) (0 + (int32_t) sizeof(float) *
                               segred_group_sizze_19661 +
                               (int32_t) sizeof(bool)));
                time_start_23850 = get_wall_time();
            }
            OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->opencl.queue,
                                                            ctx->mainzisegred_nonseg_19659,
                                                            1, NULL,
                                                            global_work_sizze_23849,
                                                            local_work_sizze_23853,
                                                            0, NULL,
                                                            ctx->profiling_paused ||
                                                            !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                                      &ctx->mainzisegred_nonseg_19659_runs,
                                                                                                      &ctx->mainzisegred_nonseg_19659_total_runtime)));
            if (ctx->debugging) {
                OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
                time_end_23851 = get_wall_time();
                
                long time_diff_23852 = time_end_23851 - time_start_23850;
                
                fprintf(stderr, "kernel %s runtime: %ldus\n",
                        "main.segred_nonseg_19659", time_diff_23852);
            }
        }
        ctx->failure_is_an_option = 1;
        
        float read_res_23854;
        
        OPENCL_SUCCEED_OR_RETURN(clEnqueueReadBuffer(ctx->opencl.queue,
                                                     mem_23306.mem,
                                                     ctx->failure_is_an_option ? CL_FALSE : CL_TRUE,
                                                     0 * sizeof(float),
                                                     sizeof(float),
                                                     &read_res_23854, 0, NULL,
                                                     ctx->profiling_paused ||
                                                     !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                               &ctx->copy_scalar_from_dev_runs,
                                                                                               &ctx->copy_scalar_from_dev_total_runtime)));
        if (ctx->failure_is_an_option && futhark_context_sync(ctx) != 0)
            return 1;
        
        float res_19803 = read_res_23854;
        
        if (memblock_unref_device(ctx, &mem_23306, "mem_23306") != 0)
            return 1;
        
        struct memblock_device mem_23336;
        
        mem_23336.references = NULL;
        if (memblock_alloc_device(ctx, &mem_23336, bytes_23287, "mem_23336")) {
            err = 1;
            goto cleanup;
        }
        if (steps_18082 * (int32_t) sizeof(float) > 0) {
            OPENCL_SUCCEED_OR_RETURN(clEnqueueCopyBuffer(ctx->opencl.queue,
                                                         mem_23308.mem,
                                                         mem_23336.mem, 0, 0,
                                                         steps_18082 *
                                                         (int32_t) sizeof(float),
                                                         0, NULL,
                                                         ctx->profiling_paused ||
                                                         !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                                   &ctx->copy_dev_to_dev_runs,
                                                                                                   &ctx->copy_dev_to_dev_total_runtime)));
            if (ctx->debugging)
                OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
        }
        if (memblock_unref_device(ctx, &mem_23308, "mem_23308") != 0)
            return 1;
        if (memblock_set_device(ctx, &res_mem_23338, &mem_23336, "mem_23336") !=
            0)
            return 1;
        res_18386 = res_19803;
        if (memblock_unref_device(ctx, &mem_23336, "mem_23336") != 0)
            return 1;
        if (memblock_unref_device(ctx, &group_res_arr_mem_23625,
                                  "group_res_arr_mem_23625") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_23308, "mem_23308") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_23306, "mem_23306") != 0)
            return 1;
    } else {
        struct memblock_device res_map_acc_mem_23330;
        
        res_map_acc_mem_23330.references = NULL;
        
        struct memblock_device res_mem_23331;
        
        res_mem_23331.references = NULL;
        
        int32_t local_memory_capacity_23746;
        
        local_memory_capacity_23746 = ctx->opencl.max_local_memory;
        if (sle64(0, sext_i32_i64(local_memory_capacity_23746)) &&
            suff_outer_par_20559) {
            int64_t segmap_usable_groups_20571 = sdiv_up64(steps_18082,
                                                           segmap_group_sizze_20570);
            struct memblock_device mem_23311;
            
            mem_23311.references = NULL;
            if (memblock_alloc_device(ctx, &mem_23311, bytes_23287,
                                      "mem_23311")) {
                err = 1;
                goto cleanup;
            }
            
            struct memblock_device mem_23313;
            
            mem_23313.references = NULL;
            if (memblock_alloc_device(ctx, &mem_23313, bytes_23287,
                                      "mem_23313")) {
                err = 1;
                goto cleanup;
            }
            if (ctx->debugging)
                fprintf(stderr, "%s\n", "\n# SegMap");
            OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_19816, 1,
                                                    sizeof(ctx->failure_is_an_option),
                                                    &ctx->failure_is_an_option));
            OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_19816, 3,
                                                    sizeof(n_18078), &n_18078));
            OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_19816, 4,
                                                    sizeof(paths_18081),
                                                    &paths_18081));
            OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_19816, 5,
                                                    sizeof(steps_18082),
                                                    &steps_18082));
            OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_19816, 6,
                                                    sizeof(a_18086), &a_18086));
            OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_19816, 7,
                                                    sizeof(b_18087), &b_18087));
            OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_19816, 8,
                                                    sizeof(sigma_18088),
                                                    &sigma_18088));
            OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_19816, 9,
                                                    sizeof(x_18106), &x_18106));
            OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_19816, 10,
                                                    sizeof(x_18108), &x_18108));
            OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_19816, 11,
                                                    sizeof(y_18110), &y_18110));
            OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_19816, 12,
                                                    sizeof(y_18111), &y_18111));
            OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_19816, 13,
                                                    sizeof(sims_per_year_18188),
                                                    &sims_per_year_18188));
            OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_19816, 14,
                                                    sizeof(res_18265),
                                                    &res_18265));
            OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_19816, 15,
                                                    sizeof(res_mem_23272.mem),
                                                    &res_mem_23272.mem));
            OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_19816, 16,
                                                    sizeof(res_mem_23273.mem),
                                                    &res_mem_23273.mem));
            OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_19816, 17,
                                                    sizeof(res_mem_23274.mem),
                                                    &res_mem_23274.mem));
            OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_19816, 18,
                                                    sizeof(res_mem_23275.mem),
                                                    &res_mem_23275.mem));
            OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_19816, 19,
                                                    sizeof(mem_23303.mem),
                                                    &mem_23303.mem));
            OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_19816, 20,
                                                    sizeof(mem_23311.mem),
                                                    &mem_23311.mem));
            OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_19816, 21,
                                                    sizeof(mem_23313.mem),
                                                    &mem_23313.mem));
            if (1 * ((size_t) segmap_usable_groups_20571 *
                     (size_t) segmap_group_sizze_20570) != 0) {
                const size_t global_work_sizze_23855[1] =
                             {(size_t) segmap_usable_groups_20571 *
                             (size_t) segmap_group_sizze_20570};
                const size_t local_work_sizze_23859[1] =
                             {segmap_group_sizze_20570};
                int64_t time_start_23856 = 0, time_end_23857 = 0;
                
                if (ctx->debugging) {
                    fprintf(stderr, "Launching %s with global work size [",
                            "main.segmap_19816");
                    fprintf(stderr, "%zu", global_work_sizze_23855[0]);
                    fprintf(stderr, "] and local work size [");
                    fprintf(stderr, "%zu", local_work_sizze_23859[0]);
                    fprintf(stderr,
                            "]; local memory parameters sum to %d bytes.\n",
                            (int) 0);
                    time_start_23856 = get_wall_time();
                }
                OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->opencl.queue,
                                                                ctx->mainzisegmap_19816,
                                                                1, NULL,
                                                                global_work_sizze_23855,
                                                                local_work_sizze_23859,
                                                                0, NULL,
                                                                ctx->profiling_paused ||
                                                                !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                                          &ctx->mainzisegmap_19816_runs,
                                                                                                          &ctx->mainzisegmap_19816_total_runtime)));
                if (ctx->debugging) {
                    OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
                    time_end_23857 = get_wall_time();
                    
                    long time_diff_23858 = time_end_23857 - time_start_23856;
                    
                    fprintf(stderr, "kernel %s runtime: %ldus\n",
                            "main.segmap_19816", time_diff_23858);
                }
            }
            ctx->failure_is_an_option = 1;
            if (memblock_set_device(ctx, &res_map_acc_mem_23330, &mem_23311,
                                    "mem_23311") != 0)
                return 1;
            if (memblock_set_device(ctx, &res_mem_23331, &mem_23313,
                                    "mem_23313") != 0)
                return 1;
            if (memblock_unref_device(ctx, &mem_23313, "mem_23313") != 0)
                return 1;
            if (memblock_unref_device(ctx, &mem_23311, "mem_23311") != 0)
                return 1;
        } else {
            struct memblock_device res_map_acc_mem_23328;
            
            res_map_acc_mem_23328.references = NULL;
            
            struct memblock_device res_mem_23329;
            
            res_mem_23329.references = NULL;
            
            int32_t local_memory_capacity_23745;
            
            local_memory_capacity_23745 = ctx->opencl.max_local_memory;
            if (sle64((int32_t) sizeof(float) * paths_18081,
                      sext_i32_i64(local_memory_capacity_23745)) &&
                intra_suff_and_fits_20566) {
                struct memblock_device mem_23317;
                
                mem_23317.references = NULL;
                if (memblock_alloc_device(ctx, &mem_23317, bytes_23287,
                                          "mem_23317")) {
                    err = 1;
                    goto cleanup;
                }
                
                struct memblock_device mem_23319;
                
                mem_23319.references = NULL;
                if (memblock_alloc_device(ctx, &mem_23319, bytes_23287,
                                          "mem_23319")) {
                    err = 1;
                    goto cleanup;
                }
                OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_intragroup_19814,
                                                        1,
                                                        sizeof(ctx->failure_is_an_option),
                                                        &ctx->failure_is_an_option));
                OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_intragroup_19814,
                                                        3,
                                                        (int32_t) sizeof(float) *
                                                        paths_18081, NULL));
                OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_intragroup_19814,
                                                        4, sizeof(n_18078),
                                                        &n_18078));
                OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_intragroup_19814,
                                                        5, sizeof(paths_18081),
                                                        &paths_18081));
                OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_intragroup_19814,
                                                        6, sizeof(a_18086),
                                                        &a_18086));
                OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_intragroup_19814,
                                                        7, sizeof(b_18087),
                                                        &b_18087));
                OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_intragroup_19814,
                                                        8, sizeof(sigma_18088),
                                                        &sigma_18088));
                OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_intragroup_19814,
                                                        9, sizeof(x_18106),
                                                        &x_18106));
                OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_intragroup_19814,
                                                        10, sizeof(x_18108),
                                                        &x_18108));
                OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_intragroup_19814,
                                                        11, sizeof(y_18110),
                                                        &y_18110));
                OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_intragroup_19814,
                                                        12, sizeof(y_18111),
                                                        &y_18111));
                OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_intragroup_19814,
                                                        13,
                                                        sizeof(sims_per_year_18188),
                                                        &sims_per_year_18188));
                OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_intragroup_19814,
                                                        14, sizeof(res_18265),
                                                        &res_18265));
                OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_intragroup_19814,
                                                        15,
                                                        sizeof(res_mem_23272.mem),
                                                        &res_mem_23272.mem));
                OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_intragroup_19814,
                                                        16,
                                                        sizeof(res_mem_23273.mem),
                                                        &res_mem_23273.mem));
                OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_intragroup_19814,
                                                        17,
                                                        sizeof(res_mem_23274.mem),
                                                        &res_mem_23274.mem));
                OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_intragroup_19814,
                                                        18,
                                                        sizeof(res_mem_23275.mem),
                                                        &res_mem_23275.mem));
                OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_intragroup_19814,
                                                        19,
                                                        sizeof(mem_23303.mem),
                                                        &mem_23303.mem));
                OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_intragroup_19814,
                                                        20,
                                                        sizeof(mem_23317.mem),
                                                        &mem_23317.mem));
                OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_intragroup_19814,
                                                        21,
                                                        sizeof(mem_23319.mem),
                                                        &mem_23319.mem));
                if (1 * ((size_t) steps_18082 * (size_t) paths_18081) != 0) {
                    const size_t global_work_sizze_23860[1] =
                                 {(size_t) steps_18082 * (size_t) paths_18081};
                    const size_t local_work_sizze_23864[1] = {paths_18081};
                    int64_t time_start_23861 = 0, time_end_23862 = 0;
                    
                    if (ctx->debugging) {
                        fprintf(stderr, "Launching %s with global work size [",
                                "main.segmap_intragroup_19814");
                        fprintf(stderr, "%zu", global_work_sizze_23860[0]);
                        fprintf(stderr, "] and local work size [");
                        fprintf(stderr, "%zu", local_work_sizze_23864[0]);
                        fprintf(stderr,
                                "]; local memory parameters sum to %d bytes.\n",
                                (int) (0 + (int32_t) sizeof(float) *
                                       paths_18081));
                        time_start_23861 = get_wall_time();
                    }
                    OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->opencl.queue,
                                                                    ctx->mainzisegmap_intragroup_19814,
                                                                    1, NULL,
                                                                    global_work_sizze_23860,
                                                                    local_work_sizze_23864,
                                                                    0, NULL,
                                                                    ctx->profiling_paused ||
                                                                    !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                                              &ctx->mainzisegmap_intragroup_19814_runs,
                                                                                                              &ctx->mainzisegmap_intragroup_19814_total_runtime)));
                    if (ctx->debugging) {
                        OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
                        time_end_23862 = get_wall_time();
                        
                        long time_diff_23863 = time_end_23862 -
                             time_start_23861;
                        
                        fprintf(stderr, "kernel %s runtime: %ldus\n",
                                "main.segmap_intragroup_19814",
                                time_diff_23863);
                    }
                }
                ctx->failure_is_an_option = 1;
                if (memblock_set_device(ctx, &res_map_acc_mem_23328, &mem_23317,
                                        "mem_23317") != 0)
                    return 1;
                if (memblock_set_device(ctx, &res_mem_23329, &mem_23319,
                                        "mem_23319") != 0)
                    return 1;
                if (memblock_unref_device(ctx, &mem_23319, "mem_23319") != 0)
                    return 1;
                if (memblock_unref_device(ctx, &mem_23317, "mem_23317") != 0)
                    return 1;
            } else {
                struct memblock_device mem_23322;
                
                mem_23322.references = NULL;
                if (memblock_alloc_device(ctx, &mem_23322, bytes_23287,
                                          "mem_23322")) {
                    err = 1;
                    goto cleanup;
                }
                if (slt64(paths_18081 * 2, segred_group_sizze_20855)) {
                    int64_t segment_sizze_nonzzero_23676 = smax64(1,
                                                                  paths_18081);
                    int64_t num_threads_23677 = num_groups_20856 *
                            segred_group_sizze_20855;
                    
                    if (ctx->debugging)
                        fprintf(stderr, "%s\n", "\n# SegRed-small");
                    if (ctx->debugging)
                        fprintf(stderr, "%s: %llu%c", "num_segments",
                                (long long) steps_18082, '\n');
                    if (ctx->debugging)
                        fprintf(stderr, "%s: %llu%c", "segment_size",
                                (long long) paths_18081, '\n');
                    if (ctx->debugging)
                        fprintf(stderr, "%s: %llu%c", "segments_per_group",
                                (long long) squot64(segred_group_sizze_20855,
                                                    segment_sizze_nonzzero_23676),
                                '\n');
                    if (ctx->debugging)
                        fprintf(stderr, "%s: %llu%c", "required_groups",
                                (long long) sext_i64_i32(sdiv_up64(steps_18082,
                                                                   squot64(segred_group_sizze_20855,
                                                                           segment_sizze_nonzzero_23676))),
                                '\n');
                    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_small_20273,
                                                            1,
                                                            sizeof(ctx->failure_is_an_option),
                                                            &ctx->failure_is_an_option));
                    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_small_20273,
                                                            3,
                                                            (int32_t) sizeof(float) *
                                                            segred_group_sizze_20855,
                                                            NULL));
                    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_small_20273,
                                                            4, sizeof(n_18078),
                                                            &n_18078));
                    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_small_20273,
                                                            5,
                                                            sizeof(paths_18081),
                                                            &paths_18081));
                    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_small_20273,
                                                            6,
                                                            sizeof(steps_18082),
                                                            &steps_18082));
                    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_small_20273,
                                                            7, sizeof(a_18086),
                                                            &a_18086));
                    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_small_20273,
                                                            8, sizeof(b_18087),
                                                            &b_18087));
                    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_small_20273,
                                                            9,
                                                            sizeof(sigma_18088),
                                                            &sigma_18088));
                    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_small_20273,
                                                            10,
                                                            sizeof(sims_per_year_18188),
                                                            &sims_per_year_18188));
                    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_small_20273,
                                                            11,
                                                            sizeof(num_groups_20856),
                                                            &num_groups_20856));
                    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_small_20273,
                                                            12,
                                                            sizeof(res_mem_23272.mem),
                                                            &res_mem_23272.mem));
                    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_small_20273,
                                                            13,
                                                            sizeof(res_mem_23273.mem),
                                                            &res_mem_23273.mem));
                    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_small_20273,
                                                            14,
                                                            sizeof(res_mem_23274.mem),
                                                            &res_mem_23274.mem));
                    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_small_20273,
                                                            15,
                                                            sizeof(res_mem_23275.mem),
                                                            &res_mem_23275.mem));
                    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_small_20273,
                                                            16,
                                                            sizeof(mem_23303.mem),
                                                            &mem_23303.mem));
                    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_small_20273,
                                                            17,
                                                            sizeof(mem_23322.mem),
                                                            &mem_23322.mem));
                    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_small_20273,
                                                            18,
                                                            sizeof(segment_sizze_nonzzero_23676),
                                                            &segment_sizze_nonzzero_23676));
                    if (1 * ((size_t) num_groups_20856 *
                             (size_t) segred_group_sizze_20855) != 0) {
                        const size_t global_work_sizze_23865[1] =
                                     {(size_t) num_groups_20856 *
                                     (size_t) segred_group_sizze_20855};
                        const size_t local_work_sizze_23869[1] =
                                     {segred_group_sizze_20855};
                        int64_t time_start_23866 = 0, time_end_23867 = 0;
                        
                        if (ctx->debugging) {
                            fprintf(stderr,
                                    "Launching %s with global work size [",
                                    "main.segred_small_20273");
                            fprintf(stderr, "%zu", global_work_sizze_23865[0]);
                            fprintf(stderr, "] and local work size [");
                            fprintf(stderr, "%zu", local_work_sizze_23869[0]);
                            fprintf(stderr,
                                    "]; local memory parameters sum to %d bytes.\n",
                                    (int) (0 + (int32_t) sizeof(float) *
                                           segred_group_sizze_20855));
                            time_start_23866 = get_wall_time();
                        }
                        OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->opencl.queue,
                                                                        ctx->mainzisegred_small_20273,
                                                                        1, NULL,
                                                                        global_work_sizze_23865,
                                                                        local_work_sizze_23869,
                                                                        0, NULL,
                                                                        ctx->profiling_paused ||
                                                                        !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                                                  &ctx->mainzisegred_small_20273_runs,
                                                                                                                  &ctx->mainzisegred_small_20273_total_runtime)));
                        if (ctx->debugging) {
                            OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
                            time_end_23867 = get_wall_time();
                            
                            long time_diff_23868 = time_end_23867 -
                                 time_start_23866;
                            
                            fprintf(stderr, "kernel %s runtime: %ldus\n",
                                    "main.segred_small_20273", time_diff_23868);
                        }
                    }
                    ctx->failure_is_an_option = 1;
                } else {
                    int64_t groups_per_segment_23699 =
                            sdiv_up64(num_groups_20856, smax64(1, steps_18082));
                    int64_t elements_per_thread_23700 = sdiv_up64(paths_18081,
                                                                  segred_group_sizze_20855 *
                                                                  groups_per_segment_23699);
                    int64_t virt_num_groups_23701 = groups_per_segment_23699 *
                            steps_18082;
                    int64_t num_threads_23702 = num_groups_20856 *
                            segred_group_sizze_20855;
                    int64_t threads_per_segment_23703 =
                            groups_per_segment_23699 * segred_group_sizze_20855;
                    
                    if (ctx->debugging)
                        fprintf(stderr, "%s\n", "\n# SegRed-large");
                    if (ctx->debugging)
                        fprintf(stderr, "%s: %llu%c", "num_segments",
                                (long long) steps_18082, '\n');
                    if (ctx->debugging)
                        fprintf(stderr, "%s: %llu%c", "segment_size",
                                (long long) paths_18081, '\n');
                    if (ctx->debugging)
                        fprintf(stderr, "%s: %llu%c", "virt_num_groups",
                                (long long) virt_num_groups_23701, '\n');
                    if (ctx->debugging)
                        fprintf(stderr, "%s: %llu%c", "num_groups",
                                (long long) num_groups_20856, '\n');
                    if (ctx->debugging)
                        fprintf(stderr, "%s: %llu%c", "group_size",
                                (long long) segred_group_sizze_20855, '\n');
                    if (ctx->debugging)
                        fprintf(stderr, "%s: %llu%c", "elems_per_thread",
                                (long long) elements_per_thread_23700, '\n');
                    if (ctx->debugging)
                        fprintf(stderr, "%s: %llu%c", "groups_per_segment",
                                (long long) groups_per_segment_23699, '\n');
                    
                    struct memblock_device group_res_arr_mem_23704;
                    
                    group_res_arr_mem_23704.references = NULL;
                    if (memblock_alloc_device(ctx, &group_res_arr_mem_23704,
                                              (int32_t) sizeof(float) *
                                              (segred_group_sizze_20855 *
                                               virt_num_groups_23701),
                                              "group_res_arr_mem_23704")) {
                        err = 1;
                        goto cleanup;
                    }
                    
                    struct memblock_device mainzicounter_mem_23706 =
                                           ctx->mainzicounter_mem_23706;
                    
                    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_large_20273,
                                                            1,
                                                            sizeof(ctx->failure_is_an_option),
                                                            &ctx->failure_is_an_option));
                    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_large_20273,
                                                            3,
                                                            (int32_t) sizeof(bool),
                                                            NULL));
                    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_large_20273,
                                                            4,
                                                            (int32_t) sizeof(float) *
                                                            segred_group_sizze_20855,
                                                            NULL));
                    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_large_20273,
                                                            5, sizeof(n_18078),
                                                            &n_18078));
                    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_large_20273,
                                                            6,
                                                            sizeof(paths_18081),
                                                            &paths_18081));
                    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_large_20273,
                                                            7, sizeof(a_18086),
                                                            &a_18086));
                    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_large_20273,
                                                            8, sizeof(b_18087),
                                                            &b_18087));
                    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_large_20273,
                                                            9,
                                                            sizeof(sigma_18088),
                                                            &sigma_18088));
                    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_large_20273,
                                                            10,
                                                            sizeof(sims_per_year_18188),
                                                            &sims_per_year_18188));
                    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_large_20273,
                                                            11,
                                                            sizeof(num_groups_20856),
                                                            &num_groups_20856));
                    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_large_20273,
                                                            12,
                                                            sizeof(res_mem_23272.mem),
                                                            &res_mem_23272.mem));
                    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_large_20273,
                                                            13,
                                                            sizeof(res_mem_23273.mem),
                                                            &res_mem_23273.mem));
                    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_large_20273,
                                                            14,
                                                            sizeof(res_mem_23274.mem),
                                                            &res_mem_23274.mem));
                    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_large_20273,
                                                            15,
                                                            sizeof(res_mem_23275.mem),
                                                            &res_mem_23275.mem));
                    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_large_20273,
                                                            16,
                                                            sizeof(mem_23303.mem),
                                                            &mem_23303.mem));
                    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_large_20273,
                                                            17,
                                                            sizeof(mem_23322.mem),
                                                            &mem_23322.mem));
                    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_large_20273,
                                                            18,
                                                            sizeof(groups_per_segment_23699),
                                                            &groups_per_segment_23699));
                    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_large_20273,
                                                            19,
                                                            sizeof(elements_per_thread_23700),
                                                            &elements_per_thread_23700));
                    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_large_20273,
                                                            20,
                                                            sizeof(virt_num_groups_23701),
                                                            &virt_num_groups_23701));
                    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_large_20273,
                                                            21,
                                                            sizeof(threads_per_segment_23703),
                                                            &threads_per_segment_23703));
                    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_large_20273,
                                                            22,
                                                            sizeof(group_res_arr_mem_23704.mem),
                                                            &group_res_arr_mem_23704.mem));
                    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_large_20273,
                                                            23,
                                                            sizeof(mainzicounter_mem_23706.mem),
                                                            &mainzicounter_mem_23706.mem));
                    if (1 * ((size_t) num_groups_20856 *
                             (size_t) segred_group_sizze_20855) != 0) {
                        const size_t global_work_sizze_23871[1] =
                                     {(size_t) num_groups_20856 *
                                     (size_t) segred_group_sizze_20855};
                        const size_t local_work_sizze_23875[1] =
                                     {segred_group_sizze_20855};
                        int64_t time_start_23872 = 0, time_end_23873 = 0;
                        
                        if (ctx->debugging) {
                            fprintf(stderr,
                                    "Launching %s with global work size [",
                                    "main.segred_large_20273");
                            fprintf(stderr, "%zu", global_work_sizze_23871[0]);
                            fprintf(stderr, "] and local work size [");
                            fprintf(stderr, "%zu", local_work_sizze_23875[0]);
                            fprintf(stderr,
                                    "]; local memory parameters sum to %d bytes.\n",
                                    (int) (0 + (int32_t) sizeof(bool) +
                                           (int32_t) sizeof(float) *
                                           segred_group_sizze_20855));
                            time_start_23872 = get_wall_time();
                        }
                        OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->opencl.queue,
                                                                        ctx->mainzisegred_large_20273,
                                                                        1, NULL,
                                                                        global_work_sizze_23871,
                                                                        local_work_sizze_23875,
                                                                        0, NULL,
                                                                        ctx->profiling_paused ||
                                                                        !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                                                  &ctx->mainzisegred_large_20273_runs,
                                                                                                                  &ctx->mainzisegred_large_20273_total_runtime)));
                        if (ctx->debugging) {
                            OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
                            time_end_23873 = get_wall_time();
                            
                            long time_diff_23874 = time_end_23873 -
                                 time_start_23872;
                            
                            fprintf(stderr, "kernel %s runtime: %ldus\n",
                                    "main.segred_large_20273", time_diff_23874);
                        }
                    }
                    ctx->failure_is_an_option = 1;
                    if (memblock_unref_device(ctx, &group_res_arr_mem_23704,
                                              "group_res_arr_mem_23704") != 0)
                        return 1;
                }
                
                int64_t segmap_usable_groups_20972 = sdiv_up64(steps_18082,
                                                               segmap_group_sizze_20971);
                struct memblock_device mem_23325;
                
                mem_23325.references = NULL;
                if (memblock_alloc_device(ctx, &mem_23325, bytes_23287,
                                          "mem_23325")) {
                    err = 1;
                    goto cleanup;
                }
                
                struct memblock_device mem_23327;
                
                mem_23327.references = NULL;
                if (memblock_alloc_device(ctx, &mem_23327, bytes_23287,
                                          "mem_23327")) {
                    err = 1;
                    goto cleanup;
                }
                if (ctx->debugging)
                    fprintf(stderr, "%s\n", "\n# SegMap");
                OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_20238,
                                                        1, sizeof(steps_18082),
                                                        &steps_18082));
                OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_20238,
                                                        2, sizeof(a_18086),
                                                        &a_18086));
                OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_20238,
                                                        3, sizeof(x_18106),
                                                        &x_18106));
                OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_20238,
                                                        4, sizeof(x_18108),
                                                        &x_18108));
                OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_20238,
                                                        5, sizeof(y_18110),
                                                        &y_18110));
                OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_20238,
                                                        6, sizeof(y_18111),
                                                        &y_18111));
                OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_20238,
                                                        7,
                                                        sizeof(sims_per_year_18188),
                                                        &sims_per_year_18188));
                OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_20238,
                                                        8, sizeof(res_18265),
                                                        &res_18265));
                OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_20238,
                                                        9,
                                                        sizeof(mem_23322.mem),
                                                        &mem_23322.mem));
                OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_20238,
                                                        10,
                                                        sizeof(mem_23325.mem),
                                                        &mem_23325.mem));
                OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_20238,
                                                        11,
                                                        sizeof(mem_23327.mem),
                                                        &mem_23327.mem));
                if (1 * ((size_t) segmap_usable_groups_20972 *
                         (size_t) segmap_group_sizze_20971) != 0) {
                    const size_t global_work_sizze_23876[1] =
                                 {(size_t) segmap_usable_groups_20972 *
                                 (size_t) segmap_group_sizze_20971};
                    const size_t local_work_sizze_23880[1] =
                                 {segmap_group_sizze_20971};
                    int64_t time_start_23877 = 0, time_end_23878 = 0;
                    
                    if (ctx->debugging) {
                        fprintf(stderr, "Launching %s with global work size [",
                                "main.segmap_20238");
                        fprintf(stderr, "%zu", global_work_sizze_23876[0]);
                        fprintf(stderr, "] and local work size [");
                        fprintf(stderr, "%zu", local_work_sizze_23880[0]);
                        fprintf(stderr,
                                "]; local memory parameters sum to %d bytes.\n",
                                (int) 0);
                        time_start_23877 = get_wall_time();
                    }
                    OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->opencl.queue,
                                                                    ctx->mainzisegmap_20238,
                                                                    1, NULL,
                                                                    global_work_sizze_23876,
                                                                    local_work_sizze_23880,
                                                                    0, NULL,
                                                                    ctx->profiling_paused ||
                                                                    !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                                              &ctx->mainzisegmap_20238_runs,
                                                                                                              &ctx->mainzisegmap_20238_total_runtime)));
                    if (ctx->debugging) {
                        OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
                        time_end_23878 = get_wall_time();
                        
                        long time_diff_23879 = time_end_23878 -
                             time_start_23877;
                        
                        fprintf(stderr, "kernel %s runtime: %ldus\n",
                                "main.segmap_20238", time_diff_23879);
                    }
                }
                if (memblock_unref_device(ctx, &mem_23322, "mem_23322") != 0)
                    return 1;
                if (memblock_set_device(ctx, &res_map_acc_mem_23328, &mem_23325,
                                        "mem_23325") != 0)
                    return 1;
                if (memblock_set_device(ctx, &res_mem_23329, &mem_23327,
                                        "mem_23327") != 0)
                    return 1;
                if (memblock_unref_device(ctx, &mem_23327, "mem_23327") != 0)
                    return 1;
                if (memblock_unref_device(ctx, &mem_23325, "mem_23325") != 0)
                    return 1;
                if (memblock_unref_device(ctx, &mem_23322, "mem_23322") != 0)
                    return 1;
            }
            if (memblock_set_device(ctx, &res_map_acc_mem_23330,
                                    &res_map_acc_mem_23328,
                                    "res_map_acc_mem_23328") != 0)
                return 1;
            if (memblock_set_device(ctx, &res_mem_23331, &res_mem_23329,
                                    "res_mem_23329") != 0)
                return 1;
            if (memblock_unref_device(ctx, &res_mem_23329, "res_mem_23329") !=
                0)
                return 1;
            if (memblock_unref_device(ctx, &res_map_acc_mem_23328,
                                      "res_map_acc_mem_23328") != 0)
                return 1;
        }
        
        struct memblock_device mem_23334;
        
        mem_23334.references = NULL;
        if (memblock_alloc_device(ctx, &mem_23334, 4, "mem_23334")) {
            err = 1;
            goto cleanup;
        }
        
        struct memblock_device mainzicounter_mem_23747 =
                               ctx->mainzicounter_mem_23747;
        struct memblock_device group_res_arr_mem_23749;
        
        group_res_arr_mem_23749.references = NULL;
        if (memblock_alloc_device(ctx, &group_res_arr_mem_23749,
                                  (int32_t) sizeof(float) *
                                  (segred_group_sizze_20999 * num_groups_21000),
                                  "group_res_arr_mem_23749")) {
            err = 1;
            goto cleanup;
        }
        
        int64_t num_threads_23751;
        
        num_threads_23751 = num_groups_21000 * segred_group_sizze_20999;
        if (ctx->debugging)
            fprintf(stderr, "%s\n", "\n# SegRed");
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_nonseg_20557,
                                                1, (int32_t) sizeof(float) *
                                                segred_group_sizze_20999,
                                                NULL));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_nonseg_20557,
                                                2, (int32_t) sizeof(bool),
                                                NULL));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_nonseg_20557,
                                                3, sizeof(steps_18082),
                                                &steps_18082));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_nonseg_20557,
                                                4, sizeof(num_groups_21000),
                                                &num_groups_21000));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_nonseg_20557,
                                                5,
                                                sizeof(res_map_acc_mem_23330.mem),
                                                &res_map_acc_mem_23330.mem));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_nonseg_20557,
                                                6, sizeof(mem_23334.mem),
                                                &mem_23334.mem));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_nonseg_20557,
                                                7,
                                                sizeof(mainzicounter_mem_23747.mem),
                                                &mainzicounter_mem_23747.mem));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_nonseg_20557,
                                                8,
                                                sizeof(group_res_arr_mem_23749.mem),
                                                &group_res_arr_mem_23749.mem));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegred_nonseg_20557,
                                                9, sizeof(num_threads_23751),
                                                &num_threads_23751));
        if (1 * ((size_t) num_groups_21000 *
                 (size_t) segred_group_sizze_20999) != 0) {
            const size_t global_work_sizze_23882[1] =
                         {(size_t) num_groups_21000 *
                         (size_t) segred_group_sizze_20999};
            const size_t local_work_sizze_23886[1] = {segred_group_sizze_20999};
            int64_t time_start_23883 = 0, time_end_23884 = 0;
            
            if (ctx->debugging) {
                fprintf(stderr, "Launching %s with global work size [",
                        "main.segred_nonseg_20557");
                fprintf(stderr, "%zu", global_work_sizze_23882[0]);
                fprintf(stderr, "] and local work size [");
                fprintf(stderr, "%zu", local_work_sizze_23886[0]);
                fprintf(stderr, "]; local memory parameters sum to %d bytes.\n",
                        (int) (0 + (int32_t) sizeof(float) *
                               segred_group_sizze_20999 +
                               (int32_t) sizeof(bool)));
                time_start_23883 = get_wall_time();
            }
            OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->opencl.queue,
                                                            ctx->mainzisegred_nonseg_20557,
                                                            1, NULL,
                                                            global_work_sizze_23882,
                                                            local_work_sizze_23886,
                                                            0, NULL,
                                                            ctx->profiling_paused ||
                                                            !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                                      &ctx->mainzisegred_nonseg_20557_runs,
                                                                                                      &ctx->mainzisegred_nonseg_20557_total_runtime)));
            if (ctx->debugging) {
                OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
                time_end_23884 = get_wall_time();
                
                long time_diff_23885 = time_end_23884 - time_start_23883;
                
                fprintf(stderr, "kernel %s runtime: %ldus\n",
                        "main.segred_nonseg_20557", time_diff_23885);
            }
        }
        if (memblock_unref_device(ctx, &res_map_acc_mem_23330,
                                  "res_map_acc_mem_23330") != 0)
            return 1;
        
        float read_res_23887;
        
        OPENCL_SUCCEED_OR_RETURN(clEnqueueReadBuffer(ctx->opencl.queue,
                                                     mem_23334.mem,
                                                     ctx->failure_is_an_option ? CL_FALSE : CL_TRUE,
                                                     0 * sizeof(float),
                                                     sizeof(float),
                                                     &read_res_23887, 0, NULL,
                                                     ctx->profiling_paused ||
                                                     !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                               &ctx->copy_scalar_from_dev_runs,
                                                                                               &ctx->copy_scalar_from_dev_total_runtime)));
        if (ctx->failure_is_an_option && futhark_context_sync(ctx) != 0)
            return 1;
        
        float res_21007 = read_res_23887;
        
        if (memblock_unref_device(ctx, &mem_23334, "mem_23334") != 0)
            return 1;
        if (memblock_set_device(ctx, &res_mem_23338, &res_mem_23331,
                                "res_mem_23331") != 0)
            return 1;
        res_18386 = res_21007;
        if (memblock_unref_device(ctx, &group_res_arr_mem_23749,
                                  "group_res_arr_mem_23749") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_23334, "mem_23334") != 0)
            return 1;
        if (memblock_unref_device(ctx, &res_mem_23331, "res_mem_23331") != 0)
            return 1;
        if (memblock_unref_device(ctx, &res_map_acc_mem_23330,
                                  "res_map_acc_mem_23330") != 0)
            return 1;
    }
    if (memblock_unref_device(ctx, &res_mem_23272, "res_mem_23272") != 0)
        return 1;
    if (memblock_unref_device(ctx, &res_mem_23273, "res_mem_23273") != 0)
        return 1;
    if (memblock_unref_device(ctx, &res_mem_23274, "res_mem_23274") != 0)
        return 1;
    if (memblock_unref_device(ctx, &res_mem_23275, "res_mem_23275") != 0)
        return 1;
    if (memblock_unref_device(ctx, &mem_23303, "mem_23303") != 0)
        return 1;
    
    float CVA_18527 = 6.0e-3F * res_18386;
    
    out_arrsizze_23491 = steps_18082;
    if (memblock_set_device(ctx, &out_mem_23490, &res_mem_23338,
                            "res_mem_23338") != 0)
        return 1;
    scalar_out_23489 = CVA_18527;
    *out_scalar_out_23799 = scalar_out_23489;
    (*out_mem_p_23800).references = NULL;
    if (memblock_set_device(ctx, &*out_mem_p_23800, &out_mem_23490,
                            "out_mem_23490") != 0)
        return 1;
    *out_out_arrsizze_23801 = out_arrsizze_23491;
    if (memblock_unref_device(ctx, &res_mem_23338, "res_mem_23338") != 0)
        return 1;
    if (memblock_unref_device(ctx, &mem_23288, "mem_23288") != 0)
        return 1;
    if (memblock_unref_device(ctx, &mem_23303, "mem_23303") != 0)
        return 1;
    if (memblock_unref_device(ctx, &mem_23285, "mem_23285") != 0)
        return 1;
    if (memblock_unref_device(ctx, &mem_23282, "mem_23282") != 0)
        return 1;
    if (memblock_unref_device(ctx, &mem_23278, "mem_23278") != 0)
        return 1;
    if (memblock_unref_device(ctx, &res_mem_23275, "res_mem_23275") != 0)
        return 1;
    if (memblock_unref_device(ctx, &res_mem_23274, "res_mem_23274") != 0)
        return 1;
    if (memblock_unref_device(ctx, &res_mem_23273, "res_mem_23273") != 0)
        return 1;
    if (memblock_unref_device(ctx, &res_mem_23272, "res_mem_23272") != 0)
        return 1;
    if (memblock_unref_device(ctx, &group_res_arr_mem_23495,
                              "group_res_arr_mem_23495") != 0)
        return 1;
    if (memblock_unref_device(ctx, &mem_23225, "mem_23225") != 0)
        return 1;
    if (memblock_unref_device(ctx, &out_mem_23490, "out_mem_23490") != 0)
        return 1;
    
  cleanup:
    { }
    return err;
}
static int futrts_test(struct futhark_context *ctx, float *out_scalar_out_23888,
                       int64_t paths_18528, int64_t steps_18529)
{
    (void) ctx;
    
    int err = 0;
    float scalar_out_23489;
    struct memblock_device mem_23221;
    
    mem_23221.references = NULL;
    if (memblock_alloc_device(ctx, &mem_23221, 36, "mem_23221")) {
        err = 1;
        goto cleanup;
    }
    
    struct memblock_device testzistatic_array_23490 =
                           ctx->testzistatic_array_23490;
    
    if (9 * (int32_t) sizeof(float) > 0) {
        OPENCL_SUCCEED_OR_RETURN(clEnqueueCopyBuffer(ctx->opencl.queue,
                                                     testzistatic_array_23490.mem,
                                                     mem_23221.mem, 0, 0, 9 *
                                                     (int32_t) sizeof(float), 0,
                                                     NULL,
                                                     ctx->profiling_paused ||
                                                     !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                               &ctx->copy_dev_to_dev_runs,
                                                                                               &ctx->copy_dev_to_dev_total_runtime)));
        if (ctx->debugging)
            OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
    }
    
    struct memblock_device mem_23223;
    
    mem_23223.references = NULL;
    if (memblock_alloc_device(ctx, &mem_23223, 72, "mem_23223")) {
        err = 1;
        goto cleanup;
    }
    
    struct memblock_device testzistatic_array_23491 =
                           ctx->testzistatic_array_23491;
    
    if (9 * (int32_t) sizeof(int64_t) > 0) {
        OPENCL_SUCCEED_OR_RETURN(clEnqueueCopyBuffer(ctx->opencl.queue,
                                                     testzistatic_array_23491.mem,
                                                     mem_23223.mem, 0, 0, 9 *
                                                     (int32_t) sizeof(int64_t),
                                                     0, NULL,
                                                     ctx->profiling_paused ||
                                                     !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                               &ctx->copy_dev_to_dev_runs,
                                                                                               &ctx->copy_dev_to_dev_total_runtime)));
        if (ctx->debugging)
            OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
    }
    
    struct memblock_device mem_23225;
    
    mem_23225.references = NULL;
    if (memblock_alloc_device(ctx, &mem_23225, 36, "mem_23225")) {
        err = 1;
        goto cleanup;
    }
    
    struct memblock_device testzistatic_array_23492 =
                           ctx->testzistatic_array_23492;
    
    if (9 * (int32_t) sizeof(float) > 0) {
        OPENCL_SUCCEED_OR_RETURN(clEnqueueCopyBuffer(ctx->opencl.queue,
                                                     testzistatic_array_23492.mem,
                                                     mem_23225.mem, 0, 0, 9 *
                                                     (int32_t) sizeof(float), 0,
                                                     NULL,
                                                     ctx->profiling_paused ||
                                                     !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                               &ctx->copy_dev_to_dev_runs,
                                                                                               &ctx->copy_dev_to_dev_total_runtime)));
        if (ctx->debugging)
            OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
    }
    
    int64_t segred_group_sizze_21012;
    
    segred_group_sizze_21012 = ctx->sizes.testzisegred_group_sizze_21011;
    
    int64_t num_groups_21014;
    int32_t max_num_groups_23493;
    
    max_num_groups_23493 = ctx->sizes.testzisegred_num_groups_21013;
    num_groups_21014 = sext_i64_i32(smax64(1, smin64(sdiv_up64(9,
                                                               sext_i32_i64(segred_group_sizze_21012)),
                                                     sext_i32_i64(max_num_groups_23493))));
    
    struct memblock_device mem_23228;
    
    mem_23228.references = NULL;
    if (memblock_alloc_device(ctx, &mem_23228, 4, "mem_23228")) {
        err = 1;
        goto cleanup;
    }
    
    struct memblock_device testzicounter_mem_23494 =
                           ctx->testzicounter_mem_23494;
    struct memblock_device group_res_arr_mem_23496;
    
    group_res_arr_mem_23496.references = NULL;
    if (memblock_alloc_device(ctx, &group_res_arr_mem_23496,
                              (int32_t) sizeof(float) *
                              (segred_group_sizze_21012 * num_groups_21014),
                              "group_res_arr_mem_23496")) {
        err = 1;
        goto cleanup;
    }
    
    int64_t num_threads_23498;
    
    num_threads_23498 = num_groups_21014 * segred_group_sizze_21012;
    if (ctx->debugging)
        fprintf(stderr, "%s\n", "\n# SegRed");
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegred_nonseg_21019, 1,
                                            (int32_t) sizeof(float) *
                                            segred_group_sizze_21012, NULL));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegred_nonseg_21019, 2,
                                            (int32_t) sizeof(bool), NULL));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegred_nonseg_21019, 3,
                                            sizeof(num_groups_21014),
                                            &num_groups_21014));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegred_nonseg_21019, 4,
                                            sizeof(mem_23223.mem),
                                            &mem_23223.mem));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegred_nonseg_21019, 5,
                                            sizeof(mem_23225.mem),
                                            &mem_23225.mem));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegred_nonseg_21019, 6,
                                            sizeof(mem_23228.mem),
                                            &mem_23228.mem));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegred_nonseg_21019, 7,
                                            sizeof(testzicounter_mem_23494.mem),
                                            &testzicounter_mem_23494.mem));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegred_nonseg_21019, 8,
                                            sizeof(group_res_arr_mem_23496.mem),
                                            &group_res_arr_mem_23496.mem));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegred_nonseg_21019, 9,
                                            sizeof(num_threads_23498),
                                            &num_threads_23498));
    if (1 * ((size_t) num_groups_21014 * (size_t) segred_group_sizze_21012) !=
        0) {
        const size_t global_work_sizze_23893[1] = {(size_t) num_groups_21014 *
                     (size_t) segred_group_sizze_21012};
        const size_t local_work_sizze_23897[1] = {segred_group_sizze_21012};
        int64_t time_start_23894 = 0, time_end_23895 = 0;
        
        if (ctx->debugging) {
            fprintf(stderr, "Launching %s with global work size [",
                    "test.segred_nonseg_21019");
            fprintf(stderr, "%zu", global_work_sizze_23893[0]);
            fprintf(stderr, "] and local work size [");
            fprintf(stderr, "%zu", local_work_sizze_23897[0]);
            fprintf(stderr, "]; local memory parameters sum to %d bytes.\n",
                    (int) (0 + (int32_t) sizeof(float) *
                           segred_group_sizze_21012 + (int32_t) sizeof(bool)));
            time_start_23894 = get_wall_time();
        }
        OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->opencl.queue,
                                                        ctx->testzisegred_nonseg_21019,
                                                        1, NULL,
                                                        global_work_sizze_23893,
                                                        local_work_sizze_23897,
                                                        0, NULL,
                                                        ctx->profiling_paused ||
                                                        !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                                  &ctx->testzisegred_nonseg_21019_runs,
                                                                                                  &ctx->testzisegred_nonseg_21019_total_runtime)));
        if (ctx->debugging) {
            OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
            time_end_23895 = get_wall_time();
            
            long time_diff_23896 = time_end_23895 - time_start_23894;
            
            fprintf(stderr, "kernel %s runtime: %ldus\n",
                    "test.segred_nonseg_21019", time_diff_23896);
        }
    }
    
    float read_res_23898;
    
    OPENCL_SUCCEED_OR_RETURN(clEnqueueReadBuffer(ctx->opencl.queue,
                                                 mem_23228.mem,
                                                 ctx->failure_is_an_option ? CL_FALSE : CL_TRUE,
                                                 0 * sizeof(float),
                                                 sizeof(float), &read_res_23898,
                                                 0, NULL,
                                                 ctx->profiling_paused ||
                                                 !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                           &ctx->copy_scalar_from_dev_runs,
                                                                                           &ctx->copy_scalar_from_dev_total_runtime)));
    if (ctx->failure_is_an_option && futhark_context_sync(ctx) != 0)
        return 1;
    
    float res_18533 = read_res_23898;
    
    if (memblock_unref_device(ctx, &mem_23228, "mem_23228") != 0)
        return 1;
    
    float res_18541 = sitofp_i64_f32(steps_18529);
    float dt_18542 = res_18533 / res_18541;
    bool suff_outer_par_21021;
    
    suff_outer_par_21021 = ctx->sizes.testzisuff_outer_par_0 <= 9;
    if (ctx->logging)
        fprintf(stderr, "Compared %s <= %d.\n", "test.suff_outer_par_0", 9);
    
    int64_t segmap_group_sizze_21111;
    
    segmap_group_sizze_21111 = ctx->sizes.testzisegmap_group_sizze_21035;
    
    int64_t segmap_group_sizze_21287;
    
    segmap_group_sizze_21287 = ctx->sizes.testzisegmap_group_sizze_21211;
    
    int64_t segred_num_groups_23425;
    
    segred_num_groups_23425 = ctx->sizes.testzisegred_num_groups_23424;
    
    int64_t segred_group_sizze_23427;
    
    segred_group_sizze_23427 = ctx->sizes.testzisegred_group_sizze_23426;
    
    int64_t segred_num_groups_23457;
    
    segred_num_groups_23457 = ctx->sizes.testzisegred_num_groups_23456;
    
    int64_t segred_group_sizze_23459;
    
    segred_group_sizze_23459 = ctx->sizes.testzisegred_group_sizze_23458;
    
    struct memblock_device res_mem_23275;
    
    res_mem_23275.references = NULL;
    
    struct memblock_device res_mem_23276;
    
    res_mem_23276.references = NULL;
    
    struct memblock_device res_mem_23277;
    
    res_mem_23277.references = NULL;
    
    struct memblock_device res_mem_23278;
    
    res_mem_23278.references = NULL;
    
    int32_t local_memory_capacity_23598;
    
    local_memory_capacity_23598 = ctx->opencl.max_local_memory;
    if ((sle64((int32_t) sizeof(bool) + (int32_t) sizeof(int64_t) *
               segred_group_sizze_23427,
               sext_i32_i64(local_memory_capacity_23598)) && sle64(0,
                                                                   sext_i32_i64(local_memory_capacity_23598))) &&
        suff_outer_par_21021) {
        int64_t segmap_usable_groups_21112 = sdiv_up64(9,
                                                       segmap_group_sizze_21111);
        struct memblock_device mem_23230;
        
        mem_23230.references = NULL;
        if (memblock_alloc_device(ctx, &mem_23230, 36, "mem_23230")) {
            err = 1;
            goto cleanup;
        }
        if (9 * (int32_t) sizeof(float) > 0) {
            OPENCL_SUCCEED_OR_RETURN(clEnqueueCopyBuffer(ctx->opencl.queue,
                                                         mem_23225.mem,
                                                         mem_23230.mem, 0, 0,
                                                         9 *
                                                         (int32_t) sizeof(float),
                                                         0, NULL,
                                                         ctx->profiling_paused ||
                                                         !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                                   &ctx->copy_dev_to_dev_runs,
                                                                                                   &ctx->copy_dev_to_dev_total_runtime)));
            if (ctx->debugging)
                OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
        }
        
        struct memblock_device mem_23232;
        
        mem_23232.references = NULL;
        if (memblock_alloc_device(ctx, &mem_23232, 72, "mem_23232")) {
            err = 1;
            goto cleanup;
        }
        if (9 * (int32_t) sizeof(int64_t) > 0) {
            OPENCL_SUCCEED_OR_RETURN(clEnqueueCopyBuffer(ctx->opencl.queue,
                                                         mem_23223.mem,
                                                         mem_23232.mem, 0, 0,
                                                         9 *
                                                         (int32_t) sizeof(int64_t),
                                                         0, NULL,
                                                         ctx->profiling_paused ||
                                                         !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                                   &ctx->copy_dev_to_dev_runs,
                                                                                                   &ctx->copy_dev_to_dev_total_runtime)));
            if (ctx->debugging)
                OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
        }
        
        struct memblock_device mem_23234;
        
        mem_23234.references = NULL;
        if (memblock_alloc_device(ctx, &mem_23234, 36, "mem_23234")) {
            err = 1;
            goto cleanup;
        }
        if (9 * (int32_t) sizeof(float) > 0) {
            OPENCL_SUCCEED_OR_RETURN(clEnqueueCopyBuffer(ctx->opencl.queue,
                                                         mem_23221.mem,
                                                         mem_23234.mem, 0, 0,
                                                         9 *
                                                         (int32_t) sizeof(float),
                                                         0, NULL,
                                                         ctx->profiling_paused ||
                                                         !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                                   &ctx->copy_dev_to_dev_runs,
                                                                                                   &ctx->copy_dev_to_dev_total_runtime)));
            if (ctx->debugging)
                OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
        }
        
        struct memblock_device mem_23251;
        
        mem_23251.references = NULL;
        if (memblock_alloc_device(ctx, &mem_23251, 36, "mem_23251")) {
            err = 1;
            goto cleanup;
        }
        
        int64_t num_threads_23415 = segmap_group_sizze_21111 *
                segmap_usable_groups_21112;
        struct memblock_device mem_23443;
        
        mem_23443.references = NULL;
        if (memblock_alloc_device(ctx, &mem_23443, 8, "mem_23443")) {
            err = 1;
            goto cleanup;
        }
        
        struct memblock_device testzicounter_mem_23524 =
                               ctx->testzicounter_mem_23524;
        struct memblock_device group_res_arr_mem_23526;
        
        group_res_arr_mem_23526.references = NULL;
        if (memblock_alloc_device(ctx, &group_res_arr_mem_23526,
                                  (int32_t) sizeof(int64_t) *
                                  (segred_group_sizze_23427 *
                                   segred_num_groups_23425),
                                  "group_res_arr_mem_23526")) {
            err = 1;
            goto cleanup;
        }
        
        int64_t num_threads_23528;
        
        num_threads_23528 = segred_num_groups_23425 * segred_group_sizze_23427;
        if (ctx->debugging)
            fprintf(stderr, "%s\n", "\n# SegRed");
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegred_nonseg_23431,
                                                1, (int32_t) sizeof(int64_t) *
                                                segred_group_sizze_23427,
                                                NULL));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegred_nonseg_23431,
                                                2, (int32_t) sizeof(bool),
                                                NULL));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegred_nonseg_23431,
                                                3, sizeof(mem_23223.mem),
                                                &mem_23223.mem));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegred_nonseg_23431,
                                                4, sizeof(mem_23443.mem),
                                                &mem_23443.mem));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegred_nonseg_23431,
                                                5,
                                                sizeof(testzicounter_mem_23524.mem),
                                                &testzicounter_mem_23524.mem));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegred_nonseg_23431,
                                                6,
                                                sizeof(group_res_arr_mem_23526.mem),
                                                &group_res_arr_mem_23526.mem));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegred_nonseg_23431,
                                                7, sizeof(num_threads_23528),
                                                &num_threads_23528));
        if (1 * ((size_t) segred_num_groups_23425 *
                 (size_t) segred_group_sizze_23427) != 0) {
            const size_t global_work_sizze_23900[1] =
                         {(size_t) segred_num_groups_23425 *
                         (size_t) segred_group_sizze_23427};
            const size_t local_work_sizze_23904[1] = {segred_group_sizze_23427};
            int64_t time_start_23901 = 0, time_end_23902 = 0;
            
            if (ctx->debugging) {
                fprintf(stderr, "Launching %s with global work size [",
                        "test.segred_nonseg_23431");
                fprintf(stderr, "%zu", global_work_sizze_23900[0]);
                fprintf(stderr, "] and local work size [");
                fprintf(stderr, "%zu", local_work_sizze_23904[0]);
                fprintf(stderr, "]; local memory parameters sum to %d bytes.\n",
                        (int) (0 + (int32_t) sizeof(int64_t) *
                               segred_group_sizze_23427 +
                               (int32_t) sizeof(bool)));
                time_start_23901 = get_wall_time();
            }
            OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->opencl.queue,
                                                            ctx->testzisegred_nonseg_23431,
                                                            1, NULL,
                                                            global_work_sizze_23900,
                                                            local_work_sizze_23904,
                                                            0, NULL,
                                                            ctx->profiling_paused ||
                                                            !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                                      &ctx->testzisegred_nonseg_23431_runs,
                                                                                                      &ctx->testzisegred_nonseg_23431_total_runtime)));
            if (ctx->debugging) {
                OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
                time_end_23902 = get_wall_time();
                
                long time_diff_23903 = time_end_23902 - time_start_23901;
                
                fprintf(stderr, "kernel %s runtime: %ldus\n",
                        "test.segred_nonseg_23431", time_diff_23903);
            }
        }
        
        int64_t read_res_23905;
        
        OPENCL_SUCCEED_OR_RETURN(clEnqueueReadBuffer(ctx->opencl.queue,
                                                     mem_23443.mem,
                                                     ctx->failure_is_an_option ? CL_FALSE : CL_TRUE,
                                                     0 * sizeof(int64_t),
                                                     sizeof(int64_t),
                                                     &read_res_23905, 0, NULL,
                                                     ctx->profiling_paused ||
                                                     !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                               &ctx->copy_scalar_from_dev_runs,
                                                                                               &ctx->copy_scalar_from_dev_total_runtime)));
        if (ctx->failure_is_an_option && futhark_context_sync(ctx) != 0)
            return 1;
        
        int64_t max_per_thread_23421 = read_res_23905;
        
        if (memblock_unref_device(ctx, &mem_23443, "mem_23443") != 0)
            return 1;
        
        int64_t sizze_sum_23438 = num_threads_23415 * max_per_thread_23421;
        struct memblock_device mem_23237;
        
        mem_23237.references = NULL;
        if (memblock_alloc_device(ctx, &mem_23237, sizze_sum_23438,
                                  "mem_23237")) {
            err = 1;
            goto cleanup;
        }
        if (ctx->debugging)
            fprintf(stderr, "%s\n", "\n# SegMap");
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegmap_21033, 1,
                                                sizeof(ctx->failure_is_an_option),
                                                &ctx->failure_is_an_option));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegmap_21033, 3,
                                                sizeof(mem_23223.mem),
                                                &mem_23223.mem));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegmap_21033, 4,
                                                sizeof(mem_23225.mem),
                                                &mem_23225.mem));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegmap_21033, 5,
                                                sizeof(mem_23237.mem),
                                                &mem_23237.mem));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegmap_21033, 6,
                                                sizeof(mem_23251.mem),
                                                &mem_23251.mem));
        if (1 * ((size_t) segmap_usable_groups_21112 *
                 (size_t) segmap_group_sizze_21111) != 0) {
            const size_t global_work_sizze_23906[1] =
                         {(size_t) segmap_usable_groups_21112 *
                         (size_t) segmap_group_sizze_21111};
            const size_t local_work_sizze_23910[1] = {segmap_group_sizze_21111};
            int64_t time_start_23907 = 0, time_end_23908 = 0;
            
            if (ctx->debugging) {
                fprintf(stderr, "Launching %s with global work size [",
                        "test.segmap_21033");
                fprintf(stderr, "%zu", global_work_sizze_23906[0]);
                fprintf(stderr, "] and local work size [");
                fprintf(stderr, "%zu", local_work_sizze_23910[0]);
                fprintf(stderr, "]; local memory parameters sum to %d bytes.\n",
                        (int) 0);
                time_start_23907 = get_wall_time();
            }
            OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->opencl.queue,
                                                            ctx->testzisegmap_21033,
                                                            1, NULL,
                                                            global_work_sizze_23906,
                                                            local_work_sizze_23910,
                                                            0, NULL,
                                                            ctx->profiling_paused ||
                                                            !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                                      &ctx->testzisegmap_21033_runs,
                                                                                                      &ctx->testzisegmap_21033_total_runtime)));
            if (ctx->debugging) {
                OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
                time_end_23908 = get_wall_time();
                
                long time_diff_23909 = time_end_23908 - time_start_23907;
                
                fprintf(stderr, "kernel %s runtime: %ldus\n",
                        "test.segmap_21033", time_diff_23909);
            }
        }
        ctx->failure_is_an_option = 1;
        if (memblock_unref_device(ctx, &mem_23237, "mem_23237") != 0)
            return 1;
        if (memblock_set_device(ctx, &res_mem_23275, &mem_23251, "mem_23251") !=
            0)
            return 1;
        if (memblock_set_device(ctx, &res_mem_23276, &mem_23234, "mem_23234") !=
            0)
            return 1;
        if (memblock_set_device(ctx, &res_mem_23277, &mem_23232, "mem_23232") !=
            0)
            return 1;
        if (memblock_set_device(ctx, &res_mem_23278, &mem_23230, "mem_23230") !=
            0)
            return 1;
        if (memblock_unref_device(ctx, &mem_23237, "mem_23237") != 0)
            return 1;
        if (memblock_unref_device(ctx, &group_res_arr_mem_23526,
                                  "group_res_arr_mem_23526") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_23443, "mem_23443") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_23251, "mem_23251") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_23234, "mem_23234") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_23232, "mem_23232") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_23230, "mem_23230") != 0)
            return 1;
    } else {
        int64_t segmap_usable_groups_21288 = sdiv_up64(9,
                                                       segmap_group_sizze_21287);
        struct memblock_device mem_23253;
        
        mem_23253.references = NULL;
        if (memblock_alloc_device(ctx, &mem_23253, 36, "mem_23253")) {
            err = 1;
            goto cleanup;
        }
        if (9 * (int32_t) sizeof(float) > 0) {
            OPENCL_SUCCEED_OR_RETURN(clEnqueueCopyBuffer(ctx->opencl.queue,
                                                         mem_23225.mem,
                                                         mem_23253.mem, 0, 0,
                                                         9 *
                                                         (int32_t) sizeof(float),
                                                         0, NULL,
                                                         ctx->profiling_paused ||
                                                         !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                                   &ctx->copy_dev_to_dev_runs,
                                                                                                   &ctx->copy_dev_to_dev_total_runtime)));
            if (ctx->debugging)
                OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
        }
        
        struct memblock_device mem_23255;
        
        mem_23255.references = NULL;
        if (memblock_alloc_device(ctx, &mem_23255, 72, "mem_23255")) {
            err = 1;
            goto cleanup;
        }
        if (9 * (int32_t) sizeof(int64_t) > 0) {
            OPENCL_SUCCEED_OR_RETURN(clEnqueueCopyBuffer(ctx->opencl.queue,
                                                         mem_23223.mem,
                                                         mem_23255.mem, 0, 0,
                                                         9 *
                                                         (int32_t) sizeof(int64_t),
                                                         0, NULL,
                                                         ctx->profiling_paused ||
                                                         !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                                   &ctx->copy_dev_to_dev_runs,
                                                                                                   &ctx->copy_dev_to_dev_total_runtime)));
            if (ctx->debugging)
                OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
        }
        
        struct memblock_device mem_23257;
        
        mem_23257.references = NULL;
        if (memblock_alloc_device(ctx, &mem_23257, 36, "mem_23257")) {
            err = 1;
            goto cleanup;
        }
        if (9 * (int32_t) sizeof(float) > 0) {
            OPENCL_SUCCEED_OR_RETURN(clEnqueueCopyBuffer(ctx->opencl.queue,
                                                         mem_23221.mem,
                                                         mem_23257.mem, 0, 0,
                                                         9 *
                                                         (int32_t) sizeof(float),
                                                         0, NULL,
                                                         ctx->profiling_paused ||
                                                         !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                                   &ctx->copy_dev_to_dev_runs,
                                                                                                   &ctx->copy_dev_to_dev_total_runtime)));
            if (ctx->debugging)
                OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
        }
        
        struct memblock_device mem_23274;
        
        mem_23274.references = NULL;
        if (memblock_alloc_device(ctx, &mem_23274, 36, "mem_23274")) {
            err = 1;
            goto cleanup;
        }
        
        int64_t num_threads_23447 = segmap_group_sizze_21287 *
                segmap_usable_groups_21288;
        struct memblock_device mem_23475;
        
        mem_23475.references = NULL;
        if (memblock_alloc_device(ctx, &mem_23475, 8, "mem_23475")) {
            err = 1;
            goto cleanup;
        }
        
        struct memblock_device testzicounter_mem_23561 =
                               ctx->testzicounter_mem_23561;
        struct memblock_device group_res_arr_mem_23563;
        
        group_res_arr_mem_23563.references = NULL;
        if (memblock_alloc_device(ctx, &group_res_arr_mem_23563,
                                  (int32_t) sizeof(int64_t) *
                                  (segred_group_sizze_23459 *
                                   segred_num_groups_23457),
                                  "group_res_arr_mem_23563")) {
            err = 1;
            goto cleanup;
        }
        
        int64_t num_threads_23565;
        
        num_threads_23565 = segred_num_groups_23457 * segred_group_sizze_23459;
        if (ctx->debugging)
            fprintf(stderr, "%s\n", "\n# SegRed");
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegred_nonseg_23463,
                                                1, (int32_t) sizeof(int64_t) *
                                                segred_group_sizze_23459,
                                                NULL));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegred_nonseg_23463,
                                                2, (int32_t) sizeof(bool),
                                                NULL));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegred_nonseg_23463,
                                                3, sizeof(mem_23223.mem),
                                                &mem_23223.mem));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegred_nonseg_23463,
                                                4, sizeof(mem_23475.mem),
                                                &mem_23475.mem));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegred_nonseg_23463,
                                                5,
                                                sizeof(testzicounter_mem_23561.mem),
                                                &testzicounter_mem_23561.mem));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegred_nonseg_23463,
                                                6,
                                                sizeof(group_res_arr_mem_23563.mem),
                                                &group_res_arr_mem_23563.mem));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegred_nonseg_23463,
                                                7, sizeof(num_threads_23565),
                                                &num_threads_23565));
        if (1 * ((size_t) segred_num_groups_23457 *
                 (size_t) segred_group_sizze_23459) != 0) {
            const size_t global_work_sizze_23912[1] =
                         {(size_t) segred_num_groups_23457 *
                         (size_t) segred_group_sizze_23459};
            const size_t local_work_sizze_23916[1] = {segred_group_sizze_23459};
            int64_t time_start_23913 = 0, time_end_23914 = 0;
            
            if (ctx->debugging) {
                fprintf(stderr, "Launching %s with global work size [",
                        "test.segred_nonseg_23463");
                fprintf(stderr, "%zu", global_work_sizze_23912[0]);
                fprintf(stderr, "] and local work size [");
                fprintf(stderr, "%zu", local_work_sizze_23916[0]);
                fprintf(stderr, "]; local memory parameters sum to %d bytes.\n",
                        (int) (0 + (int32_t) sizeof(int64_t) *
                               segred_group_sizze_23459 +
                               (int32_t) sizeof(bool)));
                time_start_23913 = get_wall_time();
            }
            OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->opencl.queue,
                                                            ctx->testzisegred_nonseg_23463,
                                                            1, NULL,
                                                            global_work_sizze_23912,
                                                            local_work_sizze_23916,
                                                            0, NULL,
                                                            ctx->profiling_paused ||
                                                            !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                                      &ctx->testzisegred_nonseg_23463_runs,
                                                                                                      &ctx->testzisegred_nonseg_23463_total_runtime)));
            if (ctx->debugging) {
                OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
                time_end_23914 = get_wall_time();
                
                long time_diff_23915 = time_end_23914 - time_start_23913;
                
                fprintf(stderr, "kernel %s runtime: %ldus\n",
                        "test.segred_nonseg_23463", time_diff_23915);
            }
        }
        
        int64_t read_res_23917;
        
        OPENCL_SUCCEED_OR_RETURN(clEnqueueReadBuffer(ctx->opencl.queue,
                                                     mem_23475.mem,
                                                     ctx->failure_is_an_option ? CL_FALSE : CL_TRUE,
                                                     0 * sizeof(int64_t),
                                                     sizeof(int64_t),
                                                     &read_res_23917, 0, NULL,
                                                     ctx->profiling_paused ||
                                                     !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                               &ctx->copy_scalar_from_dev_runs,
                                                                                               &ctx->copy_scalar_from_dev_total_runtime)));
        if (ctx->failure_is_an_option && futhark_context_sync(ctx) != 0)
            return 1;
        
        int64_t max_per_thread_23453 = read_res_23917;
        
        if (memblock_unref_device(ctx, &mem_23475, "mem_23475") != 0)
            return 1;
        
        int64_t sizze_sum_23470 = num_threads_23447 * max_per_thread_23453;
        struct memblock_device mem_23260;
        
        mem_23260.references = NULL;
        if (memblock_alloc_device(ctx, &mem_23260, sizze_sum_23470,
                                  "mem_23260")) {
            err = 1;
            goto cleanup;
        }
        if (ctx->debugging)
            fprintf(stderr, "%s\n", "\n# SegMap");
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegmap_21209, 1,
                                                sizeof(ctx->failure_is_an_option),
                                                &ctx->failure_is_an_option));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegmap_21209, 3,
                                                sizeof(mem_23223.mem),
                                                &mem_23223.mem));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegmap_21209, 4,
                                                sizeof(mem_23225.mem),
                                                &mem_23225.mem));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegmap_21209, 5,
                                                sizeof(mem_23260.mem),
                                                &mem_23260.mem));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegmap_21209, 6,
                                                sizeof(mem_23274.mem),
                                                &mem_23274.mem));
        if (1 * ((size_t) segmap_usable_groups_21288 *
                 (size_t) segmap_group_sizze_21287) != 0) {
            const size_t global_work_sizze_23918[1] =
                         {(size_t) segmap_usable_groups_21288 *
                         (size_t) segmap_group_sizze_21287};
            const size_t local_work_sizze_23922[1] = {segmap_group_sizze_21287};
            int64_t time_start_23919 = 0, time_end_23920 = 0;
            
            if (ctx->debugging) {
                fprintf(stderr, "Launching %s with global work size [",
                        "test.segmap_21209");
                fprintf(stderr, "%zu", global_work_sizze_23918[0]);
                fprintf(stderr, "] and local work size [");
                fprintf(stderr, "%zu", local_work_sizze_23922[0]);
                fprintf(stderr, "]; local memory parameters sum to %d bytes.\n",
                        (int) 0);
                time_start_23919 = get_wall_time();
            }
            OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->opencl.queue,
                                                            ctx->testzisegmap_21209,
                                                            1, NULL,
                                                            global_work_sizze_23918,
                                                            local_work_sizze_23922,
                                                            0, NULL,
                                                            ctx->profiling_paused ||
                                                            !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                                      &ctx->testzisegmap_21209_runs,
                                                                                                      &ctx->testzisegmap_21209_total_runtime)));
            if (ctx->debugging) {
                OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
                time_end_23920 = get_wall_time();
                
                long time_diff_23921 = time_end_23920 - time_start_23919;
                
                fprintf(stderr, "kernel %s runtime: %ldus\n",
                        "test.segmap_21209", time_diff_23921);
            }
        }
        ctx->failure_is_an_option = 1;
        if (memblock_unref_device(ctx, &mem_23260, "mem_23260") != 0)
            return 1;
        if (memblock_set_device(ctx, &res_mem_23275, &mem_23274, "mem_23274") !=
            0)
            return 1;
        if (memblock_set_device(ctx, &res_mem_23276, &mem_23257, "mem_23257") !=
            0)
            return 1;
        if (memblock_set_device(ctx, &res_mem_23277, &mem_23255, "mem_23255") !=
            0)
            return 1;
        if (memblock_set_device(ctx, &res_mem_23278, &mem_23253, "mem_23253") !=
            0)
            return 1;
        if (memblock_unref_device(ctx, &mem_23260, "mem_23260") != 0)
            return 1;
        if (memblock_unref_device(ctx, &group_res_arr_mem_23563,
                                  "group_res_arr_mem_23563") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_23475, "mem_23475") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_23274, "mem_23274") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_23257, "mem_23257") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_23255, "mem_23255") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_23253, "mem_23253") != 0)
            return 1;
    }
    if (memblock_unref_device(ctx, &mem_23221, "mem_23221") != 0)
        return 1;
    if (memblock_unref_device(ctx, &mem_23223, "mem_23223") != 0)
        return 1;
    if (memblock_unref_device(ctx, &mem_23225, "mem_23225") != 0)
        return 1;
    
    float sims_per_year_18620 = res_18541 / res_18533;
    bool bounds_invalid_upwards_18621 = slt64(steps_18529, 1);
    bool valid_18622 = !bounds_invalid_upwards_18621;
    bool range_valid_c_18623;
    
    if (!valid_18622) {
        ctx->error = msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s",
                               "Range ", 1, "..", 2, "...", steps_18529,
                               " is invalid.",
                               "-> #0  cvaold.fut:60:56-67\n   #1  cvaold.fut:111:17-44\n   #2  cvaold.fut:168:3-120\n   #3  cvaold.fut:167:1-168:128\n");
        if (memblock_unref_device(ctx, &res_mem_23278, "res_mem_23278") != 0)
            return 1;
        if (memblock_unref_device(ctx, &res_mem_23277, "res_mem_23277") != 0)
            return 1;
        if (memblock_unref_device(ctx, &res_mem_23276, "res_mem_23276") != 0)
            return 1;
        if (memblock_unref_device(ctx, &res_mem_23275, "res_mem_23275") != 0)
            return 1;
        if (memblock_unref_device(ctx, &group_res_arr_mem_23496,
                                  "group_res_arr_mem_23496") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_23228, "mem_23228") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_23225, "mem_23225") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_23223, "mem_23223") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_23221, "mem_23221") != 0)
            return 1;
        return 1;
    }
    
    bool bounds_invalid_upwards_18629 = slt64(paths_18528, 0);
    bool valid_18630 = !bounds_invalid_upwards_18629;
    bool range_valid_c_18631;
    
    if (!valid_18630) {
        ctx->error = msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s",
                               "Range ", 0, "..", 1, "..<", paths_18528,
                               " is invalid.",
                               "-> #0  /prelude/array.fut:60:3-10\n   #1  /prelude/array.fut:126:11-16\n   #2  lib/github.com/diku-dk/cpprandom/random.fut:174:8-56\n   #3  cvaold.fut:115:19-49\n   #4  cvaold.fut:168:3-120\n   #5  cvaold.fut:167:1-168:128\n");
        if (memblock_unref_device(ctx, &res_mem_23278, "res_mem_23278") != 0)
            return 1;
        if (memblock_unref_device(ctx, &res_mem_23277, "res_mem_23277") != 0)
            return 1;
        if (memblock_unref_device(ctx, &res_mem_23276, "res_mem_23276") != 0)
            return 1;
        if (memblock_unref_device(ctx, &res_mem_23275, "res_mem_23275") != 0)
            return 1;
        if (memblock_unref_device(ctx, &group_res_arr_mem_23496,
                                  "group_res_arr_mem_23496") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_23228, "mem_23228") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_23225, "mem_23225") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_23223, "mem_23223") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_23221, "mem_23221") != 0)
            return 1;
        return 1;
    }
    
    int64_t upper_bound_18634 = sub64(steps_18529, 1);
    float res_18635;
    
    res_18635 = futrts_sqrt32(dt_18542);
    
    int64_t segmap_group_sizze_21723;
    
    segmap_group_sizze_21723 = ctx->sizes.testzisegmap_group_sizze_21706;
    
    int64_t segmap_usable_groups_21724 = sdiv_up64(paths_18528,
                                                   segmap_group_sizze_21723);
    int64_t bytes_23280 = 4 * paths_18528;
    struct memblock_device mem_23281;
    
    mem_23281.references = NULL;
    if (memblock_alloc_device(ctx, &mem_23281, bytes_23280, "mem_23281")) {
        err = 1;
        goto cleanup;
    }
    if (ctx->debugging)
        fprintf(stderr, "%s\n", "\n# SegMap");
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegmap_21704, 1,
                                            sizeof(paths_18528), &paths_18528));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegmap_21704, 2,
                                            sizeof(mem_23281.mem),
                                            &mem_23281.mem));
    if (1 * ((size_t) segmap_usable_groups_21724 *
             (size_t) segmap_group_sizze_21723) != 0) {
        const size_t global_work_sizze_23923[1] =
                     {(size_t) segmap_usable_groups_21724 *
                     (size_t) segmap_group_sizze_21723};
        const size_t local_work_sizze_23927[1] = {segmap_group_sizze_21723};
        int64_t time_start_23924 = 0, time_end_23925 = 0;
        
        if (ctx->debugging) {
            fprintf(stderr, "Launching %s with global work size [",
                    "test.segmap_21704");
            fprintf(stderr, "%zu", global_work_sizze_23923[0]);
            fprintf(stderr, "] and local work size [");
            fprintf(stderr, "%zu", local_work_sizze_23927[0]);
            fprintf(stderr, "]; local memory parameters sum to %d bytes.\n",
                    (int) 0);
            time_start_23924 = get_wall_time();
        }
        OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->opencl.queue,
                                                        ctx->testzisegmap_21704,
                                                        1, NULL,
                                                        global_work_sizze_23923,
                                                        local_work_sizze_23927,
                                                        0, NULL,
                                                        ctx->profiling_paused ||
                                                        !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                                  &ctx->testzisegmap_21704_runs,
                                                                                                  &ctx->testzisegmap_21704_total_runtime)));
        if (ctx->debugging) {
            OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
            time_end_23925 = get_wall_time();
            
            long time_diff_23926 = time_end_23925 - time_start_23924;
            
            fprintf(stderr, "kernel %s runtime: %ldus\n", "test.segmap_21704",
                    time_diff_23926);
        }
    }
    
    int64_t nest_sizze_21747 = paths_18528 * steps_18529;
    int64_t segmap_group_sizze_21748;
    
    segmap_group_sizze_21748 = ctx->sizes.testzisegmap_group_sizze_21643;
    
    int64_t segmap_usable_groups_21749 = sdiv_up64(nest_sizze_21747,
                                                   segmap_group_sizze_21748);
    int64_t bytes_23283 = 4 * nest_sizze_21747;
    struct memblock_device mem_23285;
    
    mem_23285.references = NULL;
    if (memblock_alloc_device(ctx, &mem_23285, bytes_23283, "mem_23285")) {
        err = 1;
        goto cleanup;
    }
    if (ctx->debugging)
        fprintf(stderr, "%s\n", "\n# SegMap");
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegmap_21640, 1,
                                            sizeof(paths_18528), &paths_18528));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegmap_21640, 2,
                                            sizeof(steps_18529), &steps_18529));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegmap_21640, 3,
                                            sizeof(mem_23281.mem),
                                            &mem_23281.mem));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegmap_21640, 4,
                                            sizeof(mem_23285.mem),
                                            &mem_23285.mem));
    if (1 * ((size_t) segmap_usable_groups_21749 *
             (size_t) segmap_group_sizze_21748) != 0) {
        const size_t global_work_sizze_23928[1] =
                     {(size_t) segmap_usable_groups_21749 *
                     (size_t) segmap_group_sizze_21748};
        const size_t local_work_sizze_23932[1] = {segmap_group_sizze_21748};
        int64_t time_start_23929 = 0, time_end_23930 = 0;
        
        if (ctx->debugging) {
            fprintf(stderr, "Launching %s with global work size [",
                    "test.segmap_21640");
            fprintf(stderr, "%zu", global_work_sizze_23928[0]);
            fprintf(stderr, "] and local work size [");
            fprintf(stderr, "%zu", local_work_sizze_23932[0]);
            fprintf(stderr, "]; local memory parameters sum to %d bytes.\n",
                    (int) 0);
            time_start_23929 = get_wall_time();
        }
        OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->opencl.queue,
                                                        ctx->testzisegmap_21640,
                                                        1, NULL,
                                                        global_work_sizze_23928,
                                                        local_work_sizze_23932,
                                                        0, NULL,
                                                        ctx->profiling_paused ||
                                                        !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                                  &ctx->testzisegmap_21640_runs,
                                                                                                  &ctx->testzisegmap_21640_total_runtime)));
        if (ctx->debugging) {
            OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
            time_end_23930 = get_wall_time();
            
            long time_diff_23931 = time_end_23930 - time_start_23929;
            
            fprintf(stderr, "kernel %s runtime: %ldus\n", "test.segmap_21640",
                    time_diff_23931);
        }
    }
    if (memblock_unref_device(ctx, &mem_23281, "mem_23281") != 0)
        return 1;
    
    int64_t segmap_group_sizze_21793;
    
    segmap_group_sizze_21793 = ctx->sizes.testzisegmap_group_sizze_21544;
    
    int64_t num_groups_21794;
    int32_t max_num_groups_23609;
    
    max_num_groups_23609 = ctx->sizes.testzisegmap_num_groups_21546;
    num_groups_21794 = sext_i64_i32(smax64(1, smin64(sdiv_up64(paths_18528,
                                                               sext_i32_i64(segmap_group_sizze_21793)),
                                                     sext_i32_i64(max_num_groups_23609))));
    
    struct memblock_device mem_23288;
    
    mem_23288.references = NULL;
    if (memblock_alloc_device(ctx, &mem_23288, bytes_23283, "mem_23288")) {
        err = 1;
        goto cleanup;
    }
    if (futrts_builtinzhgpu_map_transpose_f32(ctx, mem_23288, 0, mem_23285, 0,
                                              1, steps_18529, paths_18528) !=
        0) {
        err = 1;
        goto cleanup;
    }
    if (memblock_unref_device(ctx, &mem_23285, "mem_23285") != 0)
        return 1;
    
    struct memblock_device mem_23306;
    
    mem_23306.references = NULL;
    if (memblock_alloc_device(ctx, &mem_23306, bytes_23283, "mem_23306")) {
        err = 1;
        goto cleanup;
    }
    
    int64_t bytes_23290 = 4 * steps_18529;
    int64_t num_threads_23481 = segmap_group_sizze_21793 * num_groups_21794;
    int64_t total_sizze_23482 = bytes_23290 * num_threads_23481;
    struct memblock_device mem_23291;
    
    mem_23291.references = NULL;
    if (memblock_alloc_device(ctx, &mem_23291, total_sizze_23482,
                              "mem_23291")) {
        err = 1;
        goto cleanup;
    }
    if (ctx->debugging)
        fprintf(stderr, "%s\n", "\n# SegMap");
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegmap_21542, 1,
                                            sizeof(ctx->failure_is_an_option),
                                            &ctx->failure_is_an_option));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegmap_21542, 3,
                                            sizeof(paths_18528), &paths_18528));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegmap_21542, 4,
                                            sizeof(steps_18529), &steps_18529));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegmap_21542, 5,
                                            sizeof(dt_18542), &dt_18542));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegmap_21542, 6,
                                            sizeof(upper_bound_18634),
                                            &upper_bound_18634));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegmap_21542, 7,
                                            sizeof(res_18635), &res_18635));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegmap_21542, 8,
                                            sizeof(num_groups_21794),
                                            &num_groups_21794));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegmap_21542, 9,
                                            sizeof(mem_23288.mem),
                                            &mem_23288.mem));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegmap_21542, 10,
                                            sizeof(mem_23291.mem),
                                            &mem_23291.mem));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegmap_21542, 11,
                                            sizeof(mem_23306.mem),
                                            &mem_23306.mem));
    if (1 * ((size_t) num_groups_21794 * (size_t) segmap_group_sizze_21793) !=
        0) {
        const size_t global_work_sizze_23933[1] = {(size_t) num_groups_21794 *
                     (size_t) segmap_group_sizze_21793};
        const size_t local_work_sizze_23937[1] = {segmap_group_sizze_21793};
        int64_t time_start_23934 = 0, time_end_23935 = 0;
        
        if (ctx->debugging) {
            fprintf(stderr, "Launching %s with global work size [",
                    "test.segmap_21542");
            fprintf(stderr, "%zu", global_work_sizze_23933[0]);
            fprintf(stderr, "] and local work size [");
            fprintf(stderr, "%zu", local_work_sizze_23937[0]);
            fprintf(stderr, "]; local memory parameters sum to %d bytes.\n",
                    (int) 0);
            time_start_23934 = get_wall_time();
        }
        OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->opencl.queue,
                                                        ctx->testzisegmap_21542,
                                                        1, NULL,
                                                        global_work_sizze_23933,
                                                        local_work_sizze_23937,
                                                        0, NULL,
                                                        ctx->profiling_paused ||
                                                        !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                                  &ctx->testzisegmap_21542_runs,
                                                                                                  &ctx->testzisegmap_21542_total_runtime)));
        if (ctx->debugging) {
            OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
            time_end_23935 = get_wall_time();
            
            long time_diff_23936 = time_end_23935 - time_start_23934;
            
            fprintf(stderr, "kernel %s runtime: %ldus\n", "test.segmap_21542",
                    time_diff_23936);
        }
    }
    ctx->failure_is_an_option = 1;
    if (memblock_unref_device(ctx, &mem_23288, "mem_23288") != 0)
        return 1;
    if (memblock_unref_device(ctx, &mem_23291, "mem_23291") != 0)
        return 1;
    
    float res_18697 = sitofp_i64_f32(paths_18528);
    bool suff_outer_redomap_21820;
    
    suff_outer_redomap_21820 = ctx->sizes.testzisuff_outer_redomap_5 <=
        steps_18529;
    if (ctx->logging)
        fprintf(stderr, "Compared %s <= %d.\n", "test.suff_outer_redomap_5",
                steps_18529);
    
    int64_t segred_group_sizze_21832;
    
    segred_group_sizze_21832 = ctx->sizes.testzisegred_group_sizze_21822;
    
    int64_t num_groups_21833;
    int32_t max_num_groups_23621;
    
    max_num_groups_23621 = ctx->sizes.testzisegred_num_groups_21824;
    num_groups_21833 = sext_i64_i32(smax64(1, smin64(sdiv_up64(steps_18529,
                                                               sext_i32_i64(segred_group_sizze_21832)),
                                                     sext_i32_i64(max_num_groups_23621))));
    
    bool suff_outer_par_22687;
    
    suff_outer_par_22687 = ctx->sizes.testzisuff_outer_par_6 <= steps_18529;
    if (ctx->logging)
        fprintf(stderr, "Compared %s <= %d.\n", "test.suff_outer_par_6",
                steps_18529);
    
    int64_t max_group_sizze_22690;
    
    max_group_sizze_22690 = ctx->opencl.max_group_size;
    
    bool fits_22691 = sle64(paths_18528, max_group_sizze_22690);
    bool suff_intra_par_22693;
    
    suff_intra_par_22693 = ctx->sizes.testzisuff_intra_par_7 <= paths_18528;
    if (ctx->logging)
        fprintf(stderr, "Compared %s <= %d.\n", "test.suff_intra_par_7",
                paths_18528);
    
    bool intra_suff_and_fits_22694 = fits_22691 && suff_intra_par_22693;
    int64_t segmap_group_sizze_22697;
    
    segmap_group_sizze_22697 = ctx->sizes.testzisegmap_group_sizze_21981;
    
    int64_t segred_group_sizze_22967;
    
    segred_group_sizze_22967 = ctx->sizes.testzisegred_group_sizze_22410;
    
    int64_t num_groups_22968;
    int32_t max_num_groups_23622;
    
    max_num_groups_23622 = ctx->sizes.testzisegred_num_groups_22412;
    num_groups_22968 = sext_i64_i32(smax64(1, smin64(sdiv_up64(nest_sizze_21747,
                                                               sext_i32_i64(segred_group_sizze_22967)),
                                                     sext_i32_i64(max_num_groups_23622))));
    
    int64_t segmap_group_sizze_23077;
    
    segmap_group_sizze_23077 = ctx->sizes.testzisegmap_group_sizze_22383;
    
    int64_t segred_group_sizze_23103;
    
    segred_group_sizze_23103 = ctx->sizes.testzisegred_group_sizze_22677;
    
    int64_t num_groups_23104;
    int32_t max_num_groups_23623;
    
    max_num_groups_23623 = ctx->sizes.testzisegred_num_groups_22679;
    num_groups_23104 = sext_i64_i32(smax64(1, smin64(sdiv_up64(steps_18529,
                                                               sext_i32_i64(segred_group_sizze_23103)),
                                                     sext_i32_i64(max_num_groups_23623))));
    
    float res_18704;
    int32_t local_memory_capacity_23778;
    
    local_memory_capacity_23778 = ctx->opencl.max_local_memory;
    if (sle64((int32_t) sizeof(bool) + (int32_t) sizeof(float) *
              segred_group_sizze_21832,
              sext_i32_i64(local_memory_capacity_23778)) &&
        suff_outer_redomap_21820) {
        struct memblock_device mem_23309;
        
        mem_23309.references = NULL;
        if (memblock_alloc_device(ctx, &mem_23309, 4, "mem_23309")) {
            err = 1;
            goto cleanup;
        }
        
        struct memblock_device testzicounter_mem_23624 =
                               ctx->testzicounter_mem_23624;
        struct memblock_device group_res_arr_mem_23626;
        
        group_res_arr_mem_23626.references = NULL;
        if (memblock_alloc_device(ctx, &group_res_arr_mem_23626,
                                  (int32_t) sizeof(float) *
                                  (segred_group_sizze_21832 * num_groups_21833),
                                  "group_res_arr_mem_23626")) {
            err = 1;
            goto cleanup;
        }
        
        int64_t num_threads_23628;
        
        num_threads_23628 = num_groups_21833 * segred_group_sizze_21832;
        if (ctx->debugging)
            fprintf(stderr, "%s\n", "\n# SegRed");
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegred_nonseg_21830,
                                                1,
                                                sizeof(ctx->failure_is_an_option),
                                                &ctx->failure_is_an_option));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegred_nonseg_21830,
                                                3, (int32_t) sizeof(float) *
                                                segred_group_sizze_21832,
                                                NULL));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegred_nonseg_21830,
                                                4, (int32_t) sizeof(bool),
                                                NULL));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegred_nonseg_21830,
                                                5, sizeof(paths_18528),
                                                &paths_18528));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegred_nonseg_21830,
                                                6, sizeof(steps_18529),
                                                &steps_18529));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegred_nonseg_21830,
                                                7, sizeof(sims_per_year_18620),
                                                &sims_per_year_18620));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegred_nonseg_21830,
                                                8, sizeof(res_18697),
                                                &res_18697));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegred_nonseg_21830,
                                                9, sizeof(num_groups_21833),
                                                &num_groups_21833));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegred_nonseg_21830,
                                                10, sizeof(res_mem_23275.mem),
                                                &res_mem_23275.mem));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegred_nonseg_21830,
                                                11, sizeof(res_mem_23276.mem),
                                                &res_mem_23276.mem));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegred_nonseg_21830,
                                                12, sizeof(res_mem_23277.mem),
                                                &res_mem_23277.mem));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegred_nonseg_21830,
                                                13, sizeof(res_mem_23278.mem),
                                                &res_mem_23278.mem));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegred_nonseg_21830,
                                                14, sizeof(mem_23306.mem),
                                                &mem_23306.mem));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegred_nonseg_21830,
                                                15, sizeof(mem_23309.mem),
                                                &mem_23309.mem));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegred_nonseg_21830,
                                                16,
                                                sizeof(testzicounter_mem_23624.mem),
                                                &testzicounter_mem_23624.mem));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegred_nonseg_21830,
                                                17,
                                                sizeof(group_res_arr_mem_23626.mem),
                                                &group_res_arr_mem_23626.mem));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegred_nonseg_21830,
                                                18, sizeof(num_threads_23628),
                                                &num_threads_23628));
        if (1 * ((size_t) num_groups_21833 *
                 (size_t) segred_group_sizze_21832) != 0) {
            const size_t global_work_sizze_23939[1] =
                         {(size_t) num_groups_21833 *
                         (size_t) segred_group_sizze_21832};
            const size_t local_work_sizze_23943[1] = {segred_group_sizze_21832};
            int64_t time_start_23940 = 0, time_end_23941 = 0;
            
            if (ctx->debugging) {
                fprintf(stderr, "Launching %s with global work size [",
                        "test.segred_nonseg_21830");
                fprintf(stderr, "%zu", global_work_sizze_23939[0]);
                fprintf(stderr, "] and local work size [");
                fprintf(stderr, "%zu", local_work_sizze_23943[0]);
                fprintf(stderr, "]; local memory parameters sum to %d bytes.\n",
                        (int) (0 + (int32_t) sizeof(float) *
                               segred_group_sizze_21832 +
                               (int32_t) sizeof(bool)));
                time_start_23940 = get_wall_time();
            }
            OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->opencl.queue,
                                                            ctx->testzisegred_nonseg_21830,
                                                            1, NULL,
                                                            global_work_sizze_23939,
                                                            local_work_sizze_23943,
                                                            0, NULL,
                                                            ctx->profiling_paused ||
                                                            !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                                      &ctx->testzisegred_nonseg_21830_runs,
                                                                                                      &ctx->testzisegred_nonseg_21830_total_runtime)));
            if (ctx->debugging) {
                OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
                time_end_23941 = get_wall_time();
                
                long time_diff_23942 = time_end_23941 - time_start_23940;
                
                fprintf(stderr, "kernel %s runtime: %ldus\n",
                        "test.segred_nonseg_21830", time_diff_23942);
            }
        }
        ctx->failure_is_an_option = 1;
        
        float read_res_23944;
        
        OPENCL_SUCCEED_OR_RETURN(clEnqueueReadBuffer(ctx->opencl.queue,
                                                     mem_23309.mem,
                                                     ctx->failure_is_an_option ? CL_FALSE : CL_TRUE,
                                                     0 * sizeof(float),
                                                     sizeof(float),
                                                     &read_res_23944, 0, NULL,
                                                     ctx->profiling_paused ||
                                                     !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                               &ctx->copy_scalar_from_dev_runs,
                                                                                               &ctx->copy_scalar_from_dev_total_runtime)));
        if (ctx->failure_is_an_option && futhark_context_sync(ctx) != 0)
            return 1;
        
        float res_21967 = read_res_23944;
        
        if (memblock_unref_device(ctx, &mem_23309, "mem_23309") != 0)
            return 1;
        res_18704 = res_21967;
        if (memblock_unref_device(ctx, &group_res_arr_mem_23626,
                                  "group_res_arr_mem_23626") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_23309, "mem_23309") != 0)
            return 1;
    } else {
        struct memblock_device res_map_acc_mem_23324;
        
        res_map_acc_mem_23324.references = NULL;
        
        int32_t local_memory_capacity_23747;
        
        local_memory_capacity_23747 = ctx->opencl.max_local_memory;
        if (sle64(0, sext_i32_i64(local_memory_capacity_23747)) &&
            suff_outer_par_22687) {
            int64_t segmap_usable_groups_22698 = sdiv_up64(steps_18529,
                                                           segmap_group_sizze_22697);
            struct memblock_device mem_23312;
            
            mem_23312.references = NULL;
            if (memblock_alloc_device(ctx, &mem_23312, bytes_23290,
                                      "mem_23312")) {
                err = 1;
                goto cleanup;
            }
            if (ctx->debugging)
                fprintf(stderr, "%s\n", "\n# SegMap");
            OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegmap_21979, 1,
                                                    sizeof(ctx->failure_is_an_option),
                                                    &ctx->failure_is_an_option));
            OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegmap_21979, 3,
                                                    sizeof(paths_18528),
                                                    &paths_18528));
            OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegmap_21979, 4,
                                                    sizeof(steps_18529),
                                                    &steps_18529));
            OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegmap_21979, 5,
                                                    sizeof(sims_per_year_18620),
                                                    &sims_per_year_18620));
            OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegmap_21979, 6,
                                                    sizeof(res_18697),
                                                    &res_18697));
            OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegmap_21979, 7,
                                                    sizeof(res_mem_23275.mem),
                                                    &res_mem_23275.mem));
            OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegmap_21979, 8,
                                                    sizeof(res_mem_23276.mem),
                                                    &res_mem_23276.mem));
            OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegmap_21979, 9,
                                                    sizeof(res_mem_23277.mem),
                                                    &res_mem_23277.mem));
            OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegmap_21979, 10,
                                                    sizeof(res_mem_23278.mem),
                                                    &res_mem_23278.mem));
            OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegmap_21979, 11,
                                                    sizeof(mem_23306.mem),
                                                    &mem_23306.mem));
            OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegmap_21979, 12,
                                                    sizeof(mem_23312.mem),
                                                    &mem_23312.mem));
            if (1 * ((size_t) segmap_usable_groups_22698 *
                     (size_t) segmap_group_sizze_22697) != 0) {
                const size_t global_work_sizze_23945[1] =
                             {(size_t) segmap_usable_groups_22698 *
                             (size_t) segmap_group_sizze_22697};
                const size_t local_work_sizze_23949[1] =
                             {segmap_group_sizze_22697};
                int64_t time_start_23946 = 0, time_end_23947 = 0;
                
                if (ctx->debugging) {
                    fprintf(stderr, "Launching %s with global work size [",
                            "test.segmap_21979");
                    fprintf(stderr, "%zu", global_work_sizze_23945[0]);
                    fprintf(stderr, "] and local work size [");
                    fprintf(stderr, "%zu", local_work_sizze_23949[0]);
                    fprintf(stderr,
                            "]; local memory parameters sum to %d bytes.\n",
                            (int) 0);
                    time_start_23946 = get_wall_time();
                }
                OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->opencl.queue,
                                                                ctx->testzisegmap_21979,
                                                                1, NULL,
                                                                global_work_sizze_23945,
                                                                local_work_sizze_23949,
                                                                0, NULL,
                                                                ctx->profiling_paused ||
                                                                !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                                          &ctx->testzisegmap_21979_runs,
                                                                                                          &ctx->testzisegmap_21979_total_runtime)));
                if (ctx->debugging) {
                    OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
                    time_end_23947 = get_wall_time();
                    
                    long time_diff_23948 = time_end_23947 - time_start_23946;
                    
                    fprintf(stderr, "kernel %s runtime: %ldus\n",
                            "test.segmap_21979", time_diff_23948);
                }
            }
            ctx->failure_is_an_option = 1;
            if (memblock_set_device(ctx, &res_map_acc_mem_23324, &mem_23312,
                                    "mem_23312") != 0)
                return 1;
            if (memblock_unref_device(ctx, &mem_23312, "mem_23312") != 0)
                return 1;
        } else {
            struct memblock_device res_map_acc_mem_23323;
            
            res_map_acc_mem_23323.references = NULL;
            
            int32_t local_memory_capacity_23746;
            
            local_memory_capacity_23746 = ctx->opencl.max_local_memory;
            if (sle64((int32_t) sizeof(float) * paths_18528,
                      sext_i32_i64(local_memory_capacity_23746)) &&
                intra_suff_and_fits_22694) {
                struct memblock_device mem_23316;
                
                mem_23316.references = NULL;
                if (memblock_alloc_device(ctx, &mem_23316, bytes_23290,
                                          "mem_23316")) {
                    err = 1;
                    goto cleanup;
                }
                OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegmap_intragroup_21977,
                                                        1,
                                                        sizeof(ctx->failure_is_an_option),
                                                        &ctx->failure_is_an_option));
                OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegmap_intragroup_21977,
                                                        3,
                                                        (int32_t) sizeof(float) *
                                                        paths_18528, NULL));
                OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegmap_intragroup_21977,
                                                        4, sizeof(paths_18528),
                                                        &paths_18528));
                OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegmap_intragroup_21977,
                                                        5,
                                                        sizeof(sims_per_year_18620),
                                                        &sims_per_year_18620));
                OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegmap_intragroup_21977,
                                                        6, sizeof(res_18697),
                                                        &res_18697));
                OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegmap_intragroup_21977,
                                                        7,
                                                        sizeof(res_mem_23275.mem),
                                                        &res_mem_23275.mem));
                OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegmap_intragroup_21977,
                                                        8,
                                                        sizeof(res_mem_23276.mem),
                                                        &res_mem_23276.mem));
                OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegmap_intragroup_21977,
                                                        9,
                                                        sizeof(res_mem_23277.mem),
                                                        &res_mem_23277.mem));
                OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegmap_intragroup_21977,
                                                        10,
                                                        sizeof(res_mem_23278.mem),
                                                        &res_mem_23278.mem));
                OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegmap_intragroup_21977,
                                                        11,
                                                        sizeof(mem_23306.mem),
                                                        &mem_23306.mem));
                OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegmap_intragroup_21977,
                                                        12,
                                                        sizeof(mem_23316.mem),
                                                        &mem_23316.mem));
                if (1 * ((size_t) steps_18529 * (size_t) paths_18528) != 0) {
                    const size_t global_work_sizze_23950[1] =
                                 {(size_t) steps_18529 * (size_t) paths_18528};
                    const size_t local_work_sizze_23954[1] = {paths_18528};
                    int64_t time_start_23951 = 0, time_end_23952 = 0;
                    
                    if (ctx->debugging) {
                        fprintf(stderr, "Launching %s with global work size [",
                                "test.segmap_intragroup_21977");
                        fprintf(stderr, "%zu", global_work_sizze_23950[0]);
                        fprintf(stderr, "] and local work size [");
                        fprintf(stderr, "%zu", local_work_sizze_23954[0]);
                        fprintf(stderr,
                                "]; local memory parameters sum to %d bytes.\n",
                                (int) (0 + (int32_t) sizeof(float) *
                                       paths_18528));
                        time_start_23951 = get_wall_time();
                    }
                    OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->opencl.queue,
                                                                    ctx->testzisegmap_intragroup_21977,
                                                                    1, NULL,
                                                                    global_work_sizze_23950,
                                                                    local_work_sizze_23954,
                                                                    0, NULL,
                                                                    ctx->profiling_paused ||
                                                                    !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                                              &ctx->testzisegmap_intragroup_21977_runs,
                                                                                                              &ctx->testzisegmap_intragroup_21977_total_runtime)));
                    if (ctx->debugging) {
                        OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
                        time_end_23952 = get_wall_time();
                        
                        long time_diff_23953 = time_end_23952 -
                             time_start_23951;
                        
                        fprintf(stderr, "kernel %s runtime: %ldus\n",
                                "test.segmap_intragroup_21977",
                                time_diff_23953);
                    }
                }
                ctx->failure_is_an_option = 1;
                if (memblock_set_device(ctx, &res_map_acc_mem_23323, &mem_23316,
                                        "mem_23316") != 0)
                    return 1;
                if (memblock_unref_device(ctx, &mem_23316, "mem_23316") != 0)
                    return 1;
            } else {
                struct memblock_device mem_23319;
                
                mem_23319.references = NULL;
                if (memblock_alloc_device(ctx, &mem_23319, bytes_23290,
                                          "mem_23319")) {
                    err = 1;
                    goto cleanup;
                }
                if (slt64(paths_18528 * 2, segred_group_sizze_22967)) {
                    int64_t segment_sizze_nonzzero_23677 = smax64(1,
                                                                  paths_18528);
                    int64_t num_threads_23678 = num_groups_22968 *
                            segred_group_sizze_22967;
                    
                    if (ctx->debugging)
                        fprintf(stderr, "%s\n", "\n# SegRed-small");
                    if (ctx->debugging)
                        fprintf(stderr, "%s: %llu%c", "num_segments",
                                (long long) steps_18529, '\n');
                    if (ctx->debugging)
                        fprintf(stderr, "%s: %llu%c", "segment_size",
                                (long long) paths_18528, '\n');
                    if (ctx->debugging)
                        fprintf(stderr, "%s: %llu%c", "segments_per_group",
                                (long long) squot64(segred_group_sizze_22967,
                                                    segment_sizze_nonzzero_23677),
                                '\n');
                    if (ctx->debugging)
                        fprintf(stderr, "%s: %llu%c", "required_groups",
                                (long long) sext_i64_i32(sdiv_up64(steps_18529,
                                                                   squot64(segred_group_sizze_22967,
                                                                           segment_sizze_nonzzero_23677))),
                                '\n');
                    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegred_small_22416,
                                                            1,
                                                            sizeof(ctx->failure_is_an_option),
                                                            &ctx->failure_is_an_option));
                    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegred_small_22416,
                                                            3,
                                                            (int32_t) sizeof(float) *
                                                            segred_group_sizze_22967,
                                                            NULL));
                    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegred_small_22416,
                                                            4,
                                                            sizeof(paths_18528),
                                                            &paths_18528));
                    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegred_small_22416,
                                                            5,
                                                            sizeof(steps_18529),
                                                            &steps_18529));
                    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegred_small_22416,
                                                            6,
                                                            sizeof(sims_per_year_18620),
                                                            &sims_per_year_18620));
                    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegred_small_22416,
                                                            7,
                                                            sizeof(num_groups_22968),
                                                            &num_groups_22968));
                    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegred_small_22416,
                                                            8,
                                                            sizeof(res_mem_23275.mem),
                                                            &res_mem_23275.mem));
                    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegred_small_22416,
                                                            9,
                                                            sizeof(res_mem_23276.mem),
                                                            &res_mem_23276.mem));
                    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegred_small_22416,
                                                            10,
                                                            sizeof(res_mem_23277.mem),
                                                            &res_mem_23277.mem));
                    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegred_small_22416,
                                                            11,
                                                            sizeof(res_mem_23278.mem),
                                                            &res_mem_23278.mem));
                    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegred_small_22416,
                                                            12,
                                                            sizeof(mem_23306.mem),
                                                            &mem_23306.mem));
                    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegred_small_22416,
                                                            13,
                                                            sizeof(mem_23319.mem),
                                                            &mem_23319.mem));
                    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegred_small_22416,
                                                            14,
                                                            sizeof(segment_sizze_nonzzero_23677),
                                                            &segment_sizze_nonzzero_23677));
                    if (1 * ((size_t) num_groups_22968 *
                             (size_t) segred_group_sizze_22967) != 0) {
                        const size_t global_work_sizze_23955[1] =
                                     {(size_t) num_groups_22968 *
                                     (size_t) segred_group_sizze_22967};
                        const size_t local_work_sizze_23959[1] =
                                     {segred_group_sizze_22967};
                        int64_t time_start_23956 = 0, time_end_23957 = 0;
                        
                        if (ctx->debugging) {
                            fprintf(stderr,
                                    "Launching %s with global work size [",
                                    "test.segred_small_22416");
                            fprintf(stderr, "%zu", global_work_sizze_23955[0]);
                            fprintf(stderr, "] and local work size [");
                            fprintf(stderr, "%zu", local_work_sizze_23959[0]);
                            fprintf(stderr,
                                    "]; local memory parameters sum to %d bytes.\n",
                                    (int) (0 + (int32_t) sizeof(float) *
                                           segred_group_sizze_22967));
                            time_start_23956 = get_wall_time();
                        }
                        OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->opencl.queue,
                                                                        ctx->testzisegred_small_22416,
                                                                        1, NULL,
                                                                        global_work_sizze_23955,
                                                                        local_work_sizze_23959,
                                                                        0, NULL,
                                                                        ctx->profiling_paused ||
                                                                        !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                                                  &ctx->testzisegred_small_22416_runs,
                                                                                                                  &ctx->testzisegred_small_22416_total_runtime)));
                        if (ctx->debugging) {
                            OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
                            time_end_23957 = get_wall_time();
                            
                            long time_diff_23958 = time_end_23957 -
                                 time_start_23956;
                            
                            fprintf(stderr, "kernel %s runtime: %ldus\n",
                                    "test.segred_small_22416", time_diff_23958);
                        }
                    }
                    ctx->failure_is_an_option = 1;
                } else {
                    int64_t groups_per_segment_23700 =
                            sdiv_up64(num_groups_22968, smax64(1, steps_18529));
                    int64_t elements_per_thread_23701 = sdiv_up64(paths_18528,
                                                                  segred_group_sizze_22967 *
                                                                  groups_per_segment_23700);
                    int64_t virt_num_groups_23702 = groups_per_segment_23700 *
                            steps_18529;
                    int64_t num_threads_23703 = num_groups_22968 *
                            segred_group_sizze_22967;
                    int64_t threads_per_segment_23704 =
                            groups_per_segment_23700 * segred_group_sizze_22967;
                    
                    if (ctx->debugging)
                        fprintf(stderr, "%s\n", "\n# SegRed-large");
                    if (ctx->debugging)
                        fprintf(stderr, "%s: %llu%c", "num_segments",
                                (long long) steps_18529, '\n');
                    if (ctx->debugging)
                        fprintf(stderr, "%s: %llu%c", "segment_size",
                                (long long) paths_18528, '\n');
                    if (ctx->debugging)
                        fprintf(stderr, "%s: %llu%c", "virt_num_groups",
                                (long long) virt_num_groups_23702, '\n');
                    if (ctx->debugging)
                        fprintf(stderr, "%s: %llu%c", "num_groups",
                                (long long) num_groups_22968, '\n');
                    if (ctx->debugging)
                        fprintf(stderr, "%s: %llu%c", "group_size",
                                (long long) segred_group_sizze_22967, '\n');
                    if (ctx->debugging)
                        fprintf(stderr, "%s: %llu%c", "elems_per_thread",
                                (long long) elements_per_thread_23701, '\n');
                    if (ctx->debugging)
                        fprintf(stderr, "%s: %llu%c", "groups_per_segment",
                                (long long) groups_per_segment_23700, '\n');
                    
                    struct memblock_device group_res_arr_mem_23705;
                    
                    group_res_arr_mem_23705.references = NULL;
                    if (memblock_alloc_device(ctx, &group_res_arr_mem_23705,
                                              (int32_t) sizeof(float) *
                                              (segred_group_sizze_22967 *
                                               virt_num_groups_23702),
                                              "group_res_arr_mem_23705")) {
                        err = 1;
                        goto cleanup;
                    }
                    
                    struct memblock_device testzicounter_mem_23707 =
                                           ctx->testzicounter_mem_23707;
                    
                    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegred_large_22416,
                                                            1,
                                                            sizeof(ctx->failure_is_an_option),
                                                            &ctx->failure_is_an_option));
                    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegred_large_22416,
                                                            3,
                                                            (int32_t) sizeof(bool),
                                                            NULL));
                    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegred_large_22416,
                                                            4,
                                                            (int32_t) sizeof(float) *
                                                            segred_group_sizze_22967,
                                                            NULL));
                    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegred_large_22416,
                                                            5,
                                                            sizeof(paths_18528),
                                                            &paths_18528));
                    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegred_large_22416,
                                                            6,
                                                            sizeof(sims_per_year_18620),
                                                            &sims_per_year_18620));
                    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegred_large_22416,
                                                            7,
                                                            sizeof(num_groups_22968),
                                                            &num_groups_22968));
                    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegred_large_22416,
                                                            8,
                                                            sizeof(res_mem_23275.mem),
                                                            &res_mem_23275.mem));
                    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegred_large_22416,
                                                            9,
                                                            sizeof(res_mem_23276.mem),
                                                            &res_mem_23276.mem));
                    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegred_large_22416,
                                                            10,
                                                            sizeof(res_mem_23277.mem),
                                                            &res_mem_23277.mem));
                    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegred_large_22416,
                                                            11,
                                                            sizeof(res_mem_23278.mem),
                                                            &res_mem_23278.mem));
                    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegred_large_22416,
                                                            12,
                                                            sizeof(mem_23306.mem),
                                                            &mem_23306.mem));
                    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegred_large_22416,
                                                            13,
                                                            sizeof(mem_23319.mem),
                                                            &mem_23319.mem));
                    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegred_large_22416,
                                                            14,
                                                            sizeof(groups_per_segment_23700),
                                                            &groups_per_segment_23700));
                    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegred_large_22416,
                                                            15,
                                                            sizeof(elements_per_thread_23701),
                                                            &elements_per_thread_23701));
                    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegred_large_22416,
                                                            16,
                                                            sizeof(virt_num_groups_23702),
                                                            &virt_num_groups_23702));
                    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegred_large_22416,
                                                            17,
                                                            sizeof(threads_per_segment_23704),
                                                            &threads_per_segment_23704));
                    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegred_large_22416,
                                                            18,
                                                            sizeof(group_res_arr_mem_23705.mem),
                                                            &group_res_arr_mem_23705.mem));
                    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegred_large_22416,
                                                            19,
                                                            sizeof(testzicounter_mem_23707.mem),
                                                            &testzicounter_mem_23707.mem));
                    if (1 * ((size_t) num_groups_22968 *
                             (size_t) segred_group_sizze_22967) != 0) {
                        const size_t global_work_sizze_23961[1] =
                                     {(size_t) num_groups_22968 *
                                     (size_t) segred_group_sizze_22967};
                        const size_t local_work_sizze_23965[1] =
                                     {segred_group_sizze_22967};
                        int64_t time_start_23962 = 0, time_end_23963 = 0;
                        
                        if (ctx->debugging) {
                            fprintf(stderr,
                                    "Launching %s with global work size [",
                                    "test.segred_large_22416");
                            fprintf(stderr, "%zu", global_work_sizze_23961[0]);
                            fprintf(stderr, "] and local work size [");
                            fprintf(stderr, "%zu", local_work_sizze_23965[0]);
                            fprintf(stderr,
                                    "]; local memory parameters sum to %d bytes.\n",
                                    (int) (0 + (int32_t) sizeof(bool) +
                                           (int32_t) sizeof(float) *
                                           segred_group_sizze_22967));
                            time_start_23962 = get_wall_time();
                        }
                        OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->opencl.queue,
                                                                        ctx->testzisegred_large_22416,
                                                                        1, NULL,
                                                                        global_work_sizze_23961,
                                                                        local_work_sizze_23965,
                                                                        0, NULL,
                                                                        ctx->profiling_paused ||
                                                                        !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                                                  &ctx->testzisegred_large_22416_runs,
                                                                                                                  &ctx->testzisegred_large_22416_total_runtime)));
                        if (ctx->debugging) {
                            OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
                            time_end_23963 = get_wall_time();
                            
                            long time_diff_23964 = time_end_23963 -
                                 time_start_23962;
                            
                            fprintf(stderr, "kernel %s runtime: %ldus\n",
                                    "test.segred_large_22416", time_diff_23964);
                        }
                    }
                    ctx->failure_is_an_option = 1;
                    if (memblock_unref_device(ctx, &group_res_arr_mem_23705,
                                              "group_res_arr_mem_23705") != 0)
                        return 1;
                }
                
                int64_t segmap_usable_groups_23078 = sdiv_up64(steps_18529,
                                                               segmap_group_sizze_23077);
                struct memblock_device mem_23322;
                
                mem_23322.references = NULL;
                if (memblock_alloc_device(ctx, &mem_23322, bytes_23290,
                                          "mem_23322")) {
                    err = 1;
                    goto cleanup;
                }
                if (ctx->debugging)
                    fprintf(stderr, "%s\n", "\n# SegMap");
                OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegmap_22381,
                                                        1, sizeof(steps_18529),
                                                        &steps_18529));
                OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegmap_22381,
                                                        2,
                                                        sizeof(sims_per_year_18620),
                                                        &sims_per_year_18620));
                OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegmap_22381,
                                                        3, sizeof(res_18697),
                                                        &res_18697));
                OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegmap_22381,
                                                        4,
                                                        sizeof(mem_23319.mem),
                                                        &mem_23319.mem));
                OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegmap_22381,
                                                        5,
                                                        sizeof(mem_23322.mem),
                                                        &mem_23322.mem));
                if (1 * ((size_t) segmap_usable_groups_23078 *
                         (size_t) segmap_group_sizze_23077) != 0) {
                    const size_t global_work_sizze_23966[1] =
                                 {(size_t) segmap_usable_groups_23078 *
                                 (size_t) segmap_group_sizze_23077};
                    const size_t local_work_sizze_23970[1] =
                                 {segmap_group_sizze_23077};
                    int64_t time_start_23967 = 0, time_end_23968 = 0;
                    
                    if (ctx->debugging) {
                        fprintf(stderr, "Launching %s with global work size [",
                                "test.segmap_22381");
                        fprintf(stderr, "%zu", global_work_sizze_23966[0]);
                        fprintf(stderr, "] and local work size [");
                        fprintf(stderr, "%zu", local_work_sizze_23970[0]);
                        fprintf(stderr,
                                "]; local memory parameters sum to %d bytes.\n",
                                (int) 0);
                        time_start_23967 = get_wall_time();
                    }
                    OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->opencl.queue,
                                                                    ctx->testzisegmap_22381,
                                                                    1, NULL,
                                                                    global_work_sizze_23966,
                                                                    local_work_sizze_23970,
                                                                    0, NULL,
                                                                    ctx->profiling_paused ||
                                                                    !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                                              &ctx->testzisegmap_22381_runs,
                                                                                                              &ctx->testzisegmap_22381_total_runtime)));
                    if (ctx->debugging) {
                        OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
                        time_end_23968 = get_wall_time();
                        
                        long time_diff_23969 = time_end_23968 -
                             time_start_23967;
                        
                        fprintf(stderr, "kernel %s runtime: %ldus\n",
                                "test.segmap_22381", time_diff_23969);
                    }
                }
                if (memblock_unref_device(ctx, &mem_23319, "mem_23319") != 0)
                    return 1;
                if (memblock_set_device(ctx, &res_map_acc_mem_23323, &mem_23322,
                                        "mem_23322") != 0)
                    return 1;
                if (memblock_unref_device(ctx, &mem_23322, "mem_23322") != 0)
                    return 1;
                if (memblock_unref_device(ctx, &mem_23319, "mem_23319") != 0)
                    return 1;
            }
            if (memblock_set_device(ctx, &res_map_acc_mem_23324,
                                    &res_map_acc_mem_23323,
                                    "res_map_acc_mem_23323") != 0)
                return 1;
            if (memblock_unref_device(ctx, &res_map_acc_mem_23323,
                                      "res_map_acc_mem_23323") != 0)
                return 1;
        }
        
        struct memblock_device mem_23327;
        
        mem_23327.references = NULL;
        if (memblock_alloc_device(ctx, &mem_23327, 4, "mem_23327")) {
            err = 1;
            goto cleanup;
        }
        
        struct memblock_device testzicounter_mem_23748 =
                               ctx->testzicounter_mem_23748;
        struct memblock_device group_res_arr_mem_23750;
        
        group_res_arr_mem_23750.references = NULL;
        if (memblock_alloc_device(ctx, &group_res_arr_mem_23750,
                                  (int32_t) sizeof(float) *
                                  (segred_group_sizze_23103 * num_groups_23104),
                                  "group_res_arr_mem_23750")) {
            err = 1;
            goto cleanup;
        }
        
        int64_t num_threads_23752;
        
        num_threads_23752 = num_groups_23104 * segred_group_sizze_23103;
        if (ctx->debugging)
            fprintf(stderr, "%s\n", "\n# SegRed");
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegred_nonseg_22685,
                                                1, (int32_t) sizeof(float) *
                                                segred_group_sizze_23103,
                                                NULL));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegred_nonseg_22685,
                                                2, (int32_t) sizeof(bool),
                                                NULL));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegred_nonseg_22685,
                                                3, sizeof(steps_18529),
                                                &steps_18529));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegred_nonseg_22685,
                                                4, sizeof(num_groups_23104),
                                                &num_groups_23104));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegred_nonseg_22685,
                                                5,
                                                sizeof(res_map_acc_mem_23324.mem),
                                                &res_map_acc_mem_23324.mem));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegred_nonseg_22685,
                                                6, sizeof(mem_23327.mem),
                                                &mem_23327.mem));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegred_nonseg_22685,
                                                7,
                                                sizeof(testzicounter_mem_23748.mem),
                                                &testzicounter_mem_23748.mem));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegred_nonseg_22685,
                                                8,
                                                sizeof(group_res_arr_mem_23750.mem),
                                                &group_res_arr_mem_23750.mem));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->testzisegred_nonseg_22685,
                                                9, sizeof(num_threads_23752),
                                                &num_threads_23752));
        if (1 * ((size_t) num_groups_23104 *
                 (size_t) segred_group_sizze_23103) != 0) {
            const size_t global_work_sizze_23972[1] =
                         {(size_t) num_groups_23104 *
                         (size_t) segred_group_sizze_23103};
            const size_t local_work_sizze_23976[1] = {segred_group_sizze_23103};
            int64_t time_start_23973 = 0, time_end_23974 = 0;
            
            if (ctx->debugging) {
                fprintf(stderr, "Launching %s with global work size [",
                        "test.segred_nonseg_22685");
                fprintf(stderr, "%zu", global_work_sizze_23972[0]);
                fprintf(stderr, "] and local work size [");
                fprintf(stderr, "%zu", local_work_sizze_23976[0]);
                fprintf(stderr, "]; local memory parameters sum to %d bytes.\n",
                        (int) (0 + (int32_t) sizeof(float) *
                               segred_group_sizze_23103 +
                               (int32_t) sizeof(bool)));
                time_start_23973 = get_wall_time();
            }
            OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->opencl.queue,
                                                            ctx->testzisegred_nonseg_22685,
                                                            1, NULL,
                                                            global_work_sizze_23972,
                                                            local_work_sizze_23976,
                                                            0, NULL,
                                                            ctx->profiling_paused ||
                                                            !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                                      &ctx->testzisegred_nonseg_22685_runs,
                                                                                                      &ctx->testzisegred_nonseg_22685_total_runtime)));
            if (ctx->debugging) {
                OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
                time_end_23974 = get_wall_time();
                
                long time_diff_23975 = time_end_23974 - time_start_23973;
                
                fprintf(stderr, "kernel %s runtime: %ldus\n",
                        "test.segred_nonseg_22685", time_diff_23975);
            }
        }
        if (memblock_unref_device(ctx, &res_map_acc_mem_23324,
                                  "res_map_acc_mem_23324") != 0)
            return 1;
        
        float read_res_23977;
        
        OPENCL_SUCCEED_OR_RETURN(clEnqueueReadBuffer(ctx->opencl.queue,
                                                     mem_23327.mem,
                                                     ctx->failure_is_an_option ? CL_FALSE : CL_TRUE,
                                                     0 * sizeof(float),
                                                     sizeof(float),
                                                     &read_res_23977, 0, NULL,
                                                     ctx->profiling_paused ||
                                                     !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                               &ctx->copy_scalar_from_dev_runs,
                                                                                               &ctx->copy_scalar_from_dev_total_runtime)));
        if (ctx->failure_is_an_option && futhark_context_sync(ctx) != 0)
            return 1;
        
        float res_23111 = read_res_23977;
        
        if (memblock_unref_device(ctx, &mem_23327, "mem_23327") != 0)
            return 1;
        res_18704 = res_23111;
        if (memblock_unref_device(ctx, &group_res_arr_mem_23750,
                                  "group_res_arr_mem_23750") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_23327, "mem_23327") != 0)
            return 1;
        if (memblock_unref_device(ctx, &res_map_acc_mem_23324,
                                  "res_map_acc_mem_23324") != 0)
            return 1;
    }
    if (memblock_unref_device(ctx, &res_mem_23275, "res_mem_23275") != 0)
        return 1;
    if (memblock_unref_device(ctx, &res_mem_23276, "res_mem_23276") != 0)
        return 1;
    if (memblock_unref_device(ctx, &res_mem_23277, "res_mem_23277") != 0)
        return 1;
    if (memblock_unref_device(ctx, &res_mem_23278, "res_mem_23278") != 0)
        return 1;
    if (memblock_unref_device(ctx, &mem_23306, "mem_23306") != 0)
        return 1;
    
    float CVA_18837 = 6.0e-3F * res_18704;
    
    scalar_out_23489 = CVA_18837;
    *out_scalar_out_23888 = scalar_out_23489;
    if (memblock_unref_device(ctx, &mem_23291, "mem_23291") != 0)
        return 1;
    if (memblock_unref_device(ctx, &mem_23306, "mem_23306") != 0)
        return 1;
    if (memblock_unref_device(ctx, &mem_23288, "mem_23288") != 0)
        return 1;
    if (memblock_unref_device(ctx, &mem_23285, "mem_23285") != 0)
        return 1;
    if (memblock_unref_device(ctx, &mem_23281, "mem_23281") != 0)
        return 1;
    if (memblock_unref_device(ctx, &res_mem_23278, "res_mem_23278") != 0)
        return 1;
    if (memblock_unref_device(ctx, &res_mem_23277, "res_mem_23277") != 0)
        return 1;
    if (memblock_unref_device(ctx, &res_mem_23276, "res_mem_23276") != 0)
        return 1;
    if (memblock_unref_device(ctx, &res_mem_23275, "res_mem_23275") != 0)
        return 1;
    if (memblock_unref_device(ctx, &group_res_arr_mem_23496,
                              "group_res_arr_mem_23496") != 0)
        return 1;
    if (memblock_unref_device(ctx, &mem_23228, "mem_23228") != 0)
        return 1;
    if (memblock_unref_device(ctx, &mem_23225, "mem_23225") != 0)
        return 1;
    if (memblock_unref_device(ctx, &mem_23223, "mem_23223") != 0)
        return 1;
    if (memblock_unref_device(ctx, &mem_23221, "mem_23221") != 0)
        return 1;
    
  cleanup:
    { }
    return err;
}
struct futhark_i64_1d {
    struct memblock_device mem;
    int64_t shape[1];
} ;
struct futhark_i64_1d *futhark_new_i64_1d(struct futhark_context *ctx, const
                                          int64_t *data, int64_t dim0)
{
    struct futhark_i64_1d *bad = NULL;
    struct futhark_i64_1d *arr =
                          (struct futhark_i64_1d *) malloc(sizeof(struct futhark_i64_1d));
    
    if (arr == NULL)
        return bad;
    lock_lock(&ctx->lock);
    arr->mem.references = NULL;
    if (memblock_alloc_device(ctx, &arr->mem, (size_t) dim0 * sizeof(int64_t),
                              "arr->mem"))
        return NULL;
    arr->shape[0] = dim0;
    if ((size_t) dim0 * sizeof(int64_t) > 0)
        OPENCL_SUCCEED_OR_RETURN(clEnqueueWriteBuffer(ctx->opencl.queue,
                                                      arr->mem.mem, CL_TRUE, 0,
                                                      (size_t) dim0 *
                                                      sizeof(int64_t), data + 0,
                                                      0, NULL,
                                                      ctx->profiling_paused ||
                                                      !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                                &ctx->copy_dev_to_host_runs,
                                                                                                &ctx->copy_dev_to_host_total_runtime)));
    lock_unlock(&ctx->lock);
    return arr;
}
struct futhark_i64_1d *futhark_new_raw_i64_1d(struct futhark_context *ctx, const
                                              cl_mem data, int offset,
                                              int64_t dim0)
{
    struct futhark_i64_1d *bad = NULL;
    struct futhark_i64_1d *arr =
                          (struct futhark_i64_1d *) malloc(sizeof(struct futhark_i64_1d));
    
    if (arr == NULL)
        return bad;
    lock_lock(&ctx->lock);
    arr->mem.references = NULL;
    if (memblock_alloc_device(ctx, &arr->mem, (size_t) dim0 * sizeof(int64_t),
                              "arr->mem"))
        return NULL;
    arr->shape[0] = dim0;
    if ((size_t) dim0 * sizeof(int64_t) > 0) {
        OPENCL_SUCCEED_OR_RETURN(clEnqueueCopyBuffer(ctx->opencl.queue, data,
                                                     arr->mem.mem, offset, 0,
                                                     (size_t) dim0 *
                                                     sizeof(int64_t), 0, NULL,
                                                     ctx->profiling_paused ||
                                                     !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                               &ctx->copy_dev_to_dev_runs,
                                                                                               &ctx->copy_dev_to_dev_total_runtime)));
        if (ctx->debugging)
            OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
    }
    lock_unlock(&ctx->lock);
    return arr;
}
int futhark_free_i64_1d(struct futhark_context *ctx, struct futhark_i64_1d *arr)
{
    lock_lock(&ctx->lock);
    if (memblock_unref_device(ctx, &arr->mem, "arr->mem") != 0)
        return 1;
    lock_unlock(&ctx->lock);
    free(arr);
    return 0;
}
int futhark_values_i64_1d(struct futhark_context *ctx,
                          struct futhark_i64_1d *arr, int64_t *data)
{
    lock_lock(&ctx->lock);
    if ((size_t) arr->shape[0] * sizeof(int64_t) > 0) {
        OPENCL_SUCCEED_OR_RETURN(clEnqueueReadBuffer(ctx->opencl.queue,
                                                     arr->mem.mem,
                                                     ctx->failure_is_an_option ? CL_FALSE : CL_TRUE,
                                                     0, (size_t) arr->shape[0] *
                                                     sizeof(int64_t), data + 0,
                                                     0, NULL,
                                                     ctx->profiling_paused ||
                                                     !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                               &ctx->copy_host_to_dev_runs,
                                                                                               &ctx->copy_host_to_dev_total_runtime)));
        if (ctx->failure_is_an_option && futhark_context_sync(ctx) != 0)
            return 1;
    }
    lock_unlock(&ctx->lock);
    return 0;
}
cl_mem futhark_values_raw_i64_1d(struct futhark_context *ctx,
                                 struct futhark_i64_1d *arr)
{
    (void) ctx;
    return arr->mem.mem;
}
const int64_t *futhark_shape_i64_1d(struct futhark_context *ctx,
                                    struct futhark_i64_1d *arr)
{
    (void) ctx;
    return arr->shape;
}
struct futhark_f32_1d {
    struct memblock_device mem;
    int64_t shape[1];
} ;
struct futhark_f32_1d *futhark_new_f32_1d(struct futhark_context *ctx, const
                                          float *data, int64_t dim0)
{
    struct futhark_f32_1d *bad = NULL;
    struct futhark_f32_1d *arr =
                          (struct futhark_f32_1d *) malloc(sizeof(struct futhark_f32_1d));
    
    if (arr == NULL)
        return bad;
    lock_lock(&ctx->lock);
    arr->mem.references = NULL;
    if (memblock_alloc_device(ctx, &arr->mem, (size_t) dim0 * sizeof(float),
                              "arr->mem"))
        return NULL;
    arr->shape[0] = dim0;
    if ((size_t) dim0 * sizeof(float) > 0)
        OPENCL_SUCCEED_OR_RETURN(clEnqueueWriteBuffer(ctx->opencl.queue,
                                                      arr->mem.mem, CL_TRUE, 0,
                                                      (size_t) dim0 *
                                                      sizeof(float), data + 0,
                                                      0, NULL,
                                                      ctx->profiling_paused ||
                                                      !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                                &ctx->copy_dev_to_host_runs,
                                                                                                &ctx->copy_dev_to_host_total_runtime)));
    lock_unlock(&ctx->lock);
    return arr;
}
struct futhark_f32_1d *futhark_new_raw_f32_1d(struct futhark_context *ctx, const
                                              cl_mem data, int offset,
                                              int64_t dim0)
{
    struct futhark_f32_1d *bad = NULL;
    struct futhark_f32_1d *arr =
                          (struct futhark_f32_1d *) malloc(sizeof(struct futhark_f32_1d));
    
    if (arr == NULL)
        return bad;
    lock_lock(&ctx->lock);
    arr->mem.references = NULL;
    if (memblock_alloc_device(ctx, &arr->mem, (size_t) dim0 * sizeof(float),
                              "arr->mem"))
        return NULL;
    arr->shape[0] = dim0;
    if ((size_t) dim0 * sizeof(float) > 0) {
        OPENCL_SUCCEED_OR_RETURN(clEnqueueCopyBuffer(ctx->opencl.queue, data,
                                                     arr->mem.mem, offset, 0,
                                                     (size_t) dim0 *
                                                     sizeof(float), 0, NULL,
                                                     ctx->profiling_paused ||
                                                     !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                               &ctx->copy_dev_to_dev_runs,
                                                                                               &ctx->copy_dev_to_dev_total_runtime)));
        if (ctx->debugging)
            OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
    }
    lock_unlock(&ctx->lock);
    return arr;
}
int futhark_free_f32_1d(struct futhark_context *ctx, struct futhark_f32_1d *arr)
{
    lock_lock(&ctx->lock);
    if (memblock_unref_device(ctx, &arr->mem, "arr->mem") != 0)
        return 1;
    lock_unlock(&ctx->lock);
    free(arr);
    return 0;
}
int futhark_values_f32_1d(struct futhark_context *ctx,
                          struct futhark_f32_1d *arr, float *data)
{
    lock_lock(&ctx->lock);
    if ((size_t) arr->shape[0] * sizeof(float) > 0) {
        OPENCL_SUCCEED_OR_RETURN(clEnqueueReadBuffer(ctx->opencl.queue,
                                                     arr->mem.mem,
                                                     ctx->failure_is_an_option ? CL_FALSE : CL_TRUE,
                                                     0, (size_t) arr->shape[0] *
                                                     sizeof(float), data + 0, 0,
                                                     NULL,
                                                     ctx->profiling_paused ||
                                                     !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                               &ctx->copy_host_to_dev_runs,
                                                                                               &ctx->copy_host_to_dev_total_runtime)));
        if (ctx->failure_is_an_option && futhark_context_sync(ctx) != 0)
            return 1;
    }
    lock_unlock(&ctx->lock);
    return 0;
}
cl_mem futhark_values_raw_f32_1d(struct futhark_context *ctx,
                                 struct futhark_f32_1d *arr)
{
    (void) ctx;
    return arr->mem.mem;
}
const int64_t *futhark_shape_f32_1d(struct futhark_context *ctx,
                                    struct futhark_f32_1d *arr)
{
    (void) ctx;
    return arr->shape;
}
int futhark_entry_main(struct futhark_context *ctx, float *out0,
                       struct futhark_f32_1d **out1, const int64_t in0, const
                       int64_t in1, const struct futhark_f32_1d *in2, const
                       struct futhark_i64_1d *in3, const
                       struct futhark_f32_1d *in4, const float in5, const
                       float in6, const float in7, const float in8)
{
    struct memblock_device swap_term_mem_23220;
    
    swap_term_mem_23220.references = NULL;
    
    struct memblock_device payments_mem_23221;
    
    payments_mem_23221.references = NULL;
    
    struct memblock_device notional_mem_23222;
    
    notional_mem_23222.references = NULL;
    
    int64_t n_18078;
    int64_t n_18079;
    int64_t n_18080;
    int64_t paths_18081;
    int64_t steps_18082;
    float a_18086;
    float b_18087;
    float sigma_18088;
    float r0_18089;
    float scalar_out_23489;
    struct memblock_device out_mem_23490;
    
    out_mem_23490.references = NULL;
    
    int64_t out_arrsizze_23491;
    
    lock_lock(&ctx->lock);
    paths_18081 = in0;
    steps_18082 = in1;
    swap_term_mem_23220 = in2->mem;
    n_18078 = in2->shape[0];
    payments_mem_23221 = in3->mem;
    n_18079 = in3->shape[0];
    notional_mem_23222 = in4->mem;
    n_18080 = in4->shape[0];
    a_18086 = in5;
    b_18087 = in6;
    sigma_18088 = in7;
    r0_18089 = in8;
    
    int ret = futrts_main(ctx, &scalar_out_23489, &out_mem_23490,
                          &out_arrsizze_23491, swap_term_mem_23220,
                          payments_mem_23221, notional_mem_23222, n_18078,
                          n_18079, n_18080, paths_18081, steps_18082, a_18086,
                          b_18087, sigma_18088, r0_18089);
    
    if (ret == 0) {
        *out0 = scalar_out_23489;
        assert((*out1 =
                (struct futhark_f32_1d *) malloc(sizeof(struct futhark_f32_1d))) !=
            NULL);
        (*out1)->mem = out_mem_23490;
        (*out1)->shape[0] = out_arrsizze_23491;
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_test(struct futhark_context *ctx, float *out0, const
                       int64_t in0, const int64_t in1)
{
    int64_t paths_18528;
    int64_t steps_18529;
    float scalar_out_23489;
    
    lock_lock(&ctx->lock);
    paths_18528 = in0;
    steps_18529 = in1;
    
    int ret = futrts_test(ctx, &scalar_out_23489, paths_18528, steps_18529);
    
    if (ret == 0) {
        *out0 = scalar_out_23489;
    }
    lock_unlock(&ctx->lock);
    return ret;
}
